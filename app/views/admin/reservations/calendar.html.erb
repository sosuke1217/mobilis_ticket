<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="csrf-token" content="<%= form_authenticity_token %>">
    <title>äºˆç´„ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ </title>
    <%= stylesheet_link_tag 'calendar', media: 'all' %>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ“… äºˆç´„ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ </h1>
            <div class="header-controls">
                <div class="week-nav">
                    <button class="nav-btn" onclick="previousWeek()">â† å‰é€±</button>
                    <div class="current-week" id="currentWeek">2025å¹´ 8æœˆ10æ—¥ - 8æœˆ16æ—¥</div>
                    <button class="nav-btn" onclick="nextWeek()">æ¬¡é€± â†’</button>
                </div>
                <div class="mini-calendar-container">
                    <button class="mini-calendar-btn" onclick="toggleMiniCalendar()">
                        ğŸ“… é€±ã‚’é¸æŠ
                    </button>
                    <div class="mini-calendar" id="miniCalendar">
                        <div class="mini-calendar-header">
                            <button class="mini-calendar-year-btn" onclick="previousMiniCalendarYear()" title="å‰å¹´">â€¹â€¹</button>
                            <button class="mini-calendar-nav-btn" onclick="previousMiniCalendarMonth()" title="å‰æœˆ">â€¹</button>
                            <div class="mini-calendar-title" id="miniCalendarTitle">2025å¹´ 8æœˆ</div>
                            <button class="mini-calendar-nav-btn" onclick="nextMiniCalendarMonth()" title="ç¿Œæœˆ">â€º</button>
                            <button class="mini-calendar-year-btn" onclick="nextMiniCalendarYear()" title="ç¿Œå¹´">â€ºâ€º</button>
                        </div>
                        <div class="mini-calendar-weekdays">
                            <div class="mini-calendar-weekday">æ—¥</div>
                            <div class="mini-calendar-weekday">æœˆ</div>
                            <div class="mini-calendar-weekday">ç«</div>
                            <div class="mini-calendar-weekday">æ°´</div>
                            <div class="mini-calendar-weekday">æœ¨</div>
                            <div class="mini-calendar-weekday">é‡‘</div>
                            <div class="mini-calendar-weekday">åœŸ</div>
                        </div>
                        <div class="mini-calendar-days" id="miniCalendarDays">
                            <!-- å‹•çš„ã«ç”Ÿæˆã•ã‚Œã‚‹ -->
                        </div>
                    </div>
                </div>
                <button id="showCancellationsBtn" onclick="toggleCancellationDisplay()" class="cancellation-btn">
                    âŒ ã‚­ãƒ£ãƒ³ã‚»ãƒ«å±¥æ­´ (<span id="cancellation-count">0</span>)
                </button>
                <button class="settings-btn" onclick="openSettingsModal()">
                    âš™ï¸ äºˆç´„å¯èƒ½æ—¥æ™‚ã‚’ç·¨é›†
                </button>
            </div>
        </div>
        
        <div id="cancellation-display" class="cancellation-display" style="display: none;">
            <div class="cancellation-header">
                <h3>âŒ ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚ŒãŸäºˆç´„</h3>
                <button onclick="clearCancellationDisplay()" class="clear-btn">ã‚¯ãƒªã‚¢</button>
            </div>
            <div id="cancellation-list" class="cancellation-list">
                <!-- ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚ŒãŸäºˆç´„ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™ -->
            </div>
        </div>

        <div class="schedule-container">
            <div class="schedule-header">
                <div class="time-column-header">æ™‚åˆ»</div>
                <div class="day-header sunday">æ—¥<br><span style="font-size: 12px;">8/10</span></div>
                <div class="day-header">æœˆ<br><span style="font-size: 12px;">8/11</span></div>
                <div class="day-header">ç«<br><span style="font-size: 12px;">8/12</span></div>
                <div class="day-header">æ°´<br><span style="font-size: 12px;">8/13</span></div>
                <div class="day-header">æœ¨<br><span style="font-size: 12px;">8/14</span></div>
                <div class="day-header">é‡‘<br><span style="font-size: 12px;">8/15</span></div>
                <div class="day-header saturday">åœŸ<br><span style="font-size: 12px;">8/16</span></div>
            </div>
            
            <div class="schedule-body" id="scheduleBody">
                <!-- æ™‚é–“ã‚¹ãƒ­ãƒƒãƒˆã¯å‹•çš„ã«ç”Ÿæˆã•ã‚Œã‚‹ -->
            </div>
        </div>
    </div>

    <!-- è¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>âš™ï¸ äºˆç´„å¯èƒ½æ—¥æ™‚ã‚’ç·¨é›†</h2>
                <span class="close" onclick="closeSettingsModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="settings-tabs">
                    <button class="tab-button active" onclick="switchTab('general')">ä¸€å›é™ã‚Šã®å¤‰æ›´</button>
                    <button class="tab-button" onclick="switchTab('recurring')">å®šæœŸçš„ãªã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«</button>
                </div>

                <!-- ä¸€å›é™ã‚Šã®å¤‰æ›´ã‚¿ãƒ– -->
                <div id="general-tab" class="tab-content active">
                    <div id="week-info" style="margin-bottom: 20px; padding: 12px; background: #f8f9fa; border-radius: 6px; border-left: 4px solid #007bff;">
                        <strong>ç¾åœ¨ã®é€±:</strong> <span id="current-week-display"></span>
                        <br><small id="schedule-type-info" style="color: #666;"></small>
                    </div>
                    
                    <div id="daySettings">
                        <!-- æ›œæ—¥åˆ¥è¨­å®šãŒå‹•çš„ã«ç”Ÿæˆã•ã‚Œã‚‹ -->
      </div>
    </div>

                <!-- å®šæœŸçš„ãªã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¿ãƒ– -->
                <div id="recurring-tab" class="tab-content">
                    <p style="margin-bottom: 20px; color: #666;">ä»Šå¾Œã®é€±ã«é©ç”¨ã™ã‚‹ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è¨­å®š</p>
                    
                    <div id="recurringDaySettings">
                        <!-- å®šæœŸçš„ãªè¨­å®šãŒå‹•çš„ã«ç”Ÿæˆã•ã‚Œã‚‹ -->
        </div>
        </div>
        </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeSettingsModal()">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                <button class="btn btn-success" onclick="saveSettings()">å®Œäº†</button>
          </div>
        </div>
        </div>

    <!-- äºˆç´„ä½œæˆãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="bookingModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>ğŸ“… æ–°è¦äºˆç´„ä½œæˆ</h2>
                <span class="close" onclick="closeBookingModal()">&times;</span>
            </div>
            <div class="modal-body">
                <form id="bookingForm">
                    <div class="form-group mb-3">
                        <label for="bookingDate" class="form-label">äºˆç´„æ—¥æ™‚</label>
                        <input type="text" id="bookingDate" class="form-control" readonly>
                    </div>
                    
                    <div class="form-group mb-3">
                        <label for="bookingTime" class="form-label">é–‹å§‹æ™‚é–“</label>
                        <input type="text" id="bookingTime" class="form-control" readonly>
      </div>
                    
                    <div class="form-group mb-3">
                        <label for="bookingDuration" class="form-label">ã‚³ãƒ¼ã‚¹é¸æŠ</label>
                        <select id="bookingDuration" class="form-select" required>
                            <option value="">ã‚³ãƒ¼ã‚¹ã‚’é¸æŠã—ã¦ãã ã•ã„</option>
                            <option value="40">40åˆ†ã‚³ãƒ¼ã‚¹</option>
                            <option value="60">60åˆ†ã‚³ãƒ¼ã‚¹</option>
                            <option value="80">80åˆ†ã‚³ãƒ¼ã‚¹</option>
                        </select>
    </div>
                    
                    <div class="form-group mb-3">
                        <label for="customerName" class="form-label">ãŠå®¢æ§˜å</label>
                        <div class="position-relative">
                            <input type="text" id="customerName" class="form-control" required placeholder="å±±ç”°å¤ªéƒ" autocomplete="off">
                            <div id="userSearchResults" class="user-search-results" style="display: none;"></div>
                        </div>
                    </div>
                    
                    <div class="form-group mb-3">
                        <label for="customerPhone" class="form-label">é›»è©±ç•ªå·</label>
                        <input type="tel" id="customerPhone" class="form-control" required placeholder="090-1234-5678">
                    </div>
                    
                    <div class="form-group mb-3">
                        <label for="customerEmail" class="form-label">ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹</label>
                        <input type="email" id="customerEmail" class="form-control" placeholder="example@email.com">
        </div>
                    
                    <div class="form-group mb-3">
                        <label for="bookingNote" class="form-label">å‚™è€ƒ</label>
                        <textarea id="bookingNote" class="form-control" rows="3" placeholder="ã”è¦æœ›ã‚„ã”è³ªå•ãŒã‚ã‚Œã°ã”è¨˜å…¥ãã ã•ã„"></textarea>
        </div>
                    
                    <div class="form-group mb-3">
                        <label for="bookingStatus" class="form-label">äºˆç´„ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹</label>
                        <select id="bookingStatus" class="form-select">
                            <option value="tentative">ä»®äºˆç´„</option>
                            <option value="confirmed">ç¢ºå®š</option>
                        </select>
        </div>
                </form>
          </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeBookingModal()">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                <button class="btn btn-success" onclick="createBooking()">äºˆç´„ä½œæˆ</button>
        </div>
        </div>
      </div>

    <!-- äºˆç´„è©³ç´°ãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="reservationDetailModal" class="modal">
        <div class="modal-content">
            <div class="modal-body" id="reservationDetailContent">
                <span class="close" onclick="closeReservationDetailModal()">&times;</span>
                <!-- å‹•çš„ã«ç”Ÿæˆã•ã‚Œã‚‹ -->
            </div>
            <div class="modal-footer">
                                 <button type="submit" class="btn btn-primary" form="reservationEditForm" onclick="console.log('ğŸ’¾ Save button clicked')">ä¿å­˜</button>
                 <button type="button" class="btn btn-warning" onclick="cancelReservation()">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                 <button type="button" class="btn btn-danger" onclick="deleteReservation()">å‰Šé™¤</button>
                 <button type="button" class="btn btn-secondary" onclick="closeReservationDetailModal()">é–‰ã˜ã‚‹</button>
            </div>
        </div>
    </div>



    <!-- ãƒ¦ãƒ¼ã‚¶ãƒ¼é¸æŠãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="userSelectionModal" class="modal">
        <div class="modal-content">
            <div class="modal-body">
                <span class="close" onclick="closeUserSelectionModal()">&times;</span>
                <h3>ãŠå®¢æ§˜ã®å¤‰æ›´</h3>
                <div class="user-selection-settings">
                    <div class="form-group">
                        <label for="userSearchInput" class="form-label">ãŠå®¢æ§˜ã‚’æ¤œç´¢ã—ã¦ãã ã•ã„</label>
                        <input type="text" id="userSearchInput" class="form-control" placeholder="ãŠå®¢æ§˜åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„..." autocomplete="off">
                    </div>
                    <div class="user-search-results" id="userSelectionSearchResults">
                        <!-- æ¤œç´¢çµæœãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™ -->
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" onclick="closeUserSelectionModal()">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                        <button class="btn btn-primary" onclick="return saveUserSelection()" id="saveUserBtn" disabled>å¤‰æ›´</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentWeekStart = new Date(2025, 7, 10); // 2025å¹´8æœˆ10æ—¥ï¼ˆæ—¥æ›œæ—¥ï¼‰
        let weeklySchedules = {}; // é€±åˆ¥ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼ˆé€±ã®ã‚­ãƒ¼ã§ä¿å­˜ï¼‰
        let defaultSchedule = {}; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
        let reservations = {}; // äºˆç´„ãƒ‡ãƒ¼ã‚¿
        let miniCalendarMonth = new Date(2025, 7, 1); // ãƒŸãƒ‹ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã®è¡¨ç¤ºæœˆï¼ˆ8æœˆï¼‰
        let clickedDate = null; // ã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸæ—¥ä»˜
        let currentReservation = null; // ç¾åœ¨è¡¨ç¤ºä¸­ã®äºˆç´„
        let searchTimeout = null; // æ¤œç´¢ã®ãƒ‡ãƒã‚¦ãƒ³ã‚¹ç”¨
        let isEditingReservation = false; // äºˆç´„ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ãƒ•ãƒ©ã‚°
        let reservationToEdit = null; // ç·¨é›†å¯¾è±¡ã®äºˆç´„ãƒ‡ãƒ¼ã‚¿
        let cancelledReservations = []; // ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚ŒãŸäºˆç´„ã®ãƒªã‚¹ãƒˆ
        let cancellationDisplayReady = false; // ã‚­ãƒ£ãƒ³ã‚»ãƒ«è¡¨ç¤ºã®æº–å‚™å®Œäº†ãƒ•ãƒ©ã‚°
        let domReady = false; // DOMã®æº–å‚™å®Œäº†ãƒ•ãƒ©ã‚°

        // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‹ã‚‰ã‚­ãƒ£ãƒ³ã‚»ãƒ«å±¥æ­´ã‚’èª­ã¿è¾¼ã¿
        function loadCancelledReservations() {
            try {
                const stored = localStorage.getItem('cancelledReservations');
                if (stored) {
                    cancelledReservations = JSON.parse(stored);
        
                }
            } catch (error) {
                console.error('âŒ Error loading cancelled reservations:', error);
                cancelledReservations = [];
            }
        }

        // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ã‚­ãƒ£ãƒ³ã‚»ãƒ«å±¥æ­´ã‚’ä¿å­˜
        function saveCancelledReservations() {
            try {
                localStorage.setItem('cancelledReservations', JSON.stringify(cancelledReservations));
    
            } catch (error) {
                console.error('âŒ Error saving cancelled reservations:', error);
            }
        }
        
        // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‹ã‚‰äºˆç´„ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿
        <% if @reservations.present? %>
            console.log('ğŸ”„ Loading server-side reservations:', <%= @reservations.count %>);
            <% @reservations.each do |reservation| %>
                (function() {
                    const reservationDateKey = '<%= reservation.start_time.strftime('%Y-%m-%d') %>';
                    if (!reservations[reservationDateKey]) {
                        reservations[reservationDateKey] = [];
                    }
                    const reservationData = {
                        id: <%= reservation.id %>,
                        time: '<%= reservation.start_time.strftime('%H:%M') %>',
                        duration: <%= extract_course_duration(reservation.course) %>,
                        customer: '<%= j(reservation.name || reservation.user&.name || 'æœªè¨­å®š') %>',
                        phone: '<%= j(reservation.user&.phone_number || '') %>',
                        email: '<%= j(reservation.user&.email || '') %>',
                        note: '<%= j(reservation.note || '') %>',
                        status: '<%= reservation.status %>',
                        createdAt: '<%= reservation.created_at.iso8601 %>',
                        updatedAt: '<%= reservation.updated_at.iso8601 %>',
                        userId: <%= reservation.user_id || 'null' %>,
                        effective_interval_minutes: <%= reservation.effective_interval_minutes || 0 %>,
                        individual_interval_minutes: <%= reservation.individual_interval_minutes || 'null' %>
                    };
                    reservations[reservationDateKey].push(reservationData);
                    console.log('ğŸ“… Server-side reservation loaded:', {
                        date: reservationDateKey,
                        id: reservationData.id,
                        userId: reservationData.userId,
                        customer: reservationData.customer,
                        createdAt: reservationData.createdAt,
                        updatedAt: reservationData.updatedAt,
                        effective_interval_minutes: reservationData.effective_interval_minutes,
                        individual_interval_minutes: reservationData.individual_interval_minutes
                    });
                })();
            <% end %>
        <% else %>
            console.log('â„¹ï¸ No server-side reservations found');
        <% end %>
        
        // æ›œæ—¥ã®åå‰
        const dayNames = ['æ—¥', 'æœˆ', 'ç«', 'æ°´', 'æœ¨', 'é‡‘', 'åœŸ'];
        const dayNamesLong = ['æ—¥æ›œæ—¥', 'æœˆæ›œæ—¥', 'ç«æ›œæ—¥', 'æ°´æ›œæ—¥', 'æœ¨æ›œæ—¥', 'é‡‘æ›œæ—¥', 'åœŸæ›œæ—¥'];
        
        // æœˆã®åå‰
        const monthNames = ['1æœˆ', '2æœˆ', '3æœˆ', '4æœˆ', '5æœˆ', '6æœˆ', '7æœˆ', '8æœˆ', '9æœˆ', '10æœˆ', '11æœˆ', '12æœˆ'];
        
        // åˆæœŸåŒ–
        function init() {
            // ãƒ¢ãƒ¼ãƒ€ãƒ«å¤–ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹æ©Ÿèƒ½ã‚’è¨­å®š
            setupModalClickOutside();
            
            Promise.all([
                loadShiftSettingsFromBackend(),
                loadReservationsFromBackend()
            ]).then(() => {
                renderWeekView();
                renderDaySettings();
                renderMiniCalendar();
                showDragHint();
            });
        }

        // ãƒ‰ãƒ©ãƒƒã‚°ãƒ’ãƒ³ãƒˆã‚’è¡¨ç¤º
        function showDragHint() {
            // ãƒ’ãƒ³ãƒˆè¦ç´ ã‚’ä½œæˆ
            const hint = document.createElement('div');
            hint.className = 'drag-hint';
            hint.textContent = 'ğŸ’¡ äºˆç´„ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦æ™‚é–“ã‚’å¤‰æ›´ã§ãã¾ã™';
            document.body.appendChild(hint);
            
            // 3ç§’å¾Œã«è¡¨ç¤º
            setTimeout(() => {
                hint.classList.add('show');
            }, 1000);
            
            // 5ç§’å¾Œã«éè¡¨ç¤º
            setTimeout(() => {
                hint.classList.remove('show');
                setTimeout(() => {
                    if (hint.parentNode) {
                        hint.parentNode.removeChild(hint);
                    }
                }, 300);
            }, 5000);
        }

        // å„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å¤‰æ›´æ™‚ã«ä¿å­˜ã‚’å®Ÿè¡Œ
        function updateCalendarOnStatusChange() {
            console.log('ğŸ”„ Status changed - triggering save');
            saveReservationChanges({preventDefault: () => {}});
        }

        function updateCalendarOnCourseChange() {
            console.log('ğŸ”„ Course changed - triggering save');
            saveReservationChanges({preventDefault: () => {}});
        }

        // ãƒ¦ãƒ¼ã‚¶ãƒ¼æ¤œç´¢çµæœè¡¨ç¤ºé–¢æ•°
        function displayUserSearchResultsForModal(users) {
            console.log('ğŸ” displayUserSearchResultsForModal called with users:', users);
            const resultsContainer = document.getElementById('userSelectionSearchResults');
            
            if (!users || users.length === 0) {
                resultsContainer.innerHTML = '<div class="no-results">è©²å½“ã™ã‚‹ãŠå®¢æ§˜ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“</div>';
                resultsContainer.style.display = 'block';
                return;
            }
            
            const resultsHTML = users.map(user => `
                <div class="user-result-item" onclick="selectUserForModal({userId: ${user.id}, name: '${user.name}', phone: '${user.phone_number}', email: '${user.email}'})">
                    <div class="user-name">${user.name}</div>
                    <div class="user-details">${user.phone_number} | ${user.email}</div>
                </div>
            `).join('');
            
            resultsContainer.innerHTML = resultsHTML;
            resultsContainer.style.display = 'block';
            console.log('ğŸ” Search results displayed:', users.length, 'users');
        }

        // ãƒ¦ãƒ¼ã‚¶ãƒ¼é¸æŠé–¢æ•°
        function selectUserForModal(userData) {
            console.log('ğŸ” selectUserForModal called with:', userData);
            
            // Set the global selectedUser that the existing saveUserSelection function expects
            window.selectedUser = {
                id: userData.userId,
                name: userData.name,
                phone_number: userData.phone,
                email: userData.email
            };
            
            console.log('âœ… Set window.selectedUser:', window.selectedUser);
            
            // Hide search results and enable save button
            hideUserSearchResults();
            document.getElementById('saveUserBtn').disabled = false;
        }

        // ãƒ¦ãƒ¼ã‚¶ãƒ¼æ¤œç´¢çµæœã‚’éš ã™é–¢æ•°
        function hideUserSearchResults() {
            console.log('ğŸ” hideUserSearchResults called');
            const resultsContainer = document.getElementById('userSelectionSearchResults');
            resultsContainer.style.display = 'none';
            resultsContainer.innerHTML = '';
            console.log('ğŸ” Search results hidden and cleared');
        }

        // ãƒ¦ãƒ¼ã‚¶ãƒ¼æ¤œç´¢ã¨ãƒ¢ãƒ¼ãƒ€ãƒ«ç®¡ç†é–¢æ•°
        function openUserSelectionModal() {
            console.log('ğŸ” openUserSelectionModal called');
            const modal = document.getElementById('userSelectionModal');
            const searchInput = document.getElementById('userSearchInput');
            const searchResults = document.getElementById('userSelectionSearchResults');
            
            console.log('ğŸ” Search input found and cleared');
            if (searchInput) {
                searchInput.value = '';
                searchInput.focus();
            }
            
            console.log('ğŸ” Search results cleared and hidden');
            if (searchResults) {
                searchResults.innerHTML = '';
                searchResults.style.display = 'none';
            }
            
            // Reset selected user
            window.selectedUser = null;
            document.getElementById('saveUserBtn').disabled = true;
            
            // Add input event listener for search
            if (searchInput && !searchInput.hasAttribute('data-listener-added')) {
                console.log('ğŸ” Input event listener added');
                searchInput.addEventListener('input', function(e) {
                    handleUserSearch(e.target.value);
                });
                searchInput.setAttribute('data-listener-added', 'true');
            }
            
            // Show modal
            modal.style.display = 'block';
            console.log('ğŸ” Modal displayed');
        }

        function handleUserSearch(query) {
            console.log('ğŸ” handleUserSearch called with query:', query);
            
            if (query.length < 2) {
                console.log('ğŸ” Query too short, hiding results');
                hideUserSearchResults();
                return;
            }
            
            console.log('ğŸ” Setting timeout for search');
            clearTimeout(window.searchTimeout);
            window.searchTimeout = setTimeout(() => {
                console.log('ğŸ” Calling searchUsersForModal with:', query);
                searchUsersForModal(query);
            }, 300);
        }

        function searchUsersForModal(query) {
            console.log('ğŸ” searchUsersForModal called with query:', query);
            
            fetch(`/admin/users/search?q=${encodeURIComponent(query)}`)
                .then(response => {
                    console.log('ğŸ” Search response status:', response.status);
                    return response.json();
                })
                .then(data => {
                    console.log('ğŸ” Search response data:', data);
                    if (data.success) {
                        displayUserSearchResultsForModal(data.users);
                    }
                })
                .catch(error => {
                    console.error('âŒ Search error:', error);
                });
        }

        // äºˆç´„å¤‰æ›´ã‚’ä¿å­˜
        function saveReservationChanges(event) {
            if (event && event.preventDefault) {
                event.preventDefault();
            }
            
            if (!currentReservation) {
                showMessage('äºˆç´„ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚', 'error');
                return false;
            }

            // ãƒ•ã‚©ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            const courseSelect = document.getElementById('edit-course');
            const statusSelect = document.getElementById('edit-status');
            const noteTextarea = document.getElementById('edit-note');
            
            console.log('ğŸ“ Form elements found:', {
                courseSelect: courseSelect ? 'found' : 'not found',
                statusSelect: statusSelect ? 'found' : 'not found',
                noteTextarea: noteTextarea ? 'found' : 'not found'
            });
            
            const newCourse = courseSelect ? courseSelect.value : `${currentReservation.duration}åˆ†`;
            const newDuration = extractDurationFromCourse(newCourse);
            const currentInterval = currentReservation.effective_interval_minutes ?? 10;
            
            // å–¶æ¥­æ™‚é–“å†…ã«åã¾ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ - use proper validation object like other functions
            let reservationDate = currentReservation.date;
            if (!reservationDate) {
                // Fallback: search reservations object for this reservation's date
                console.log('ğŸ” Save validation fallback: searching reservations object for reservation ID:', currentReservation.id);
                for (const [dateKey, dayReservations] of Object.entries(reservations)) {
                    const foundReservation = dayReservations.find(r => r.id === currentReservation.id);
                    if (foundReservation) {
                        reservationDate = dateKey;
                        console.log('ğŸŸ© Found reservation date in save validation fallback:', reservationDate);
                        break;
                    }
                }
            }
            
            const validationReservation = {
                ...currentReservation,
                date: reservationDate,
                time: currentReservation.time || currentReservation.startTime
            };
            
            console.log('ğŸ” Save validation reservation object:', validationReservation);
            
            const businessHoursValidation = validateReservationTimeWithinBusinessHours(validationReservation, newDuration, currentInterval);
            if (!businessHoursValidation.valid) {
                showMessage(businessHoursValidation.message, 'error');
                return;
            }
            
            // é‡è¤‡ãƒã‚§ãƒƒã‚¯
            const overlapValidation = validateReservationOverlap(validationReservation, newDuration, currentInterval, currentReservation.id);
            if (!overlapValidation.valid) {
                showMessage(overlapValidation.message, 'error');
                return;
            }
            
            const formData = {
                reservation: {
                    course: newCourse,
                    status: statusSelect ? statusSelect.value : currentReservation.status,
                    note: noteTextarea ? noteTextarea.value : currentReservation.note || ''
                }
            };
            
            // ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã‚’é€ä¿¡
            if (currentReservation.userId) {
                formData.reservation.user_id = currentReservation.userId;
            }

            // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã«æ›´æ–°ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡
            const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');
            
            fetch(`/admin/reservations/${currentReservation.id}/update_booking`, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-Token': csrfToken
                },
                body: JSON.stringify(formData)
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(errorData => {
                        throw new Error(`HTTP error! status: ${response.status}, message: ${errorData.message || 'Unknown error'}`);
                    }).catch(() => {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    });
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    // ãƒ¦ãƒ¼ã‚¶ãƒ¼å¤‰æ›´æ¤œå‡ºã®ãŸã‚ã«å…ƒã®ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã‚’ä¿å­˜
                    const originalUserId = currentReservation.userId;
                    
                    // ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°
                    const reservationData = data.reservation;
                    const updatedReservation = {
                        ...currentReservation,
                        customer: reservationData.name || reservationData.user?.name || 'æœªè¨­å®š',
                        phone: reservationData.user?.phone_number || '',
                        email: reservationData.user?.email || '',
                        duration: extractDurationFromCourse(reservationData.course),
                        status: reservationData.status,
                        note: reservationData.note || '',
                        updatedAt: reservationData.updated_at,
                        userId: window.currentUserId || currentReservation.userId // æ–°ã—ã„ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã‚’è¨­å®š
                    };
                    
                    // ã‚°ãƒ­ãƒ¼ãƒãƒ«reservationsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ›´æ–°
                    const reservationDateKey = formatDateKey(new Date(currentReservation.start_time || currentReservation.time));
                    if (reservations[reservationDateKey]) {
                        const reservationIndex = reservations[reservationDateKey].findIndex(r => r.id === currentReservation.id);
                        if (reservationIndex !== -1) {
                            reservations[reservationDateKey][reservationIndex] = updatedReservation;
                        }
                    }
                    
                    // currentReservationã‚’æ›´æ–°
                    currentReservation = updatedReservation;
                    
                    // ãƒ¢ãƒ¼ãƒ€ãƒ«å†…ã®å¤‰æ›´æ—¥æ™‚ã‚’æ›´æ–°
                    let updateTimestamp = reservationData.updated_at;
                    if (!updateTimestamp) {
                        // Backend doesn't provide updated_at, use current time
                        updateTimestamp = new Date().toISOString();
                        console.log('ğŸ” Backend missing updated_at, using current time:', updateTimestamp);
                    }
                    console.log('ğŸ” About to call updateModalUpdatedAt with:', updateTimestamp);
                    updateModalUpdatedAt(updateTimestamp);
                    
                    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå¤‰æ›´ã•ã‚ŒãŸå ´åˆã€ãƒ¢ãƒ¼ãƒ€ãƒ«ã®ãƒã‚±ãƒƒãƒˆã¨å±¥æ­´ã‚’å†èª­ã¿è¾¼ã¿
                    console.log('ğŸ” User change check:', {
                        windowCurrentUserId: window.currentUserId,
                        originalUserId: originalUserId,
                        updatedReservationCustomer: updatedReservation.customer,
                        isUserChanged: window.currentUserId && window.currentUserId !== originalUserId
                    });
                    
                    if (window.currentUserId && window.currentUserId !== originalUserId) {
                        console.log('ğŸ”„ User changed, reloading modal data for new user:', window.currentUserId);
                        
                        // ãƒ¢ãƒ¼ãƒ€ãƒ«ã®é¡§å®¢åã‚’æ›´æ–°
                        const customerNameElement = document.querySelector('.customer-name-large');
                        console.log('ğŸ” Customer name element found:', customerNameElement);
                        if (customerNameElement) {
                            console.log('ğŸ”„ Updating customer name from:', customerNameElement.textContent, 'to:', updatedReservation.customer);
                            customerNameElement.textContent = updatedReservation.customer;
                            console.log('ğŸ”„ Updated customer name display to:', updatedReservation.customer);
                        } else {
                            console.error('âŒ Customer name element not found!');
                        }
                        
                        // ãƒã‚±ãƒƒãƒˆæƒ…å ±ã‚’å†èª­ã¿è¾¼ã¿
                        loadTicketsForUser(window.currentUserId);
                        
                        // å±¥æ­´æƒ…å ±ã‚’å†èª­ã¿è¾¼ã¿
                        loadReservationHistoryForUser(window.currentUserId);
                    } else {
                        console.log('ğŸ” No user change detected or window.currentUserId not set');
                    }
                    
                    // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚’å†æç”»
                    generateTimeSlots();
                    
                    showMessage('äºˆç´„ãŒæ›´æ–°ã•ã‚Œã¾ã—ãŸã€‚', 'success');
                    
                    // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã„ãŸã¾ã¾ã«ã—ã¦å¤‰æ›´å†…å®¹ã‚’ç¢ºèªã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹
                    console.log('ğŸ”„ Keeping modal open to show updated information');
                    
                    // çŸ­æ™‚é–“å¾Œã«ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå¤‰æ›´ã‚’ç¢ºèªã§ãã‚‹ã‚ˆã†ã«ï¼‰
                    setTimeout(() => {
                        if (window.currentUserId && window.currentUserId !== originalUserId) {
                            console.log('ğŸ”„ User was changed, extended delay before closing modal');
                            // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå¤‰æ›´ã•ã‚ŒãŸå ´åˆã¯ã•ã‚‰ã«é•·ãå¾…ã¤
                            setTimeout(() => {
                    closeReservationDetailModal();
                            }, 3000);
                        } else {
                            console.log('ğŸ”„ Normal delay before closing modal');
                            closeReservationDetailModal();
                        }
                    }, 1000);
                } else {
                    showMessage(`äºˆç´„ã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ: ${data.message}`, 'error');
                }
            })
            .catch(error => {
                console.error('Error updating reservation:', error);
                showMessage('äºˆç´„ã®æ›´æ–°ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚', 'error');
            });
            
            return false; // Prevent any form submission
        }

        // ãƒ¢ãƒ¼ãƒ€ãƒ«å†…ã®å¤‰æ›´æ—¥æ™‚ã‚’å³åº§ã«æ›´æ–°
        function updateModalUpdatedAt(updatedAt) {
            console.log('ğŸ” updateModalUpdatedAt called with:', updatedAt);
            
            const modal = document.getElementById('reservationDetailModal');
            console.log('ğŸ” Modal found:', modal ? 'yes' : 'no');
            if (!modal) {
                console.log('âŒ Modal not found, cannot update change date');
                return;
            }
            
            const systemInfoSection = modal.querySelector('.system-info-section');
            console.log('ğŸ” System info section found:', systemInfoSection ? 'yes' : 'no');
            if (!systemInfoSection) {
                console.log('âŒ System info section not found, cannot update change date');
                // Let's try to find what sections do exist
                const allSections = modal.querySelectorAll('div[class*="section"], div[class*="info"]');
                console.log('ğŸ” Available sections in modal:', Array.from(allSections).map(s => s.className));
                return;
            }
            
            // æ—¢å­˜ã®å¤‰æ›´æ—¥æ™‚è¦ç´ ã‚’å‰Šé™¤
            const detailItems = systemInfoSection.querySelectorAll('.detail-item');
            detailItems.forEach(item => {
                const label = item.querySelector('.detail-label');
                if (label && label.textContent === 'å¤‰æ›´æ—¥æ™‚') {
                    item.remove();
                }
            });
            
            // ä½œæˆæ—¥æ™‚è¦ç´ ã‚’å–å¾—
            let createdAtItem = null;
            detailItems.forEach(item => {
                const label = item.querySelector('.detail-label');
                if (label && label.textContent === 'ä½œæˆæ—¥æ™‚') {
                    createdAtItem = item;
                }
            });
            
            if (!createdAtItem) return;
            
            // æ–°ã—ã„å¤‰æ›´æ—¥æ™‚è¦ç´ ã‚’ä½œæˆ
            const updatedAtItem = document.createElement('div');
            updatedAtItem.className = 'detail-item';
            updatedAtItem.innerHTML = `
                <span class="detail-label">å¤‰æ›´æ—¥æ™‚</span>
                <span class="detail-value">${new Date(updatedAt).toLocaleString('ja-JP')}</span>
            `;
            
            // ä½œæˆæ—¥æ™‚ã®å¾Œã«æŒ¿å…¥
            createdAtItem.insertAdjacentElement('afterend', updatedAtItem);
            console.log('âœ… Successfully added change date/time to modal');
        }

        // Add event listener to course dropdown to update change time immediately
        document.addEventListener('DOMContentLoaded', function() {
            // Add event listener for course changes
            document.addEventListener('change', function(event) {
                if (event.target && event.target.id === 'edit-course') {
                    console.log('ğŸ” Course dropdown changed, updating change time');
                    const currentTime = new Date().toISOString();
                    updateModalUpdatedAt(currentTime);
                }
            });
        });

        // Fixed updateIntervalOnChange function for calendar.html.erb
        // Replace the existing updateIntervalOnChange function around line 703 with this version

        function updateIntervalOnChange() {
            if (!currentReservation) {
                showMessage('äºˆç´„ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚', 'error');
                return;
            }

            const newInterval = parseInt(document.getElementById('edit-interval').value);
            const currentDuration = currentReservation.duration || 60;
            
            console.log('ğŸ” updateIntervalOnChange called with:', {
                newInterval,
                currentDuration,
                currentReservation
            });
            
            console.log('ğŸ” DEBUG: Full currentReservation object:', JSON.stringify(currentReservation, null, 2));

            // Extract time and date from the current reservation - this is the key fix
            let startTime;
            let reservationDate;
            
            // Try multiple ways to get the start time
            if (currentReservation.time) {
                startTime = currentReservation.time;
            } else if (currentReservation.startTime) {
                startTime = currentReservation.startTime;
            } else {
                // Try to get from form fields as fallback
                startTime = document.getElementById('reservationTime')?.value;
            }
            
            // Try multiple ways to get the date
            if (currentReservation.date) {
                reservationDate = currentReservation.date;
            } else if (currentReservation.reservationDate) {
                reservationDate = currentReservation.reservationDate;
            } else {
                // Try to get from form fields as fallback
                reservationDate = document.getElementById('reservationDate')?.value;
            }
            
            // If we still don't have date, try to extract from any available datetime
            if (!reservationDate && currentReservation.start_time) {
                try {
                    const startDateTime = new Date(currentReservation.start_time);
                    const year = startDateTime.getFullYear();
                    const month = String(startDateTime.getMonth() + 1).padStart(2, '0');
                    const day = String(startDateTime.getDate()).padStart(2, '0');
                    reservationDate = `${year}-${month}-${day}`;
                } catch (e) {
                    console.error('âŒ Error parsing start_time:', e);
                }
            }
            
            // Final fallback: search through reservations object to find the date key
            if (!reservationDate && currentReservation.id) {
                console.log('ğŸ” Final fallback: searching reservations object for reservation ID:', currentReservation.id);
                for (const dateKey of Object.keys(reservations)) {
                    const dayReservations = reservations[dateKey];
                    if (dayReservations && dayReservations.find(r => r.id === currentReservation.id)) {
                        reservationDate = dateKey;
                        console.log('ğŸŸ© Found reservation date in fallback:', dateKey);
                        break;
                    }
                }
            }
            
            console.log('ğŸ” Interval change attempt:', {
                newInterval,
                currentDuration,
                currentReservation,
                startTime,
                date: reservationDate,
                extractedStartTime: startTime,
                extractedDate: reservationDate
            });

            // Validation - ensure we have required data
            if (!startTime || !reservationDate) {
                console.error('âŒ Missing required data for validation:', { startTime, reservationDate });
                showMessage('äºˆç´„ã®æ™‚é–“ãƒ»æ—¥ä»˜æƒ…å ±ãŒå–å¾—ã§ãã¾ã›ã‚“', 'warning');
                return;
            }

            console.log('ğŸ” About to call business hours validation with:', {
                reservation: {
                    date: reservationDate,
                    time: startTime,
                    start_time: currentReservation.start_time
                },
                duration: currentDuration,
                interval: newInterval
            });

            // Create a properly structured reservation object for validation
            const validationReservation = {
                date: reservationDate,
                time: startTime,
                start_time: currentReservation.start_time
            };

            const validation = validateReservationTimeWithinBusinessHours(
                validationReservation,
                currentDuration,
                newInterval
            );

            console.log('ğŸ” Interval change business hours validation result:', validation);

            if (!validation.valid) {
                console.log('âŒ Business hours validation failed, showing error and returning');
                showMessage(validation.message, 'error');
                // å…ƒã®å€¤ã«æˆ»ã™
                const intervalSelect = document.getElementById('edit-interval');
                intervalSelect.value = currentReservation.effective_interval_minutes ?? 10;
                return;
            }
            
            // é‡è¤‡ãƒã‚§ãƒƒã‚¯
            console.log('ğŸ” About to call overlap validation with:', {
                reservation: validationReservation,
                duration: currentDuration,
                interval: newInterval
            });
            const overlapValidation = validateReservationOverlap(validationReservation, currentDuration, newInterval, currentReservation.id);
            console.log('ğŸ” Interval change overlap validation result:', overlapValidation);
            if (!overlapValidation.valid) {
                showMessage(overlapValidation.message, 'error');
                // å…ƒã®å€¤ã«æˆ»ã™
                const intervalSelect = document.getElementById('edit-interval');
                intervalSelect.value = currentReservation.effective_interval_minutes ?? 10;
                return;
            }

            console.log('âœ… Interval change validation passed');

            const reservationId = currentReservation.id;

            // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã«æ›´æ–°ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡
            const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');
            
            const requestBody = {
                reservation: {
                individual_interval_minutes: newInterval
                }
            };
            console.log('ğŸ” Sending interval update request:', {
                reservationId,
                newInterval,
                requestBody
            });
            
            fetch(`/admin/reservations/${reservationId}/update_interval`, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-Token': csrfToken
                },
                body: JSON.stringify(requestBody)
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                console.log('ğŸ” Backend response for interval update:', data);
                if (data.success) {
                    // ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°
                    currentReservation.effective_interval_minutes = newInterval;
                    currentReservation.individual_interval_minutes = newInterval;
                    console.log('ğŸ” Updated currentReservation:', currentReservation);
                    
                    // updatedAtãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æ›´æ–°
                    let updateTimestamp = data.updated_at;
                    if (!updateTimestamp) {
                        // Backend doesn't provide updated_at, use current time
                        updateTimestamp = new Date().toISOString();
                        console.log('ğŸ” Interval update: Backend missing updated_at, using current time:', updateTimestamp);
                    }
                    currentReservation.updatedAt = updateTimestamp;
                    // ãƒ¢ãƒ¼ãƒ€ãƒ«å†…ã®å¤‰æ›´æ—¥æ™‚ã‚’æ›´æ–°
                    console.log('ğŸ” Interval update: About to call updateModalUpdatedAt with:', updateTimestamp);
                    updateModalUpdatedAt(updateTimestamp);
                        
                                            // ã‚°ãƒ­ãƒ¼ãƒãƒ«reservationsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚‚æ›´æ–°
                    const reservationDateKey = currentReservation.date || formatDateKey(new Date(currentReservation.start_time || currentReservation.time));
                    if (reservations[reservationDateKey]) {
                        const reservationIndex = reservations[reservationDateKey].findIndex(r => r.id === currentReservation.id);
                        if (reservationIndex !== -1) {
                            reservations[reservationDateKey][reservationIndex].updatedAt = updateTimestamp;
                            reservations[reservationDateKey][reservationIndex].effective_interval_minutes = newInterval;
                            reservations[reservationDateKey][reservationIndex].individual_interval_minutes = newInterval;
                            console.log('ğŸ” Updated local reservation data:', reservations[reservationDateKey][reservationIndex]);
                        }
                    }
                    
                    // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚’å†æç”»
                    generateTimeSlots();
                    
                    showMessage('æº–å‚™æ™‚é–“ãŒæ›´æ–°ã•ã‚Œã¾ã—ãŸã€‚', 'success');
                } else {
                    showMessage(`æº–å‚™æ™‚é–“ã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ: ${data.message}`, 'error');
                }
            })
            .catch(error => {
                console.error('Error updating interval:', error);
                showMessage('æº–å‚™æ™‚é–“ã®æ›´æ–°ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚', 'error');
            });
        }

        // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å¤‰æ›´æ™‚ã«ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚’å³åº§ã«æ›´æ–°
        function updateCalendarOnStatusChange() {
            if (!currentReservation) {
                return;
            }

            const newStatus = document.getElementById('edit-status').value;
            
            // ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°
            currentReservation.status = newStatus;
            
            // ã‚°ãƒ­ãƒ¼ãƒãƒ«reservationsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚‚æ›´æ–°
            const reservationDateKey = formatDateKey(new Date(currentReservation.start_time || currentReservation.time));
            if (reservations[reservationDateKey]) {
                const reservationIndex = reservations[reservationDateKey].findIndex(r => r.id === currentReservation.id);
                if (reservationIndex !== -1) {
                    reservations[reservationDateKey][reservationIndex].status = newStatus;
                }
            }
            
            // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚’å†æç”»
            generateTimeSlots();
        }

        // äºˆç´„æ™‚é–“ãŒå–¶æ¥­æ™‚é–“å†…ã«åã¾ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        // Also update the validateReservationTimeWithinBusinessHours function
        function validateReservationTimeWithinBusinessHours(reservation, newDuration, newInterval) {
            console.log('ğŸ” validateReservationTimeWithinBusinessHours called with:', {
                reservation,
                newDuration,
                newInterval
            });

            // Extract date - improved logic
            let dateToCheck = reservation.date;
            
            // If no date field, try to extract from start_time
            if (!dateToCheck && reservation.start_time) {
                try {
                    const startDateTime = new Date(reservation.start_time);
                    const year = startDateTime.getFullYear();
                    const month = String(startDateTime.getMonth() + 1).padStart(2, '0');
                    const day = String(startDateTime.getDate()).padStart(2, '0');
                    dateToCheck = `${year}-${month}-${day}`;
                } catch (e) {
                    console.error('âŒ Error parsing start_time for date:', e);
                }
            }

            // Extract start time
            let startTime = reservation.time;
            if (!startTime && reservation.start_time) {
                try {
                    const startDateTime = new Date(reservation.start_time);
                    startTime = startDateTime.toTimeString().substring(0, 5);
                } catch (e) {
                    console.error('âŒ Error parsing start_time for time:', e);
                }
            }
            
            console.log('ğŸ” Date calculation debug:', {
                start_time: reservation.start_time,
                date: reservation.date,
                dateKey: dateToCheck,
                reservationDate: reservation.start_time,
                extractedDate: dateToCheck,
                extractedStartTime: startTime
            });

            // Validation - check we have the required data
            if (!dateToCheck || !startTime) {
                console.error('âŒ Missing date or time for validation:', { dateToCheck, startTime });
                return { valid: false, message: 'äºˆç´„ã®æ—¥æ™‚æƒ…å ±ãŒä¸æ­£ã§ã™' };
            }

            // Calculate day of week correctly using the extracted date
            const reservationDate = new Date(dateToCheck + 'T00:00:00'); // Force local timezone interpretation
            const dayOfWeek = reservationDate.getDay(); // 0 = Sunday, 1 = Monday, etc.

            // Convert start time to minutes
            const [hours, minutes] = startTime.split(':').map(Number);
            const startTimeInMinutes = hours * 60 + minutes;
            const totalDuration = newDuration + newInterval;
            const endTimeInMinutes = startTimeInMinutes + totalDuration;
            
            const endHours = Math.floor(endTimeInMinutes / 60);
            const endMins = endTimeInMinutes % 60;
            const endTimeStr = `${String(endHours).padStart(2, '0')}:${String(endMins).padStart(2, '0')}`;
            
            console.log('ğŸ” Validation debug:', {
                startTime,
                startTimeInMinutes,
                totalDuration,
                endTimeInMinutes,
                endTimeStr,
                dayOfWeek,
                dayName: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][dayOfWeek],
                dateToCheck,
                reservationDate: reservationDate.toDateString()
            });

            // Check using your existing custom schedule logic
            const customScheduleDate = '2025-08-10'; // Your reference date for custom schedule
            
            // Check start time is within business hours
            const isStartTimeValid = isBusinessHourForCustomSchedule(dayOfWeek, startTimeInMinutes, customScheduleDate);
            console.log('ğŸ” Business hours check for start time:', {
                dayOfWeek,
                startTime,
                startTimeInMinutes,
                isValid: isStartTimeValid
            });
            
            if (!isStartTimeValid) {
                const message = `äºˆç´„é–‹å§‹æ™‚é–“ãŒå–¶æ¥­æ™‚é–“å¤–ï¼ˆ${startTime}ï¼‰ã®ãŸã‚ã€ã“ã®è¨­å®šã¯ã§ãã¾ã›ã‚“ã€‚`;
                console.log('âŒ Start time validation failed:', startTime, 'dayOfWeek:', dayOfWeek);
                return { valid: false, message };
            }
            
            // Check end time is within business hours - allow ending exactly at closing time
            const isEndTimeValid = isBusinessHourForEndTime(dayOfWeek, endTimeInMinutes, customScheduleDate);
            console.log('ğŸ” Business hours check for end time:', {
                dayOfWeek,
                endTimeStr,
                endTimeInMinutes,
                isValid: isEndTimeValid
            });
            
            if (!isEndTimeValid) {
                const message = `äºˆç´„çµ‚äº†æ™‚é–“ãŒå–¶æ¥­æ™‚é–“å¤–ï¼ˆ${endTimeStr}ï¼‰ã«åŠã¶ãŸã‚ã€ã“ã®è¨­å®šã¯ã§ãã¾ã›ã‚“ã€‚`;
                console.log('âŒ End time validation failed:', endTimeStr, 'dayOfWeek:', dayOfWeek);
                return { valid: false, message };
            }
            
            console.log('âœ… Validation passed');
            return { valid: true };
        }

        // å®šæœŸçš„ãªã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«å¤‰æ›´ãŒæ—¢å­˜äºˆç´„ã«ä¸ãˆã‚‹å½±éŸ¿ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆéåŒæœŸã§å…¨äºˆç´„ã‚’ãƒã‚§ãƒƒã‚¯ï¼‰
        async function checkRecurringScheduleImpact(dayOfWeek, newStartTime, newEndTime) {
            const affectedReservations = [];
            
            console.log('ğŸ” Checking recurring schedule impact:', {
                dayOfWeek,
                newStartTime,
                newEndTime,
                dayName: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][dayOfWeek]
            });
            
            try {
                // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‹ã‚‰è©²å½“æ›œæ—¥ã®å…¨äºˆç´„ã‚’å–å¾—
                const response = await fetch(`/admin/test/by_day_of_week?day_of_week=${dayOfWeek}&from_date=${new Date().toISOString().split('T')[0]}`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]')?.getAttribute('content')
                    }
                });
                
                if (response.ok) {
                    const allReservations = await response.json();
                    console.log(`ğŸ” Retrieved ${allReservations.length} future reservations for ${['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][dayOfWeek]}`);
                    
                    // å–å¾—ã—ãŸäºˆç´„ã‚’ãƒã‚§ãƒƒã‚¯
                    for (const reservation of allReservations) {
                        const reservationTime = reservation.time;
                        const duration = reservation.duration || 60;
                        const interval = reservation.effective_interval_minutes || 10;
                        
                        // äºˆç´„ã®é–‹å§‹æ™‚é–“ã¨çµ‚äº†æ™‚é–“ã‚’è¨ˆç®—
                        const [startHour, startMin] = reservationTime.split(':').map(Number);
                        const startTimeInMinutes = startHour * 60 + startMin;
                        const endTimeInMinutes = startTimeInMinutes + duration + interval;
                        
                        // æ–°ã—ã„å–¶æ¥­æ™‚é–“ã¨æ¯”è¼ƒ
                        const [newStartHour, newStartMin] = newStartTime.split(':').map(Number);
                        const [newEndHour, newEndMin] = newEndTime.split(':').map(Number);
                        const newStartInMinutes = newStartHour * 60 + newStartMin;
                        const newEndInMinutes = newEndHour * 60 + newEndMin;
                        
                        // äºˆç´„ãŒæ–°ã—ã„å–¶æ¥­æ™‚é–“å¤–ã«ãªã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                        if (startTimeInMinutes < newStartInMinutes || endTimeInMinutes > newEndInMinutes) {
                            affectedReservations.push({
                                ...reservation,
                                endTime: `${Math.floor(endTimeInMinutes / 60).toString().padStart(2, '0')}:${(endTimeInMinutes % 60).toString().padStart(2, '0')}`
                            });
                            
                            console.log('âš ï¸ Found affected reservation:', {
                                id: reservation.id,
                                customer: reservation.customer,
                                date: reservation.date,
                                time: reservationTime,
                                duration,
                                interval,
                                calculatedEndTime: `${Math.floor(endTimeInMinutes / 60).toString().padStart(2, '0')}:${(endTimeInMinutes % 60).toString().padStart(2, '0')}`,
                                newBusinessHours: `${newStartTime} - ${newEndTime}`,
                                reason: startTimeInMinutes < newStartInMinutes ? 'starts before business hours' : 'ends after business hours'
                            });
                        }
                    }
                } else {
                    console.error('âŒ Failed to fetch reservations for validation');
                    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ç¾åœ¨ã®reservationsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã¿ãƒã‚§ãƒƒã‚¯
                    return checkRecurringScheduleImpactLocal(dayOfWeek, newStartTime, newEndTime);
                }
            } catch (error) {
                console.error('âŒ Error fetching reservations for validation:', error);
                // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ç¾åœ¨ã®reservationsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã¿ãƒã‚§ãƒƒã‚¯
                return checkRecurringScheduleImpactLocal(dayOfWeek, newStartTime, newEndTime);
            }
            
            console.log(`ğŸ” Found ${affectedReservations.length} affected reservations for ${['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][dayOfWeek]}`);
            return affectedReservations;
        }

        // ç¾åœ¨ã®é€±ã®ç‰¹å®šã®æ›œæ—¥ã®äºˆç´„ã‚’ãƒã‚§ãƒƒã‚¯
        function checkCurrentWeekReservationsForDay(dayOfWeek) {
            const affectedReservations = [];
            
            console.log('ğŸ” Checking current week reservations for day:', {
                dayOfWeek,
                dayName: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][dayOfWeek],
                allReservationDates: Object.keys(reservations),
                currentWeekStart: currentWeekStart
            });
            
            // ç¾åœ¨ã®é€±ã®è©²å½“æ›œæ—¥ã®æ—¥ä»˜ã‚’è¨ˆç®—
            const weekStart = new Date(currentWeekStart);
            const targetDate = new Date(weekStart);
            targetDate.setDate(weekStart.getDate() + dayOfWeek);
            
            // UTCã§ã¯ãªããƒ­ãƒ¼ã‚«ãƒ«æ—¥ä»˜ã‚’ä½¿ç”¨ã—ã¦ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³ã®å•é¡Œã‚’å›é¿
            const year = targetDate.getFullYear();
            const month = String(targetDate.getMonth() + 1).padStart(2, '0');
            const day = String(targetDate.getDate()).padStart(2, '0');
            const dateKey = `${year}-${month}-${day}`;
            
            console.log('ğŸ” Checking for reservations on date:', dateKey);
            console.log('ğŸ” Date calculation details:', {
                weekStartStr: currentWeekStart,
                weekStartDateLocal: `${weekStart.getFullYear()}-${String(weekStart.getMonth() + 1).padStart(2, '0')}-${String(weekStart.getDate()).padStart(2, '0')}`,
                dayOfWeek,
                targetDateStr: dateKey,
                targetDateObj: targetDate,
                availableReservationDates: Object.keys(reservations)
            });
            
            // è©²å½“æ—¥ã®äºˆç´„ã‚’ãƒã‚§ãƒƒã‚¯
            if (reservations[dateKey]) {
                const dayReservations = reservations[dateKey];
                console.log(`ğŸ” Found ${dayReservations.length} reservations on ${dateKey}`);
                
                for (const reservation of dayReservations) {
                    affectedReservations.push({
                        id: reservation.id,
                        customer: reservation.customer || reservation.name || 'æœªè¨­å®š',
                        date: dateKey,
                        time: reservation.time || reservation.start_time?.split('T')[1]?.substring(0, 5) || 'æ™‚é–“ä¸æ˜'
                    });
                }
            }
            
            console.log('ğŸ” Total affected reservations for day toggle:', affectedReservations.length);
            return affectedReservations;
        }

        // ãƒ­ãƒ¼ã‚«ãƒ«reservationsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã¿ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹é–¢æ•°ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
        function checkRecurringScheduleImpactLocal(dayOfWeek, newStartTime, newEndTime) {
            const affectedReservations = [];
            
            // ç¾åœ¨è¡¨ç¤ºä¸­ã®äºˆç´„ã®ã¿ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆå…ƒã®ãƒ­ã‚¸ãƒƒã‚¯ï¼‰
            for (const [dateKey, dayReservations] of Object.entries(reservations)) {
                const date = new Date(dateKey + 'T00:00:00');
                const reservationDayOfWeek = date.getDay();
                
                if (reservationDayOfWeek === dayOfWeek) {
                    for (const reservation of dayReservations) {
                        const reservationTime = reservation.time;
                        const duration = reservation.duration || 60;
                        const interval = reservation.effective_interval_minutes || 10;
                        
                        const [startHour, startMin] = reservationTime.split(':').map(Number);
                        const startTimeInMinutes = startHour * 60 + startMin;
                        const endTimeInMinutes = startTimeInMinutes + duration + interval;
                        
                        const [newStartHour, newStartMin] = newStartTime.split(':').map(Number);
                        const [newEndHour, newEndMin] = newEndTime.split(':').map(Number);
                        const newStartInMinutes = newStartHour * 60 + newStartMin;
                        const newEndInMinutes = newEndHour * 60 + newEndMin;
                        
                        if (startTimeInMinutes < newStartInMinutes || endTimeInMinutes > newEndInMinutes) {
                            affectedReservations.push({
                                ...reservation,
                                date: dateKey,
                                endTime: `${Math.floor(endTimeInMinutes / 60).toString().padStart(2, '0')}:${(endTimeInMinutes % 60).toString().padStart(2, '0')}`
                            });
                        }
                    }
                }
            }
            
            return affectedReservations;
        }

        // Helper function that integrates with your existing custom schedule logic
        function isBusinessHourForCustomSchedule(dayOfWeek, timeInMinutes, customScheduleDate) {
            // Convert minutes back to time string for existing isBusinessHour function
            const hour = Math.floor(timeInMinutes / 60);
            const minute = timeInMinutes % 60;
            const timeStr = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
            
            console.log('ğŸ” Checking business hour with existing function:', {
                dayOfWeek,
                timeStr,
                timeInMinutes
            });
            
            // Use your existing isBusinessHour function if available
            if (typeof isBusinessHour === 'function') {
                const result = isBusinessHour(dayOfWeek, timeStr);
                console.log('ğŸ” Existing isBusinessHour result:', result);
                return result;
            }
            
            // Fallback: basic business hours check
            console.log('ğŸ” Using fallback business hours (9:00-18:00)');
            const businessStart = 9 * 60;  // 9:00 in minutes  
            const businessEnd = 18 * 60;   // 18:00 in minutes
            
            // Sunday check
            if (dayOfWeek === 0) {
                return false; // Sunday closed
            }
            
            return timeInMinutes >= businessStart && timeInMinutes < businessEnd;
        }

        // Business hour check for end times - allows ending exactly at closing time
        function isBusinessHourForEndTime(dayOfWeek, timeInMinutes, customScheduleDate) {
            // Convert minutes back to time string for existing isBusinessHour function
            const hour = Math.floor(timeInMinutes / 60);
            const minute = timeInMinutes % 60;
            const timeStr = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
            
            console.log('ğŸ” Checking business hour for END TIME with existing function:', {
                dayOfWeek,
                timeStr,
                timeInMinutes
            });
            
            // Use your existing isBusinessHour function if available
            if (typeof isBusinessHour === 'function') {
                // First check if it's within regular business hours
                const isWithinBusinessHours = isBusinessHour(dayOfWeek, timeStr);
                
                console.log('ğŸ” Existing isBusinessHour result for end time:', isWithinBusinessHours);
                
                // If within business hours, allow it
                if (isWithinBusinessHours) {
                    return true;
                }
                
                // If not within regular business hours, check common closing times
                // This is a simplified approach - check if it's exactly at common closing times
                const commonClosingTimes = [
                    17 * 60,  // 17:00
                    18 * 60,  // 18:00
                    19 * 60,  // 19:00
                    20 * 60,  // 20:00
                    21 * 60,  // 21:00
                    22 * 60   // 22:00
                ];
                
                const isAtClosingTime = commonClosingTimes.includes(timeInMinutes);
                console.log('ğŸ” Checking if end time is at common closing time:', {
                    endTimeInMinutes: timeInMinutes,
                    timeStr,
                    isAtClosingTime
                });
                
                if (isAtClosingTime) {
                    console.log('âœ… End time is at common closing time - allowing');
                    return true;
                }
                
                return false;
            }
            
            // Fallback: basic business hours check with closing time allowance
            console.log('ğŸ” Using fallback business hours for end time (9:00-18:00, allowing 18:00)');
            const businessStart = 9 * 60;  // 9:00 in minutes  
            const businessEnd = 18 * 60;   // 18:00 in minutes
            
            // Sunday check
            if (dayOfWeek === 0) {
                return false; // Sunday closed
            }
            
            // Allow ending exactly at closing time (note: <= instead of <)
            return timeInMinutes >= businessStart && timeInMinutes <= businessEnd;
        }

        // äºˆç´„ã®é‡è¤‡ãƒã‚§ãƒƒã‚¯
        function validateReservationOverlap(reservation, newDuration, newInterval, excludeReservationId = null) {
            if (!reservation) return { valid: false, message: 'äºˆç´„ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚' };
            
            // äºˆç´„ã®é–‹å§‹æ™‚é–“ã‚’å–å¾—
            let startTime;
            let dateKey;
            
            // å„ªå…ˆé †ä½: start_time > dateKey > date > time
            if (reservation.start_time) {
                const dateTime = new Date(reservation.start_time);
                startTime = `${dateTime.getHours().toString().padStart(2, '0')}:${dateTime.getMinutes().toString().padStart(2, '0')}`;
                dateKey = formatDateKey(dateTime);
            } else if (reservation.dateKey) {
                startTime = reservation.time;
                dateKey = reservation.dateKey;
            } else if (reservation.date && reservation.time) {
                startTime = reservation.time;
                dateKey = reservation.date;
            } else if (reservation.time) {
                startTime = reservation.time;
                // ç¾åœ¨ã®é€±ã®é–‹å§‹æ—¥ã‚’ä½¿ç”¨
                const reservationDate = new Date(currentWeekStart);
                dateKey = formatDateKey(reservationDate);
            } else {
                return { valid: false, message: 'äºˆç´„ã®é–‹å§‹æ™‚é–“ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚' };
            }
            
            const [startHour, startMin] = startTime.split(':').map(Number);
            const startTimeInMinutes = startHour * 60 + startMin;
            const totalDuration = newDuration + newInterval;
            const endTimeInMinutes = startTimeInMinutes + totalDuration;
            
            // æŒ‡å®šæ—¥ã®äºˆç´„ã‚’å–å¾—ï¼ˆè‡ªåˆ†ä»¥å¤–ï¼‰
            const dayReservations = reservations[dateKey] || [];
            
            console.log('ğŸ” Overlap validation debug:', {
                dateKey,
                startTime,
                startTimeInMinutes,
                totalDuration,
                endTimeInMinutes,
                reservationId: reservation.id,
                dayReservations: dayReservations.length,
                reservationData: {
                    start_time: reservation.start_time,
                    dateKey: reservation.dateKey,
                    date: reservation.date,
                    time: reservation.time
                }
            });
            
            // é‡è¤‡ãƒã‚§ãƒƒã‚¯ï¼ˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«æ™‚é–“ã‚‚å«ã‚€ï¼‰
            for (const existingReservation of dayReservations) {
                if (existingReservation.id === reservation.id || existingReservation.id === excludeReservationId) {
                    console.log('â­ï¸ Skipping self or excluded reservation:', existingReservation.id);
                    continue; // è‡ªåˆ†ã¾ãŸã¯é™¤å¤–å¯¾è±¡ã¯é™¤å¤–
                }
                
                const existingStart = new Date(`${dateKey}T${existingReservation.time}`);
                const existingEnd = new Date(existingStart.getTime() + existingReservation.duration * 60 * 1000);
                
                // æ—¢å­˜äºˆç´„ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«æ™‚é–“ã‚’å–å¾—
                const existingIntervalMinutes = existingReservation.effective_interval_minutes ?? 10;
                const existingEndWithInterval = new Date(existingEnd.getTime() + existingIntervalMinutes * 60 * 1000);
                
                // æ–°ã—ã„äºˆç´„ã®çµ‚äº†æ™‚é–“
                const newEnd = new Date(`${dateKey}T${startTime}`);
                newEnd.setMinutes(newEnd.getMinutes() + totalDuration);
                
                console.log('ğŸ” Comparing with existing reservation:', {
                    existingId: existingReservation.id,
                    existingTime: `${existingReservation.time} - ${new Date(existingEndWithInterval).toTimeString().slice(0, 5)}`,
                    newTime: `${startTime} - ${newEnd.toTimeString().slice(0, 5)}`,
                    existingInterval: existingIntervalMinutes,
                    newInterval: newInterval
                });
                
                // é‡è¤‡åˆ¤å®šï¼ˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«æ™‚é–“ã‚‚å«ã‚€ï¼‰
                if (startTimeInMinutes < (existingEndWithInterval.getHours() * 60 + existingEndWithInterval.getMinutes()) && 
                    endTimeInMinutes > (existingStart.getHours() * 60 + existingStart.getMinutes())) {
                    console.log('ğŸš« Overlap detected with reservation:', existingReservation.id);
                    return { 
                        valid: false, 
                        message: `äºˆç´„æ™‚é–“ãŒæ—¢å­˜ã®äºˆç´„ï¼ˆ${existingReservation.customer}æ§˜ï¼‰ã¨é‡è¤‡ã™ã‚‹ãŸã‚ã€ã“ã®è¨­å®šã¯ã§ãã¾ã›ã‚“ã€‚` 
                    };
                }
            }
            
            console.log('âœ… No overlaps detected');
            return { valid: true, message: '' };
        }

        // ã‚³ãƒ¼ã‚¹å¤‰æ›´æ™‚ã«ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚’å³åº§ã«æ›´æ–°
        function updateCalendarOnCourseChange() {
            if (!currentReservation) return;
            
            const courseSelect = document.getElementById('edit-course');
            if (!courseSelect) return;
            
            const newCourse = courseSelect.value;
            const newDuration = parseInt(newCourse);
            const currentInterval = currentReservation.effective_interval_minutes ?? 10;
            
            console.log('ğŸ”„ Course changed to:', newCourse, 'Duration:', newDuration);
            
            // å–¶æ¥­æ™‚é–“å†…ã«åã¾ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            console.log('ğŸ” Validating course change for reservation:', currentReservation);
            
            // Extract proper date and time from reservation for validation (same logic as interval change)
            let startTime = currentReservation.time || currentReservation.startTime;
            let reservationDate = currentReservation.date || currentReservation.reservationDate;
            
            // Final fallback: search through reservations object to find the date key
            if (!reservationDate && currentReservation.id) {
                console.log('ğŸ” Course change fallback: searching reservations object for reservation ID:', currentReservation.id);
                for (const dateKey of Object.keys(reservations)) {
                    const dayReservations = reservations[dateKey];
                    if (dayReservations && dayReservations.find(r => r.id === currentReservation.id)) {
                        reservationDate = dateKey;
                        console.log('ğŸŸ© Found reservation date in course change fallback:', dateKey);
                        break;
                    }
                }
            }
            
            // Create properly structured reservation object for validation
            const validationReservation = {
                date: reservationDate,
                time: startTime,
                start_time: currentReservation.start_time
            };
            
            console.log('ğŸ” Course change validation reservation:', validationReservation);
            
            const businessHoursValidation = validateReservationTimeWithinBusinessHours(validationReservation, newDuration, currentInterval);
            console.log('ğŸ” Course change business hours validation result:', businessHoursValidation);
            if (!businessHoursValidation.valid) {
                showMessage(businessHoursValidation.message, 'error');
                // å…ƒã®å€¤ã«æˆ»ã™
                courseSelect.value = currentReservation.course || currentReservation.duration.toString();
                return;
            }
            
            // é‡è¤‡ãƒã‚§ãƒƒã‚¯ - use the same properly structured reservation object and exclude current reservation
            const overlapValidation = validateReservationOverlap(validationReservation, newDuration, currentInterval, currentReservation.id);
            console.log('ğŸ” Course change overlap validation result:', overlapValidation);
            if (!overlapValidation.valid) {
                showMessage(overlapValidation.message, 'error');
                // å…ƒã®å€¤ã«æˆ»ã™
                courseSelect.value = currentReservation.course || currentReservation.duration.toString();
                return;
            }
            
            // ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’å³åº§ã«æ›´æ–°ï¼ˆè­¦å‘ŠãŒã‚ã£ã¦ã‚‚æ›´æ–°ã™ã‚‹ï¼‰
            currentReservation.duration = newDuration;
            currentReservation.course = newCourse;
            
            // ã‚°ãƒ­ãƒ¼ãƒãƒ«reservationsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚‚æ›´æ–° - use the correct date
            const reservationDateKey = reservationDate; // Use the date we already found
            if (reservations[reservationDateKey]) {
                const reservationIndex = reservations[reservationDateKey].findIndex(r => r.id === currentReservation.id);
                if (reservationIndex !== -1) {
                    reservations[reservationDateKey][reservationIndex].duration = newDuration;
                    reservations[reservationDateKey][reservationIndex].course = newCourse;
                }
            }
            
            // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚’å³åº§ã«å†æç”»
            generateTimeSlots();
            
            console.log('âœ… Calendar updated immediately for course change');
        }



        // ãƒ¦ãƒ¼ã‚¶ãƒ¼é¸æŠãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
        function openUserSelectionModal() {
            console.log('ğŸ” openUserSelectionModal called');
            
            // æ¤œç´¢å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ã‚¯ãƒªã‚¢
            const searchInput = document.getElementById('userSearchInput');
            if (searchInput) {
                searchInput.value = '';
                console.log('ğŸ” Search input found and cleared');
            } else {
                console.error('âŒ Search input not found');
            }
            
            // æ¤œç´¢çµæœã‚’ã‚¯ãƒªã‚¢
            const searchResults = document.getElementById('userSelectionSearchResults');
            if (searchResults) {
                searchResults.innerHTML = '';
                searchResults.style.display = 'none';
                console.log('ğŸ” Search results cleared and hidden');
            } else {
                console.error('âŒ Search results container not found');
            }
            
            // ä¿å­˜ãƒœã‚¿ãƒ³ã‚’ç„¡åŠ¹åŒ–
            const saveBtn = document.getElementById('saveUserBtn');
            if (saveBtn) {
                saveBtn.disabled = true;
            }
            
            // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¨­å®š
            if (searchInput) {
                // æ—¢å­˜ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤
                searchInput.removeEventListener('input', handleUserSearch);
                
                // å…¥åŠ›ã‚¤ãƒ™ãƒ³ãƒˆ
                searchInput.addEventListener('input', handleUserSearch);
                console.log('ğŸ” Input event listener added');
                
                // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã‚¢ã‚¦ãƒˆæ™‚ã«çµæœã‚’éš ã™
                searchInput.addEventListener('blur', function() {
                    setTimeout(() => {
                        hideUserSearchResults();
                    }, 200);
                });
                
                // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹æ™‚ã«çµæœã‚’è¡¨ç¤ºï¼ˆå…¥åŠ›ãŒã‚ã‚‹å ´åˆï¼‰
                searchInput.addEventListener('focus', function() {
                    const query = this.value.trim();
                    if (query.length >= 2) {
                        searchUsersForModal(query);
                    }
                });
                
                searchInput.focus();
            }
            
            document.getElementById('userSelectionModal').style.display = 'block';
            console.log('ğŸ” Modal displayed');
            
            // Debug modal dimensions
            const modal = document.getElementById('userSelectionModal');
            const modalContent = modal.querySelector('.modal-content');
            console.log('ğŸ” Modal dimensions:', modal.offsetWidth, 'x', modal.offsetHeight);
            console.log('ğŸ” Modal content dimensions:', modalContent.offsetWidth, 'x', modalContent.offsetHeight);
        }

        // ãƒ¦ãƒ¼ã‚¶ãƒ¼æ¤œç´¢ã‚’å‡¦ç†
        function handleUserSearch(event) {
            const query = event.target.value.trim();
            console.log('ğŸ” handleUserSearch called with query:', query);
            
            // ãƒ‡ãƒã‚¦ãƒ³ã‚¹å‡¦ç†
            if (searchTimeout) {
                clearTimeout(searchTimeout);
            }
            
            if (query.length < 2) {
                console.log('ğŸ” Query too short, hiding results');
                hideUserSearchResults();
                return;
            }
            
            console.log('ğŸ” Setting timeout for search');
            searchTimeout = setTimeout(() => {
                console.log('ğŸ” Calling searchUsersForModal with:', query);
                searchUsersForModal(query);
            }, 300);
        }

        // ãƒ¢ãƒ¼ãƒ€ãƒ«ç”¨ãƒ¦ãƒ¼ã‚¶ãƒ¼æ¤œç´¢
        function searchUsersForModal(query) {
            console.log('ğŸ” searchUsersForModal called with query:', query);
            fetch(`/admin/reservations/search_users?query=${encodeURIComponent(query)}`)
                .then(response => {
                    console.log('ğŸ” Search response status:', response.status);
                    return response.json();
                })
                .then(data => {
                    console.log('ğŸ” Search response data:', data);
                    if (data.success) {
                        displayUserSearchResultsForModal(data.users);
                    } else {
                        console.error('âŒ User search failed:', data.message);
                        hideUserSearchResults();
                    }
                })
                .catch(error => {
                    console.error('âŒ Error searching users:', error);
                    hideUserSearchResults();
                });
        }

        // ãƒ¢ãƒ¼ãƒ€ãƒ«ç”¨æ¤œç´¢çµæœè¡¨ç¤º
        function displayUserSearchResultsForModal(users) {
            console.log('ğŸ” displayUserSearchResultsForModal called with users:', users);
            const searchResults = document.getElementById('userSelectionSearchResults');
            if (!searchResults) {
                console.error('âŒ Search results container not found');
                return;
            }
            
            if (users.length === 0) {
                searchResults.innerHTML = '<div class="user-search-item">è©²å½“ã™ã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“</div>';
                searchResults.style.display = 'block';
                console.log('ğŸ” No users found, showing message');
                return;
            }
            
            const resultsHtml = users.map(user => `
                <div class="user-search-item" onclick="selectUserForModal(${user.id}, '${user.name}', '${user.phone_number}', '${user.email}')">
                    <div class="user-name">${user.name}</div>
                    <div class="user-details">
                        ğŸ“ ${user.phone_number || 'æœªè¨­å®š'} | ğŸ“§ ${user.email || 'æœªè¨­å®š'}
                        ${user.active_tickets > 0 ? `<span class="user-tickets"> | ğŸ« æ®‹${user.active_tickets}æš</span>` : ''}
                        ${user.last_visit !== 'ãªã—' ? ` | ğŸ“… æœ€çµ‚æ¥åº—: ${user.last_visit}` : ''}
                    </div>
                </div>
            `).join('');
            
            searchResults.innerHTML = resultsHtml;
            searchResults.style.display = 'block';
            
            // Let the container size naturally based on content
            searchResults.style.height = 'auto';
            
            // Force a reflow to ensure the browser recalculates dimensions
            searchResults.offsetHeight;
            
            console.log('ğŸ” Search results displayed:', users.length, 'users');
            

        }

        // ãƒ¢ãƒ¼ãƒ€ãƒ«ç”¨ãƒ¦ãƒ¼ã‚¶ãƒ¼é¸æŠ
        function selectUserForModal(userId, name, phone, email) {
            console.log('ğŸ” selectUserForModal called with:', { userId, name, phone, email });
            console.log('ğŸ” Current reservation user ID:', currentReservation?.userId);
            
            // é¸æŠã•ã‚ŒãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ä¿å­˜
            window.selectedUser = {
                id: userId,
                name: name,
                phone_number: phone,
                email: email
            };
            
            // æ¤œç´¢çµæœã‚’ã‚¯ãƒªã‚¢ã—ã¦é¸æŠã•ã‚ŒãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’è¡¨ç¤º
            const searchResults = document.getElementById('userSelectionSearchResults');
            if (searchResults) {
                searchResults.innerHTML = `
                    <div class="selected-user">
                        <div class="user-info">
                            <div class="user-name">âœ… ${name}</div>
                            <div class="user-details">
                                ğŸ“ ${phone || 'æœªè¨­å®š'} | ğŸ“§ ${email || 'æœªè¨­å®š'}
                            </div>
                        </div>
                    </div>
                `;
            }
            
            // ä¿å­˜ãƒœã‚¿ãƒ³ã‚’æœ‰åŠ¹åŒ–
            const saveBtn = document.getElementById('saveUserBtn');
            if (saveBtn) {
                saveBtn.disabled = false;
            }
            

            
            // æˆåŠŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
            showMessage(`æ—¢å­˜ãƒ¦ãƒ¼ã‚¶ãƒ¼ã€Œ${name}ã€ã‚’é¸æŠã—ã¾ã—ãŸ`, 'success');
        }

        // ãƒ¦ãƒ¼ã‚¶ãƒ¼é¸æŠãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
        function closeUserSelectionModal() {
            document.getElementById('userSelectionModal').style.display = 'none';
        }

        // ãƒ¦ãƒ¼ã‚¶ãƒ¼é¸æŠã‚’ä¿å­˜
        function saveUserSelection() {
            if (!window.selectedUser) {
                showMessage('ãŠå®¢æ§˜ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚', 'error');
                return;
            }
            
            const newUserId = window.selectedUser.id;
            const newUserName = window.selectedUser.name;
            const newUserPhone = window.selectedUser.phone_number || '';
            const newUserEmail = window.selectedUser.email || '';
            
            console.log('ğŸ” saveUserSelection - Selected user:', { newUserId, newUserName, newUserPhone, newUserEmail });
            console.log('ğŸ” saveUserSelection - Current reservation user ID:', currentReservation?.userId);
            
            // é¡§å®¢æƒ…å ±ã‚’æ›´æ–°
            const customerNameElement = document.querySelector('.customer-name-large');
            if (customerNameElement) {
                customerNameElement.textContent = newUserName;
            }
            
            const phoneElement = document.querySelector('.customer-phone');
            if (phoneElement) {
                phoneElement.textContent = newUserPhone || 'é›»è©±ç•ªå·æœªè¨˜å…¥';
            }
            
            const emailElement = document.querySelector('.customer-email');
            if (emailElement) {
                emailElement.textContent = newUserEmail || 'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹æœªè¨˜å…¥';
            }
            
            // ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚‚æ›´æ–°
            if (currentReservation) {
                currentReservation.customer = newUserName;
                currentReservation.phone = newUserPhone;
                currentReservation.email = newUserEmail;
                currentReservation.userId = newUserId;
            }
            
            // ã‚°ãƒ­ãƒ¼ãƒãƒ«reservationsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚‚æ›´æ–°
            const reservationDateKey = formatDateKey(new Date(currentReservation.start_time || currentReservation.time));
            if (reservations[reservationDateKey]) {
                const reservationIndex = reservations[reservationDateKey].findIndex(r => r.id === currentReservation.id);
                if (reservationIndex !== -1) {
                    reservations[reservationDateKey][reservationIndex].customer = newUserName;
                    reservations[reservationDateKey][reservationIndex].phone = newUserPhone;
                    reservations[reservationDateKey][reservationIndex].email = newUserEmail;
                    reservations[reservationDateKey][reservationIndex].userId = newUserId;
                }
            }
            
            // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã«ãƒ¦ãƒ¼ã‚¶ãƒ¼å¤‰æ›´ã‚’ä¿å­˜
            const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');
            
            fetch(`/admin/reservations/${currentReservation.id}/update_booking`, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-Token': csrfToken
                },
                body: JSON.stringify({
                    reservation: {
                        user_id: newUserId
                    }
                })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    // ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‹ã‚‰æ›´æ–°ã•ã‚ŒãŸãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’å–å¾—
                    const updatedUser = data.reservation.user;
                    
                    // ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°
                    if (currentReservation) {
                        currentReservation.customer = updatedUser.name;
                        currentReservation.phone = updatedUser.phone_number;
                        currentReservation.email = updatedUser.email;
                        currentReservation.userId = updatedUser.id;
                    }
                    
                    // ã‚°ãƒ­ãƒ¼ãƒãƒ«reservationsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚‚æ›´æ–°
                    const reservationDateKey = formatDateKey(new Date(currentReservation.start_time || currentReservation.time));
                    if (reservations[reservationDateKey]) {
                        const reservationIndex = reservations[reservationDateKey].findIndex(r => r.id === currentReservation.id);
                        if (reservationIndex !== -1) {
                            reservations[reservationDateKey][reservationIndex].customer = updatedUser.name;
                            reservations[reservationDateKey][reservationIndex].phone = updatedUser.phone_number;
                            reservations[reservationDateKey][reservationIndex].email = updatedUser.email;
                            reservations[reservationDateKey][reservationIndex].userId = updatedUser.id;
                        }
                    }
                    
                    // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‚‚æ›´æ–°
                    window.currentUserId = updatedUser.id;
                    
                    // å³åº§ã«ãƒ¢ãƒ¼ãƒ€ãƒ«ã®é¡§å®¢åã‚’æ›´æ–°
                    const customerNameElement = document.querySelector('.customer-name-large');
                    if (customerNameElement) {
                        customerNameElement.textContent = updatedUser.name;
                        console.log('âœ… Customer name updated immediately to:', updatedUser.name);
                    }
                    
                    // å…ƒã®ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã‚’ä¿å­˜ã—ã¦ã‹ã‚‰æ›´æ–°
                    currentReservation.originalUserId = currentReservation.userId;
                    
                    // currentReservationã‚‚å³åº§ã«æ›´æ–°
                    currentReservation.customer = updatedUser.name;
                    currentReservation.userId = updatedUser.id;
                    currentReservation.phone = updatedUser.phone_number;
                    currentReservation.email = updatedUser.email;
                    
                    // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚’å³åº§ã«å†æç”»ã—ã¦å¤‰æ›´ã‚’åæ˜ 
                    generateTimeSlots();
                    
                    // ãƒã‚±ãƒƒãƒˆã¨å±¥æ­´ã‚’æ–°ã—ã„ãƒ¦ãƒ¼ã‚¶ãƒ¼ã§æ›´æ–°
                    loadTicketsAndHistoryForUser(updatedUser.id);
                    
                    // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
                    closeUserSelectionModal();
                    
                    showMessage('ãŠå®¢æ§˜ãŒå¤‰æ›´ã•ã‚Œã¾ã—ãŸã€‚', 'success');
                    
                    console.log('ğŸ”„ Customer changed to:', updatedUser.name);
                    
                    // ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦ç¢ºå®Ÿã«ãƒ‡ãƒ¼ã‚¿ã‚’åŒæœŸ
                    setTimeout(() => {
                        window.location.reload();
                    }, 500);
                } else {
                    showMessage(`ãŠå®¢æ§˜ã®å¤‰æ›´ã«å¤±æ•—ã—ã¾ã—ãŸ: ${data.message}`, 'error');
                }
            })
            .catch(error => {
                console.error('âŒ Error updating user:', error);
                showMessage('ãŠå®¢æ§˜ã®å¤‰æ›´ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚', 'error');
            });
        }



        // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‹ã‚‰ã‚·ãƒ•ãƒˆè¨­å®šã‚’èª­ã¿è¾¼ã¿
        function loadShiftSettingsFromBackend() {
            const weekStartStr = formatDateKey(currentWeekStart);
            
            return fetch(`/admin/reservations/load_shift_settings?week_start_date=${weekStartStr}`)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        defaultSchedule = data.default_schedule;
                        weeklySchedules[weekStartStr] = data.current_week_schedule;
                        

                        
                        // é€±å›ºæœ‰ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒãªã„å ´åˆã®ãƒ­ã‚°
                        if (!data.has_custom_schedule) {
    
                        }
  } else {
                        console.error('âŒ Failed to load shift settings:', data.message);
                        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’åˆæœŸåŒ–
                        initializeDefaultSchedule();
                    }
                })
                .catch(error => {
                    console.error('âŒ Error loading shift settings:', error);
                    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’åˆæœŸåŒ–
                    initializeDefaultSchedule();
                });
        }

        // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‹ã‚‰äºˆç´„ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿
        function loadReservationsFromBackend() {
            const weekStartStr = formatDateKey(currentWeekStart);

            
            return fetch(`/admin/reservations/load_reservations?week_start_date=${weekStartStr}`)
                .then(response => response.json())
                .then(data => {

                    if (data.success) {
                        // æ–°ã—ã„é€±ã®äºˆç´„ãƒ‡ãƒ¼ã‚¿ã§æ—¢å­˜ã®ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°ï¼ˆæ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒï¼‰
                        console.log('ğŸ”„ Loading reservations from backend');
                        console.log('ğŸ“… Existing reservations:', reservations);
                        console.log('ğŸ“… Backend reservations:', data.reservations);
                        
                        // æ—¢å­˜ã®ãƒ‡ãƒ¼ã‚¿ã¨æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ã‚’ãƒãƒ¼ã‚¸ï¼ˆæ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒï¼‰
                        for (const [dateKey, newReservations] of Object.entries(data.reservations)) {
                            reservations[dateKey] = newReservations;
                        }
                        
                        console.log('ğŸ“… Final merged reservations:', reservations);
                        console.log('ğŸ“… Checking specific reservation 97:', reservations['2025-08-13']?.find(r => r.id === 97));
                        
                        // Debug: Check if AJAX reservations have timestamp fields and interval data
                        if (data.reservations && Object.keys(data.reservations).length > 0) {
                            const firstDateKey = Object.keys(data.reservations)[0];
                            const firstReservation = data.reservations[firstDateKey][0];
                            console.log('ğŸ” First AJAX reservation structure:', firstReservation);
                            console.log('ğŸ” AJAX interval data:', {
                                effective_interval_minutes: firstReservation.effective_interval_minutes,
                                individual_interval_minutes: firstReservation.individual_interval_minutes,
                                id: firstReservation.id
                            });
                        }
                        
                        // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚’å³åº§ã«å†æç”»ã—ã¦å¤‰æ›´ã‚’åæ˜ 
                        console.log('ğŸ”„ Calling generateTimeSlots after data load');
                        generateTimeSlots();
    } else {
                        console.error('âŒ Failed to load reservations:', data.message);
                    }
                })
                .catch(error => {
                    console.error('âŒ Error loading reservations:', error);
                });
        }

        // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’åˆæœŸåŒ–
        function initializeDefaultSchedule() {
            defaultSchedule = {
                0: { enabled: false, times: [] }, // æ—¥æ›œæ—¥ã¯ä¼‘æ¥­
                1: { enabled: true, times: [{ start: '09:00', end: '20:00' }] }, // æœˆæ›œæ—¥
                2: { enabled: true, times: [{ start: '10:00', end: '20:00' }] }, // ç«æ›œæ—¥
                3: { enabled: true, times: [{ start: '10:00', end: '20:00' }] }, // æ°´æ›œæ—¥
                4: { enabled: true, times: [{ start: '10:00', end: '20:00' }] }, // æœ¨æ›œæ—¥
                5: { enabled: true, times: [{ start: '10:00', end: '20:00' }] }, // é‡‘æ›œæ—¥
                6: { enabled: true, times: [{ start: '09:00', end: '18:00' }] }, // åœŸæ›œæ—¥
            };
        }

        // é€±è¡¨ç¤ºã‚’æç”»
        function renderWeekView() {
            updateWeekHeader();
            generateTimeSlots();
        }

        // é€±ã®ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’æ›´æ–°
        function updateWeekHeader() {
            const endDate = new Date(currentWeekStart);
            endDate.setDate(endDate.getDate() + 6);
            
            const startStr = formatDateShort(currentWeekStart);
            const endStr = formatDateShort(endDate);
            
            document.getElementById('currentWeek').textContent = 
                `${currentWeekStart.getFullYear()}å¹´ ${startStr} - ${endStr}`;
            
            // æ—¥ä»˜ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’æ›´æ–°
            const headers = document.querySelectorAll('.day-header');
            for (let i = 0; i < headers.length; i++) {
                const date = new Date(currentWeekStart);
                date.setDate(date.getDate() + i);
                
                const dayName = dayNames[date.getDay()];
                const dateStr = `${date.getMonth() + 1}/${date.getDate()}`;
                
                // CSSã‚¯ãƒ©ã‚¹ã‚’ãƒªã‚»ãƒƒãƒˆ
                headers[i].classList.remove('sunday', 'saturday');
                
                // æ­£ã—ã„CSSã‚¯ãƒ©ã‚¹ã‚’è¿½åŠ 
                if (date.getDay() === 0) {
                    headers[i].classList.add('sunday');
                } else if (date.getDay() === 6) {
                    headers[i].classList.add('saturday');
                }
                
                headers[i].innerHTML = `${dayName}<br><span style="font-size: 12px;">${dateStr}</span>`;
            }
        }

        // ã‚¿ã‚¤ãƒ ã‚¹ãƒ­ãƒƒãƒˆã‚’ç”Ÿæˆ
        function generateTimeSlots() {
            console.log('ğŸ” generateTimeSlots called - defaultSchedule:', defaultSchedule);
            console.log('ğŸ” generateTimeSlots - current reservations data:', reservations);
            console.log('ğŸ” generateTimeSlots - reservation 97 data:', reservations['2025-08-13']?.find(r => r.id === 97));
            const scheduleBody = document.getElementById('scheduleBody');
            scheduleBody.innerHTML = '';
            
            // 8:00ã‹ã‚‰21:00ã¾ã§10åˆ†åˆ»ã¿ã§ç”Ÿæˆ
            for (let hour = 8; hour <= 21; hour++) {
                for (let minute = 0; minute < 60; minute += 10) {
                    if (hour === 21 && minute > 0) break; // 21:00ã§çµ‚äº†
                    
                    const timeStr = `${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}`;
                    
                    // è¡Œã‚³ãƒ³ãƒ†ãƒŠã‚’ä½œæˆ
                    const row = document.createElement('div');
                    row.className = 'schedule-row';
                    
                    // è¡Œå…¨ä½“ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è¿½åŠ 
                    if (minute === 0) {
                        row.classList.add('hour-row');
                    } else if (minute === 30) {
                        row.classList.add('half-hour-row');
                    }
                    
                    // æ™‚åˆ»ãƒ©ãƒ™ãƒ«
                    const timeSlot = document.createElement('div');
                    timeSlot.className = 'time-slot';
                    
                    // æ™‚é–“ãƒãƒ¼ã‚«ãƒ¼ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è¿½åŠ ï¼ˆ10åˆ†åˆ»ã¿ã«å¯¾å¿œï¼‰
                    if (minute === 0) {
                        timeSlot.classList.add('hour-marker');
                    } else if (minute === 30) {
                        timeSlot.classList.add('half-hour-marker');
                    }
                    
                    timeSlot.textContent = timeStr;
                    row.appendChild(timeSlot);
                    
                    // å„æ›œæ—¥ã®ã‚»ãƒ«
                    for (let day = 0; day < 7; day++) {
                        const cell = document.createElement('div');
                        cell.className = 'schedule-cell';
                        cell.dataset.day = day;
                        cell.dataset.time = timeStr;
                        
                        // ãƒ‰ãƒ­ãƒƒãƒ—ã‚¾ãƒ¼ãƒ³ã¨ã—ã¦è¨­å®š
                        cell.addEventListener('dragover', handleDragOver);
                        cell.addEventListener('drop', handleDrop);
                        cell.addEventListener('dragenter', handleDragEnter);
                        cell.addEventListener('dragleave', handleDragLeave);
                        
                        const currentDate = new Date(currentWeekStart);
                        currentDate.setDate(currentDate.getDate() + day);
                        const dateKey = formatDateKey(currentDate);
                        
                                                // å–¶æ¥­æ™‚é–“ãƒã‚§ãƒƒã‚¯
                        if (isBusinessHour(day, timeStr)) {
                            // äºˆç´„ãƒã‚§ãƒƒã‚¯
                            const reservation = findReservation(dateKey, timeStr);
                            
                            // ãƒ‡ãƒãƒƒã‚°ç”¨ãƒ­ã‚°ï¼ˆç‰¹å®šã®æ™‚é–“ã®ã¿ï¼‰
                            if (timeStr === '10:00' && day === 1) {
                                console.log(`ğŸ” Checking for reservation at ${dateKey} ${timeStr}:`, {
                                    dayReservations: reservations[dateKey] || [],
                                    foundReservation: reservation,
                                    isReservationStart: reservation ? isReservationStart(dateKey, timeStr) : false
                                });
                            }
                            
                            if (reservation) {
                                // äºˆç´„ã®é–‹å§‹ã‚¹ãƒ­ãƒƒãƒˆã®å ´åˆã®ã¿ãƒ–ãƒ­ãƒƒã‚¯ã‚’è¡¨ç¤º
                                if (isReservationStart(dateKey, timeStr)) {
                                    console.log('ğŸ¯ Creating reservation block for:', {
                                        id: reservation.id,
                                        customer: reservation.customer,
                                        userId: reservation.userId,
                                        date: dateKey,
                                        time: timeStr,
                                        effective_interval_minutes: reservation.effective_interval_minutes,
                                        individual_interval_minutes: reservation.individual_interval_minutes,
                                        duration: reservation.duration
                                    });
                                    const block = createSpanningReservationBlock(reservation, dateKey, timeStr);
                                    cell.appendChild(block);
                                    // äºˆç´„è©³ç´°ã‚’è¡¨ç¤ºã™ã‚‹ãŸã‚ã®ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
                                    cell.addEventListener('click', (e) => {
                                        // ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã§ãªã„å ´åˆã®ã¿ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã‚’å®Ÿè¡Œ
                                        if (!isDragging) {
                                        openReservationDetailModal(reservation);
                                        }
                                    });
                                    
                                    // ãƒ‰ãƒ©ãƒƒã‚°ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¿½åŠ ï¼ˆãƒ¡ã‚¤ãƒ³ãƒ–ãƒ­ãƒƒã‚¯ã«è¿½åŠ ï¼‰
                                    console.log('ğŸ¯ Setting up drag events for reservation:', reservation.id);
                                    block.addEventListener('dragstart', handleDragStart);
                                    block.addEventListener('dragend', handleDragEnd);
                                    
                                    // Also add drag over to the cell for visual feedback
                                    cell.addEventListener('dragover', handleDragOver);
                                    
                                    // ãƒ‡ãƒãƒƒã‚°ç”¨ãƒ­ã‚°ï¼ˆç‰¹å®šã®äºˆç´„ã®ã¿ï¼‰
                                    if (reservation.customer === 'ç”°ä¸­æ§˜') {
                                        console.log(`ğŸ” Created reservation block for ${dateKey} ${timeStr}:`, reservation);
                                    }
                                }
    } else {
                                cell.classList.add('available', 'bookable');
                                // æ–°è¦äºˆç´„ä½œæˆã®ãŸã‚ã®ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
                                cell.addEventListener('click', () => {
                                    const slotDate = new Date(currentWeekStart);
                                    slotDate.setDate(slotDate.getDate() + day);
                                    openBookingModal(slotDate, timeStr);
                                });
                            }
                        } else {
                            cell.classList.add('unavailable', 'outside-business-hours');
                        }
                        
                        row.appendChild(cell);
                    }
                    
                    scheduleBody.appendChild(row);
                }
            }
            
            // ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ç”Ÿæˆå¾Œã«ã‚­ãƒ£ãƒ³ã‚»ãƒ«è¡¨ç¤ºã‚’æ›´æ–°
            setTimeout(() => {
                updateCancellationDisplayImmediately();
            }, 10);
        }

        // ç¾åœ¨ã®é€±ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å–å¾—
        function getCurrentWeekSchedule() {
            // å®‰å…¨ãƒã‚§ãƒƒã‚¯: ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
            if (!defaultSchedule) {
                console.warn('âš ï¸ Default schedule not loaded, initializing fallback');
                initializeDefaultSchedule();
            }
            
            const weekKey = formatDateKey(currentWeekStart);
            if (!weeklySchedules[weekKey]) {
                // é€±å›ºæœ‰ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒãªã„å ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚’ä½¿ç”¨ï¼ˆã‚³ãƒ”ãƒ¼ã¯ä½œæˆã—ãªã„ï¼‰
                console.log(`ğŸ” No custom schedule for ${weekKey}, using default schedule`);
                return defaultSchedule;
            }
            
            console.log(`ğŸ” Using custom schedule for ${weekKey}`);
            return weeklySchedules[weekKey];
        }

        // å–¶æ¥­æ™‚é–“ã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯
        function isBusinessHour(dayOfWeek, timeStr) {
            // ç¾åœ¨ã®é€±ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ãƒã‚§ãƒƒã‚¯
            const currentWeekSchedule = getCurrentWeekSchedule();
            const currentSchedule = currentWeekSchedule[dayOfWeek];
            
            // ãƒ‡ãƒãƒƒã‚°ç”¨ãƒ­ã‚°ï¼ˆ18:20ã®æ™‚é–“ã®ã¿ï¼‰
            if (timeStr === '18:20') {
                console.log('ğŸ” isBusinessHour debug for 18:20:', {
                    dayOfWeek,
                    currentSchedule,
                    currentWeekSchedule: Object.keys(currentWeekSchedule)
                });
            }
            
            // ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒæœ‰åŠ¹ã§æ™‚é–“è¨­å®šãŒã‚ã‚‹å ´åˆã®ã¿ãƒã‚§ãƒƒã‚¯
            if (currentSchedule && currentSchedule.enabled && currentSchedule.times.length > 0) {
                const [hours, minutes] = timeStr.split(':').map(Number);
                const timeInMinutes = hours * 60 + minutes;
                
                const isAvailable = currentSchedule.times.some(slot => {
                    const [startHour, startMin] = slot.start.split(':').map(Number);
                    const [endHour, endMin] = slot.end.split(':').map(Number);
                    const startInMinutes = startHour * 60 + startMin;
                    const endInMinutes = endHour * 60 + endMin;
                    
                    return timeInMinutes >= startInMinutes && timeInMinutes < endInMinutes;
                });
                
                // ãƒ‡ãƒãƒƒã‚°ç”¨ãƒ­ã‚°ï¼ˆç‰¹å®šã®æ™‚é–“ã®ã¿ï¼‰
                if (timeStr === '10:00' && dayOfWeek === 1) {
                    console.log(`ğŸ” Business hour check for Monday 10:00:`, {
                        schedule: currentSchedule,
                        timeInMinutes,
                        isAvailable,
                        scheduleType: currentWeekSchedule === defaultSchedule ? 'default' : 'custom'
                    });
                }
                
                return isAvailable;
            }
            
    return false;
  }
  
        // äºˆç´„ã‚’æ¤œç´¢
        function findReservation(dateKey, timeStr) {
            const dayReservations = reservations[dateKey] || [];
            
            // ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šç‰¹å®šã®äºˆç´„ã‚’ãƒã‚§ãƒƒã‚¯
            if (dateKey === '2025-08-13' && timeStr === '10:00') {
                console.log('ğŸ” findReservation called for 2025-08-13 10:00');
                console.log('ğŸ” dayReservations:', dayReservations);
                console.log('ğŸ” Looking for reservation 97:', dayReservations.find(r => r.id === 97));
            }
            return dayReservations.find(reservation => {
                const reservationTime = reservation.time;
                const [resHour, resMin] = reservationTime.split(':').map(Number);
                const [checkHour, checkMin] = timeStr.split(':').map(Number);
                
                const resTimeInMin = resHour * 60 + resMin;
                const checkTimeInMin = checkHour * 60 + checkMin;
                const preparationTime = reservation.effective_interval_minutes ?? 10; // å®Ÿéš›ã®æº–å‚™æ™‚é–“ã‚’ä½¿ç”¨
                const endTimeInMin = resTimeInMin + reservation.duration + preparationTime;
                
                // æ™‚é–“ã‚¹ãƒ­ãƒƒãƒˆã®å¢ƒç•Œã‚’è€ƒæ…®ã—ã¦ã€æ¬¡ã®æ™‚é–“ã‚¹ãƒ­ãƒƒãƒˆã¨ã®é‡è¤‡ã‚’é¿ã‘ã‚‹
                const nextHourInMin = Math.ceil(endTimeInMin / 60) * 60; // æ¬¡ã®æ™‚é–“ã®é–‹å§‹
                const adjustedEndTimeInMin = Math.min(endTimeInMin, nextHourInMin);
                
                // ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šæ™‚é–“è¨ˆç®—ã‚’ç¢ºèª
                if (timeStr === '15:00' && reservation.customer === 'å‰ç”°') {
                    console.log('ğŸ” Time calculation debug:', {
                        reservationTime,
                        timeStr,
                        resTimeInMin,
                        checkTimeInMin,
                        duration: reservation.duration,
                        preparationTime,
                        endTimeInMin,
                        isOverlapping: checkTimeInMin >= resTimeInMin && checkTimeInMin < endTimeInMin
                    });
                }
                
                return checkTimeInMin >= resTimeInMin && checkTimeInMin < adjustedEndTimeInMin;
            });
        }

        // äºˆç´„ã®é–‹å§‹ã‚¹ãƒ­ãƒƒãƒˆã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯
        function isReservationStart(dateKey, timeStr) {
            const dayReservations = reservations[dateKey] || [];
            return dayReservations.some(reservation => {
                return reservation.time === timeStr;
            });
        }

        // äºˆç´„ã®ç¶™ç¶šã‚¹ãƒ­ãƒƒãƒˆã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯
        function isReservationContinuation(dateKey, timeStr) {
            const dayReservations = reservations[dateKey] || [];
            return dayReservations.some(reservation => {
                const reservationTime = reservation.time;
                const [resHour, resMin] = reservationTime.split(':').map(Number);
                const [checkHour, checkMin] = timeStr.split(':').map(Number);
                
                const resTimeInMin = resHour * 60 + resMin;
                const checkTimeInMin = checkHour * 60 + checkMin;
                const endTimeInMin = resTimeInMin + reservation.duration;
                
                return checkTimeInMin > resTimeInMin && checkTimeInMin < endTimeInMin;
            });
        }

        // äºˆç´„ãƒ–ãƒ­ãƒƒã‚¯ã‚’ä½œæˆ
        function createReservationBlock(reservation) {
            const block = document.createElement('div');
            block.className = `reservation-block ${reservation.status}`;
            block.draggable = true;
            block.dataset.reservationId = reservation.id;
            block.dataset.reservationData = JSON.stringify(reservation);
            
            const statusIcon = {
                'tentative': 'â³',
                'confirmed': 'âœ“',
                'completed': 'âœ…'
            };
            
            block.innerHTML = `
                ${statusIcon[reservation.status] || ''} ${reservation.customer}
                <div style="font-size: 9px; opacity: 0.9;">${reservation.duration}åˆ†</div>
            `;
            
            return block;
        }

        // ã‚¹ãƒ‘ãƒ‹ãƒ³ã‚°äºˆç´„ãƒ–ãƒ­ãƒƒã‚¯ã‚’ä½œæˆ
        function createSpanningReservationBlock(reservation, dateKey, timeStr) {
            console.log('ğŸ¯ Creating spanning block for reservation:', reservation.id, {
                effective_interval_minutes: reservation.effective_interval_minutes,
                individual_interval_minutes: reservation.individual_interval_minutes,
                duration: reservation.duration
            });
            const block = document.createElement('div');
            block.className = `reservation-block spanning ${reservation.status}`;
            block.draggable = true; // ãƒ¡ã‚¤ãƒ³ãƒ–ãƒ­ãƒƒã‚¯ã‚’ãƒ‰ãƒ©ãƒƒã‚°å¯èƒ½ã«å¤‰æ›´
            block.dataset.reservationId = reservation.id;
            block.dataset.reservationData = JSON.stringify(reservation);
            block.dataset.originalDateKey = dateKey;
            block.dataset.originalTimeStr = timeStr;
            
            const statusIcon = {
                'tentative': 'â³',
                'confirmed': 'âœ“',
                'completed': 'âœ…'
            };
            
            // äºˆç´„ã®ç¶™ç¶šæ™‚é–“ã«åŸºã¥ã„ã¦é«˜ã•ã‚’è¨ˆç®—ï¼ˆæ­£ç¢ºãªæ™‚é–“ + æº–å‚™æ™‚é–“ï¼‰
            const durationInMinutes = reservation.duration;
            const preparationTime = reservation.effective_interval_minutes ?? 10; // æº–å‚™æ™‚é–“ï¼ˆåˆ†ï¼‰
            const totalTime = durationInMinutes + preparationTime;
                         const rowHeight = 20; // å„æ™‚é–“ã‚¹ãƒ­ãƒƒãƒˆã®é«˜ã•ï¼ˆ10åˆ†é–“ï¼‰
            const exactHeight = (totalTime / 10) * rowHeight; // æ­£ç¢ºãªé«˜ã•ã‚’è¨ˆç®—
            
            block.style.height = `${exactHeight}px`;
            block.style.top = '0';
            
            // æº–å‚™æ™‚é–“éƒ¨åˆ†ã‚’è¦–è¦šçš„ã«åŒºåˆ¥
            const bookingHeight = (durationInMinutes / 10) * rowHeight;
            const preparationHeight = (preparationTime / 10) * rowHeight;
            
            // é–‹å§‹æ™‚é–“ã¨çµ‚äº†æ™‚é–“ã‚’è¨ˆç®—
            const [startHour, startMin] = timeStr.split(':').map(Number);
            const startTimeInMinutes = startHour * 60 + startMin;
            const endTimeInMinutes = startTimeInMinutes + reservation.duration;
            
            const startTime = `${String(Math.floor(startTimeInMinutes / 60)).padStart(2, '0')}:${String(startTimeInMinutes % 60).padStart(2, '0')}`;
            const endTime = `${String(Math.floor(endTimeInMinutes / 60)).padStart(2, '0')}:${String(endTimeInMinutes % 60).padStart(2, '0')}`;
            
            // æº–å‚™æ™‚é–“ãŒ0ã®å ´åˆã¯æº–å‚™æ™‚é–“ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¡¨ç¤ºã—ãªã„
            const preparationSection = preparationTime > 0 ? `
                <div style="height: ${preparationHeight}px; background: linear-gradient(135deg, rgba(255,255,255,0.2), rgba(255,255,255,0.1)); display: flex; align-items: center; justify-content: center; font-size: 9px; border-top: 1px solid rgba(255,255,255,0.3); backdrop-filter: blur(1px); position: absolute; left: 0; right: 0; bottom: 0; width: 100%;">
                    <div style="position: absolute; top: 0; left: 0; right: 0; height: 1px; background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);"></div>
                    <span style="background: rgba(255,255,255,0.25); padding: 3px 10px; border-radius: 15px; font-weight: 600; font-size: 8px; text-transform: uppercase; letter-spacing: 0.5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">${preparationTime}åˆ†</span>
                </div>
            ` : '';
            
            block.innerHTML = `
                <div style="height: ${preparationTime > 0 ? bookingHeight : exactHeight}px; display: flex; flex-direction: column; justify-content: center; padding: 8px; position: relative;">

                    <div style="font-size: 12px; font-weight: 600; margin-bottom: 4px; text-shadow: 0 1px 2px rgba(0,0,0,0.3);">
                        ${statusIcon[reservation.status] || ''} ${reservation.customer}
      </div>
                    <div style="font-size: 10px; opacity: 0.9; background: rgba(255,255,255,0.2); padding: 2px 6px; border-radius: 10px; display: inline-block; backdrop-filter: blur(2px); margin-bottom: 4px;">
                        ${reservation.duration}åˆ†
    </div>
                    <div style="font-size: 9px; opacity: 0.8; background: rgba(0,0,0,0.2); padding: 2px 6px; border-radius: 8px; display: inline-block; backdrop-filter: blur(1px);">
                        ${startTime} - ${endTime}
        </div>
        </div>
                ${preparationSection}
    `;
            
            return block;
        }

        // è¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
        function openSettingsModal() {
            document.getElementById('settingsModal').style.display = 'block';
            renderDaySettings();
        }

        // è¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
        function closeSettingsModal() {
            document.getElementById('settingsModal').style.display = 'none';
        }

        // ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆ
        function switchTab(tabName) {
            // ã‚¿ãƒ–ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹æ›´æ–°
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`[onclick="switchTab('${tabName}')"]`).classList.add('active');
            
            // ã‚¿ãƒ–ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆ
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(`${tabName}-tab`).classList.add('active');
            
            if (tabName === 'recurring') {
                renderRecurringDaySettings();
            }
        }

        // æ›œæ—¥åˆ¥è¨­å®šã‚’æç”»
        function renderDaySettings() {
            // é€±æƒ…å ±ã‚’æ›´æ–°
            updateWeekInfo();
            
            const container = document.getElementById('daySettings');
            container.innerHTML = '';
            
            for (let day = 0; day < 7; day++) {
                const dayDiv = createDaySettingDiv(day, false);
                container.appendChild(dayDiv);
            }
        }

        // å®šæœŸçš„ãªè¨­å®šã‚’æç”»
        function renderRecurringDaySettings() {
            const container = document.getElementById('recurringDaySettings');
            container.innerHTML = '';
            
            for (let day = 0; day < 7; day++) {
                const dayDiv = createDaySettingDiv(day, true);
                container.appendChild(dayDiv);
            }
        }

        // é€±æƒ…å ±ã‚’æ›´æ–°
        function updateWeekInfo() {
            const weekStartStr = formatDateKey(currentWeekStart);
            const weekEnd = new Date(currentWeekStart);
            weekEnd.setDate(weekEnd.getDate() + 6);
            const weekEndStr = formatDateKey(weekEnd);
            
            const currentWeekDisplay = document.getElementById('current-week-display');
            const scheduleTypeInfo = document.getElementById('schedule-type-info');
            
            if (currentWeekDisplay) {
                currentWeekDisplay.textContent = `${weekStartStr} ã€œ ${weekEndStr}`;
            }
            
            if (scheduleTypeInfo) {
                const hasCustomSchedule = weeklySchedules[weekStartStr] && 
                    JSON.stringify(weeklySchedules[weekStartStr]) !== JSON.stringify(defaultSchedule);
                
                if (hasCustomSchedule) {
                    scheduleTypeInfo.textContent = 'âœ… ã“ã®é€±ã«ã¯ã‚«ã‚¹ã‚¿ãƒ ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã™';
                    scheduleTypeInfo.style.color = '#28a745';
                } else {
                    scheduleTypeInfo.textContent = 'â„¹ï¸ ã“ã®é€±ã«ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒé©ç”¨ã•ã‚Œã¦ã„ã¾ã™';
                    scheduleTypeInfo.style.color = '#6c757d';
                }
            }
        }

        // æ›œæ—¥è¨­å®šDIVã‚’ä½œæˆ
        function createDaySettingDiv(day, isRecurring) {
            // å®‰å…¨ãƒã‚§ãƒƒã‚¯: ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ‡ãƒ¼ã‚¿ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
            if (!defaultSchedule || !defaultSchedule[day]) {
                console.warn(`âš ï¸ Schedule data not loaded for day ${day}, using fallback`);
                return createFallbackDaySettingDiv(day, isRecurring);
            }
            
            const schedule = isRecurring ? defaultSchedule[day] : getCurrentWeekSchedule()[day];
            const dayDiv = document.createElement('div');
            dayDiv.className = 'day-setting';
            
            const headerClass = day === 0 ? 'sunday' : day === 6 ? 'saturday' : '';
            
            dayDiv.innerHTML = `
                <div class="day-setting-header ${headerClass}">
                    <span>${dayNamesLong[day]}</span>
                    <div class="day-toggle ${schedule.enabled ? 'active' : ''}" onclick="toggleDay(${day}, ${isRecurring})"></div>
        </div>
                <div class="time-slots-container" style="display: ${schedule.enabled ? 'block' : 'none'};">
                    <div id="timeSlots-${day}-${isRecurring}" class="time-slots">
                        ${renderTimeSlots(day, schedule.times, isRecurring)}
        </div>
                    <button class="add-time-btn" onclick="addTimeSlot(${day}, ${isRecurring})">
                        + æ™‚é–“å¸¯ã‚’è¿½åŠ 
          </button>
        </div>
  `;
            
            return dayDiv;
        }

        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”¨ã®æ›œæ—¥è¨­å®šDIVã‚’ä½œæˆ
        function createFallbackDaySettingDiv(day, isRecurring) {
            const dayDiv = document.createElement('div');
            dayDiv.className = 'day-setting';
            
            const headerClass = day === 0 ? 'sunday' : day === 6 ? 'saturday' : '';
            
            dayDiv.innerHTML = `
                <div class="day-setting-header ${headerClass}">
                    <span>${dayNamesLong[day]}</span>
                    <div class="day-toggle" onclick="toggleDay(${day}, ${isRecurring})"></div>
      </div>
                <div class="time-slots-container" style="display: none;">
                    <div id="timeSlots-${day}-${isRecurring}" class="time-slots">
                        <!-- ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ä¸­ -->
                    </div>
                    <button class="add-time-btn" onclick="addTimeSlot(${day}, ${isRecurring})">
                        + æ™‚é–“å¸¯ã‚’è¿½åŠ 
                    </button>
    </div>
  `;
            
            return dayDiv;
        }

        // æ™‚é–“ã‚¹ãƒ­ãƒƒãƒˆã‚’æç”»
        function renderTimeSlots(day, times, isRecurring = false) {
            return times.map((time, index) => `
                <div class="time-slot-input">
                    <input type="time" class="time-input" value="${time.start}" 
                           onchange="(async () => { await updateTimeSlot(${day}, ${index}, 'start', this.value, ${isRecurring}); })()">
                    <span>ã€œ</span>
                    <input type="time" class="time-input" value="${time.end}"
                           onchange="(async () => { await updateTimeSlot(${day}, ${index}, 'end', this.value, ${isRecurring}); })()">
                    <button class="btn btn-danger btn-sm" onclick="removeTimeSlot(${day}, ${index}, ${isRecurring})">å‰Šé™¤</button>
                </div>
            `).join('');
        }

        // æ›œæ—¥ã®æœ‰åŠ¹/ç„¡åŠ¹ã‚’åˆ‡ã‚Šæ›¿ãˆ
        async function toggleDay(day, isRecurring) {
            console.log(`Toggling day ${day} (${dayNamesLong[day]}) for recurring: ${isRecurring}`);
            
            const currentSchedule = isRecurring ? defaultSchedule[day] : getCurrentWeekSchedule()[day];
            const wouldBeDisabled = currentSchedule.enabled; // If currently enabled, it would become disabled
            
            // Check for existing reservations if trying to disable the day
            if (wouldBeDisabled) {
                console.log(`ğŸ” Checking if day ${day} can be disabled`);
                
                if (isRecurring) {
                    // For recurring schedules, check all future reservations for this day of week
                    try {
                        const affectedReservations = await checkRecurringScheduleImpact(day, '00:00', '00:00');
                        if (affectedReservations.length > 0) {
                            const dayName = ['æ—¥æ›œæ—¥', 'æœˆæ›œæ—¥', 'ç«æ›œæ—¥', 'æ°´æ›œæ—¥', 'æœ¨æ›œæ—¥', 'é‡‘æ›œæ—¥', 'åœŸæ›œæ—¥'][day];
                            const reservationList = affectedReservations.map(r => `${r.customer}æ§˜ (${r.date} ${r.time})`).join(', ');
                            
                            showMessage(`${dayName}ã‚’ä¼‘æ¥­æ—¥ã«ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚ä»¥ä¸‹ã®äºˆç´„ãŒã‚ã‚Šã¾ã™: ${reservationList}`, 'error');
                            return; // Don't proceed with the toggle
                        }
                    } catch (error) {
                        console.error('âŒ Error checking reservations for day toggle:', error);
                        showMessage('äºˆç´„çŠ¶æ³ã®ç¢ºèªä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚', 'error');
                        return;
                    }
                } else {
                    // For current week, check reservations for specific dates
                    const affectedReservations = checkCurrentWeekReservationsForDay(day);
                    if (affectedReservations.length > 0) {
                        const dayName = ['æ—¥æ›œæ—¥', 'æœˆæ›œæ—¥', 'ç«æ›œæ—¥', 'æ°´æ›œæ—¥', 'æœ¨æ›œæ—¥', 'é‡‘æ›œæ—¥', 'åœŸæ›œæ—¥'][day];
                        const reservationList = affectedReservations.map(r => `${r.customer}æ§˜ (${r.time})`).join(', ');
                        
                        showMessage(`${dayName}ã‚’ä¼‘æ¥­æ—¥ã«ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚ä»¥ä¸‹ã®äºˆç´„ãŒã‚ã‚Šã¾ã™: ${reservationList}`, 'error');
                        return; // Don't proceed with the toggle
                    }
                }
            }
            
            if (isRecurring) {
                // å®šæœŸçš„ãªã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å ´åˆ
                defaultSchedule[day].enabled = !defaultSchedule[day].enabled;
            } else {
                // ç¾åœ¨ã®é€±ã®å ´åˆã€ã‚«ã‚¹ã‚¿ãƒ ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½œæˆ
                const weekKey = formatDateKey(currentWeekStart);
                if (!weeklySchedules[weekKey]) {
                    weeklySchedules[weekKey] = JSON.parse(JSON.stringify(defaultSchedule));
                    console.log(`ğŸ” Created custom schedule for week ${weekKey}`);
                }
                weeklySchedules[weekKey][day].enabled = !weeklySchedules[weekKey][day].enabled;
            }
            
            const toggle = document.querySelector(`[onclick="toggleDay(${day}, ${isRecurring})"]`);
            const timeSlotsContainer = toggle.parentElement.nextElementSibling;
            
            const schedule = isRecurring ? defaultSchedule[day] : getCurrentWeekSchedule()[day];
            
            if (schedule.enabled) {
                toggle.classList.add('active');
                timeSlotsContainer.style.display = 'block';
                
                // æ™‚é–“ã‚¹ãƒ­ãƒƒãƒˆãŒãªã„å ´åˆã¯è¿½åŠ 
                if (schedule.times.length === 0) {
                    schedule.times.push({ start: '09:00', end: '18:00' });
                }
                
                // ç¾åœ¨ã®ã‚¿ãƒ–ã®ã‚³ãƒ³ãƒ†ãƒŠã®ã¿æ›´æ–°
                const slotsContainer = document.getElementById(`timeSlots-${day}-${isRecurring}`);
                if (slotsContainer) {
                    slotsContainer.innerHTML = renderTimeSlots(day, schedule.times, isRecurring);
                }
            } else {
                toggle.classList.remove('active');
                timeSlotsContainer.style.display = 'none';
            }
            
            console.log(`Day ${day} (${dayNamesLong[day]}) is now ${schedule.enabled ? 'enabled' : 'disabled'} for ${isRecurring ? 'recurring' : 'current week'}`);
        }

        // æ™‚é–“ã‚¹ãƒ­ãƒƒãƒˆã‚’è¿½åŠ 
        function addTimeSlot(day, isRecurring) {
            if (isRecurring) {
                defaultSchedule[day].times.push({ start: '09:00', end: '18:00' });
            } else {
                // ç¾åœ¨ã®é€±ã®å ´åˆã€ã‚«ã‚¹ã‚¿ãƒ ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½œæˆ
                const weekKey = formatDateKey(currentWeekStart);
                if (!weeklySchedules[weekKey]) {
                    weeklySchedules[weekKey] = JSON.parse(JSON.stringify(defaultSchedule));
                    console.log(`ğŸ” Created custom schedule for week ${weekKey}`);
                }
                weeklySchedules[weekKey][day].times.push({ start: '09:00', end: '18:00' });
            }
            
            // ç¾åœ¨ã®ã‚¿ãƒ–ã®ã‚³ãƒ³ãƒ†ãƒŠã®ã¿æ›´æ–°
            const slotsContainer = document.getElementById(`timeSlots-${day}-${isRecurring}`);
            if (slotsContainer) {
                const schedule = isRecurring ? defaultSchedule[day] : getCurrentWeekSchedule()[day];
                slotsContainer.innerHTML = renderTimeSlots(day, schedule.times, isRecurring);
            }
        }

        // æ™‚é–“ã‚¹ãƒ­ãƒƒãƒˆã‚’å‰Šé™¤
        function removeTimeSlot(day, index, isRecurring = false) {
            if (isRecurring) {
                defaultSchedule[day].times.splice(index, 1);
            } else {
                // ç¾åœ¨ã®é€±ã®å ´åˆã€ã‚«ã‚¹ã‚¿ãƒ ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½œæˆ
                const weekKey = formatDateKey(currentWeekStart);
                if (!weeklySchedules[weekKey]) {
                    weeklySchedules[weekKey] = JSON.parse(JSON.stringify(defaultSchedule));
                    console.log(`ğŸ” Created custom schedule for week ${weekKey}`);
                }
                weeklySchedules[weekKey][day].times.splice(index, 1);
            }
            
            // ç¾åœ¨ã®ã‚¿ãƒ–ã®ã‚³ãƒ³ãƒ†ãƒŠã®ã¿æ›´æ–°
            const slotsContainer = document.getElementById(`timeSlots-${day}-${isRecurring}`);
            if (slotsContainer) {
                const schedule = isRecurring ? defaultSchedule[day] : getCurrentWeekSchedule()[day];
                slotsContainer.innerHTML = renderTimeSlots(day, schedule.times, isRecurring);
            }
        }

        // æ™‚é–“ã‚¹ãƒ­ãƒƒãƒˆã‚’æ›´æ–°
        async function updateTimeSlot(day, index, field, value, isRecurring = false) {
            // å¤‰æ›´å‰ã®å€¤ã‚’ä¿å­˜
            let oldValue;
            if (isRecurring) {
                oldValue = defaultSchedule[day].times[index][field];
            } else {
                const weekKey = formatDateKey(currentWeekStart);
                if (!weeklySchedules[weekKey]) {
                    weeklySchedules[weekKey] = JSON.parse(JSON.stringify(defaultSchedule));
                }
                oldValue = weeklySchedules[weekKey][day].times[index][field];
            }
            
            // æ–°ã—ã„å€¤ã‚’è¨­å®š
            if (isRecurring) {
                defaultSchedule[day].times[index][field] = value;
            } else {
                const weekKey = formatDateKey(currentWeekStart);
                if (!weeklySchedules[weekKey]) {
                    weeklySchedules[weekKey] = JSON.parse(JSON.stringify(defaultSchedule));
                    console.log(`ğŸ” Created custom schedule for week ${weekKey}`);
                }
                weeklySchedules[weekKey][day].times[index][field] = value;
            }
            
            // æ™‚é–“å¤‰æ›´ã®å¦¥å½“æ€§ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆå®šæœŸçš„ãªã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚‚å«ã‚€ï¼‰
            if (isRecurring) {
                console.log('ğŸ” Validating recurring schedule time change:', {
                    day,
                    field,
                    oldValue,
                    newValue: value,
                    dayName: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][day]
                });
                
                // å®šæœŸçš„ãªã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å ´åˆã€åŸºæœ¬çš„ãªæ™‚é–“å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯
                if (field === 'start' || field === 'end') {
                    // æ™‚é–“å½¢å¼ã®åŸºæœ¬ãƒã‚§ãƒƒã‚¯
                    const timeRegex = /^([01]?[0-9]|2[0-3]):[0-5][0-9]$/;
                    if (!timeRegex.test(value)) {
                        showMessage('æ™‚é–“ã¯ HH:MM å½¢å¼ã§å…¥åŠ›ã—ã¦ãã ã•ã„', 'error');
                        // å…ƒã®å€¤ã«æˆ»ã™
                        defaultSchedule[day].times[index][field] = oldValue;
                        return;
                    }
                    
                    // é–‹å§‹æ™‚é–“ < çµ‚äº†æ™‚é–“ã®ãƒã‚§ãƒƒã‚¯
                    const currentSlot = defaultSchedule[day].times[index];
                    const startTime = field === 'start' ? value : currentSlot.start;
                    const endTime = field === 'end' ? value : currentSlot.end;
                    
                    if (startTime >= endTime) {
                        showMessage('é–‹å§‹æ™‚é–“ã¯çµ‚äº†æ™‚é–“ã‚ˆã‚Šå‰ã«è¨­å®šã—ã¦ãã ã•ã„', 'error');
                        // å…ƒã®å€¤ã«æˆ»ã™
                        defaultSchedule[day].times[index][field] = oldValue;
                        return;
                    }
                    
                    // æ—¢å­˜ã®äºˆç´„ã¸ã®å½±éŸ¿ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆéåŒæœŸï¼‰
                    try {
                        const affectedReservations = await checkRecurringScheduleImpact(day, startTime, endTime);
                        if (affectedReservations.length > 0) {
                            const dayName = ['æ—¥æ›œæ—¥', 'æœˆæ›œæ—¥', 'ç«æ›œæ—¥', 'æ°´æ›œæ—¥', 'æœ¨æ›œæ—¥', 'é‡‘æ›œæ—¥', 'åœŸæ›œæ—¥'][day];
                            const reservationList = affectedReservations.map(r => `${r.customer}æ§˜ (${r.date} ${r.time})`).join(', ');
                            
                            showMessage(`${dayName}ã®å–¶æ¥­æ™‚é–“å¤‰æ›´ã«ã‚ˆã‚Šã€ä»¥ä¸‹ã®äºˆç´„ãŒå–¶æ¥­æ™‚é–“å¤–ã«ãªã‚Šã¾ã™: ${reservationList}`, 'error');
                            
                            // å…ƒã®å€¤ã«æˆ»ã™
                            defaultSchedule[day].times[index][field] = oldValue;
                            return;
                        }
                    } catch (error) {
                        console.error('âŒ Error checking recurring schedule impact:', error);
                        showMessage('äºˆç´„ãƒ‡ãƒ¼ã‚¿ã®ç¢ºèªä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚', 'error');
                        // å…ƒã®å€¤ã«æˆ»ã™
                        defaultSchedule[day].times[index][field] = oldValue;
                        return;
                    }
                    
                    console.log('âœ… Recurring schedule time validation passed');
                }
            }
            
            // å–¶æ¥­æ™‚é–“ã®å¤‰æ›´ï¼ˆçŸ­ç¸®ãƒ»æ‹¡å¼µï¼‰ã®å ´åˆã€å½±éŸ¿ã‚’ãƒã‚§ãƒƒã‚¯
            if ((field === 'end' && parseInt(value) < parseInt(oldValue)) || 
                (field === 'start' && parseInt(value) > parseInt(oldValue)) ||
                (field === 'end' && parseInt(value) > parseInt(oldValue)) || 
                (field === 'start' && parseInt(value) < parseInt(oldValue))) {
                console.log(`ğŸ” Checking impact of changing business hours for day ${day} from ${oldValue} to ${value} (${field})`);
                
                // å½±éŸ¿ã‚’å—ã‘ã‚‹äºˆç´„ã‚’ãƒã‚§ãƒƒã‚¯
                const affectedReservations = checkShiftChangeImpact(day, oldValue, value, field);
                
                if (affectedReservations.length > 0) {
                    // å½±éŸ¿ãŒã‚ã‚‹å ´åˆã¯ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’è¡¨ç¤º
                    const confirmed = await showShiftChangeConfirmation(affectedReservations, day, oldValue, value, field);
                    if (!confirmed) {
                        // ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚ŒãŸå ´åˆã¯å…ƒã®å€¤ã«æˆ»ã™
                        if (isRecurring) {
                            defaultSchedule[day].times[index][field] = oldValue;
                        } else {
                            const weekKey = formatDateKey(currentWeekStart);
                            weeklySchedules[weekKey][day].times[index][field] = oldValue;
                        }
                        return;
                    }
                }
            }
        }

        // è¨­å®šã‚’ä¿å­˜
        function saveSettings() {
            // ç¾åœ¨ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚¿ãƒ–ã‚’ç¢ºèª
            const activeTab = document.querySelector('.tab-button.active');
            const isRecurring = activeTab && activeTab.textContent.includes('å®šæœŸçš„ãªã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«');
            
            console.log('ğŸ” Active tab:', activeTab ? activeTab.textContent : 'none');
            console.log('ğŸ” isRecurring:', isRecurring);
            
            const scheduleData = isRecurring ? defaultSchedule : getCurrentWeekSchedule();
            const weekStartStr = formatDateKey(currentWeekStart);
            
            console.log('ğŸ”„ Saving shift settings:', {
                isRecurring,
                weekStartStr,
                scheduleData
            });
            
            // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã«ä¿å­˜
            fetch('/admin/reservations/save_shift_settings', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
                    'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]')?.getAttribute('content')
                },
                body: JSON.stringify({
                    schedule_data: scheduleData,
                    is_recurring: isRecurring,
                    week_start_date: weekStartStr
                })
            })
            .then(response => response.json())
  .then(data => {
    if (data.success) {
                    console.log('âœ… Shift settings saved successfully');
                    
                    // è¡¨ç¤ºã‚’æ›´æ–°
                    renderWeekView();
                    closeSettingsModal();
                    
                    // ä¿å­˜å®Œäº†ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                    const message = isRecurring 
                        ? 'å®šæœŸçš„ãªã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒä¿å­˜ã•ã‚Œã¾ã—ãŸã€‚ã“ã®è¨­å®šã¯å…¨ã¦ã®é€±ã«é©ç”¨ã•ã‚Œã¾ã™ã€‚'
                        : 'è¨­å®šãŒä¿å­˜ã•ã‚Œã¾ã—ãŸã€‚ã“ã®è¨­å®šã¯ç¾åœ¨ã®é€±ã®ã¿ã«é©ç”¨ã•ã‚Œã¾ã™ã€‚';
                    showMessage(message, 'success');
    } else {
                    console.error('âŒ Failed to save shift settings:', data.message);
                    showMessage(`ã‚·ãƒ•ãƒˆè¨­å®šã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: ${data.message}`, 'error');
    }
  })
  .catch(error => {
                console.error('âŒ Error saving shift settings:', error);
                showMessage('ã‚·ãƒ•ãƒˆè¨­å®šã®ä¿å­˜ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ', 'error');
            });
        }

        // å‰é€±ã¸
        function previousWeek() {
            currentWeekStart.setDate(currentWeekStart.getDate() - 7);
            Promise.all([
                loadShiftSettingsFromBackend(),
                loadReservationsFromBackend()
            ]).then(() => {
                renderWeekView();
                updateCancellationDisplay(); // ã‚­ãƒ£ãƒ³ã‚»ãƒ«å±¥æ­´ã‚’æ›´æ–°
            });
        }

        // æ¬¡é€±ã¸
        function nextWeek() {
            currentWeekStart.setDate(currentWeekStart.getDate() + 7);
            Promise.all([
                loadShiftSettingsFromBackend(),
                loadReservationsFromBackend()
            ]).then(() => {
                renderWeekView();
                updateCancellationDisplay(); // ã‚­ãƒ£ãƒ³ã‚»ãƒ«å±¥æ­´ã‚’æ›´æ–°
            });
        }

        // æ—¥ä»˜ã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆï¼ˆçŸ­ç¸®ç‰ˆï¼‰
        function formatDateShort(date) {
            return `${date.getMonth() + 1}æœˆ${date.getDate()}æ—¥`;
        }
        
        // ã‚·ãƒ•ãƒˆå¤‰æ›´ã®å½±éŸ¿ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆãƒ©ãƒƒãƒ‘ãƒ¼é–¢æ•°ï¼‰
        function checkShiftChangeImpactAuto(day, oldTime, newTime, field) {
            // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚¿ãƒ–ã«åŸºã¥ã„ã¦isRecurringã‚’åˆ¤å®š
            const activeTab = document.querySelector('.tab-button.active');
            const isRecurring = activeTab && activeTab.textContent.includes('å®šæœŸçš„ãªã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«');
            
            console.log(`ğŸ” Checking impact of changing business hours for day ${day} from ${oldTime} to ${newTime} (${field})`);
            console.log(`ğŸ” Active tab text: "${activeTab ? activeTab.textContent : 'no active tab found'}"`);
            console.log(`ğŸ” isRecurring determined from active tab: ${isRecurring}`);
            
            return checkShiftChangeImpact(day, oldTime, newTime, field, isRecurring);
        }
        
        // ã‚·ãƒ•ãƒˆå¤‰æ›´ã®å½±éŸ¿ã‚’ãƒã‚§ãƒƒã‚¯
        function checkShiftChangeImpact(day, oldTime, newTime, field, isRecurring = null) {
            const affectedReservations = [];
            const dayNames = ['æ—¥', 'æœˆ', 'ç«', 'æ°´', 'æœ¨', 'é‡‘', 'åœŸ'];
            
            // If isRecurring is not specified, auto-detect from active tab
            if (isRecurring === null) {
                const activeTab = document.querySelector('.tab-button.active');
                isRecurring = activeTab && activeTab.textContent.includes('å®šæœŸçš„ãªã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«');
                console.log(`ğŸ” Auto-detected isRecurring from active tab: "${activeTab ? activeTab.textContent : 'no active tab'}" -> ${isRecurring}`);
            }
            
            console.log(`ğŸ” checkShiftChangeImpact called with: day=${day} (${dayNames[day]}), oldTime=${oldTime}, newTime=${newTime}, field=${field}, isRecurring=${isRecurring}`);
            console.log(`ğŸ” All reservations:`, reservations);
            
            // Get current week dates if this is not a recurring change
            let currentWeekDates = [];
            if (!isRecurring && currentWeekStart) {
                const weekStart = new Date(currentWeekStart);
                for (let i = 0; i < 7; i++) {
                    const date = new Date(weekStart);
                    date.setDate(weekStart.getDate() + i);
                    const year = date.getFullYear();
                    const month = String(date.getMonth() + 1).padStart(2, '0');
                    const dayStr = String(date.getDate()).padStart(2, '0');
                    currentWeekDates.push(`${year}-${month}-${dayStr}`);
                }
                console.log(`ğŸ” Current week dates:`, currentWeekDates);
            }
            
            // Check reservations (all weeks for recurring, current week only for non-recurring)
            Object.keys(reservations).forEach(weekKey => {
                // If not recurring, only check current week dates
                if (!isRecurring && !currentWeekDates.includes(weekKey)) {
                    console.log(`ğŸ” Skipping ${weekKey} - not in current week`);
                    return;
                }
                const weekReservations = reservations[weekKey] || [];
                
                weekReservations.forEach(reservation => {
                    // é€±ã®ã‚­ãƒ¼ã‹ã‚‰æ—¥ä»˜ã‚’å–å¾—
                    const reservationDate = new Date(weekKey);
                    const reservationDayOfWeek = reservationDate.getDay();
                    
                    console.log(`ğŸ” Checking reservation: ${reservation.id} on ${weekKey} (day ${reservationDayOfWeek}) vs target day ${day}`);
                    
                    // åŒã˜æ›œæ—¥ã®äºˆç´„ã‚’ãƒã‚§ãƒƒã‚¯
                    if (reservationDayOfWeek === day) {
                        const [startHour, startMin] = reservation.time.split(':').map(Number);
                        const reservationStartInMin = startHour * 60 + startMin;
                        const reservationEndInMin = reservationStartInMin + reservation.duration;
                        console.log(`ğŸ” Reservation time: ${reservation.time} (start: ${reservationStartInMin} min, duration: ${reservation.duration} min, end: ${reservationEndInMin} min)`);
                        let isAffected = false;
                        if (field === 'end') {
                            if (parseInt(newTime) < parseInt(oldTime)) {
                                // æ–°ã—ã„çµ‚äº†æ™‚é–“ï¼ˆåˆ†å˜ä½ï¼‰
                                let newEndInMin;
                                if (String(newTime).includes(':')) {
                                    const [h, m] = String(newTime).split(':').map(Number);
                                    newEndInMin = h * 60 + (isNaN(m) ? 0 : m);
                                } else {
                                    newEndInMin = parseInt(newTime) * 60;
                                }
                                // çµ‚äº†æ™‚é–“ãŒçŸ­ç¸®ã•ã‚Œã‚‹å ´åˆ - äºˆç´„ãŒæ–°ã—ã„çµ‚äº†æ™‚é–“ã‚’è¶…ãˆã‚‹å ´åˆ
                                isAffected = reservationEndInMin > newEndInMin;
                                console.log(`ğŸ” End time shrinking check: reservation ends at ${reservationEndInMin} min, new end time is ${newEndInMin} min = ${isAffected}`);
                            } else {
                                // çµ‚äº†æ™‚é–“ãŒæ‹¡å¼µã•ã‚Œã‚‹å ´åˆ
                                let oldEndInMin, newEndInMin;
                                if (String(oldTime).includes(':')) {
                                    const [h, m] = String(oldTime).split(':').map(Number);
                                    oldEndInMin = h * 60 + (isNaN(m) ? 0 : m);
                                } else {
                                    oldEndInMin = parseInt(oldTime) * 60;
                                }
                                if (String(newTime).includes(':')) {
                                    const [h, m] = String(newTime).split(':').map(Number);
                                    newEndInMin = h * 60 + (isNaN(m) ? 0 : m);
                                } else {
                                    newEndInMin = parseInt(newTime) * 60;
                                }
                                isAffected = reservationStartInMin >= oldEndInMin && reservationStartInMin < newEndInMin;
                                console.log(`ğŸ” End time expanding check: ${reservationStartInMin} >= ${oldEndInMin} AND ${reservationStartInMin} < ${newEndInMin} = ${isAffected}`);
                            }
                        } else if (field === 'start') {
                            if (parseInt(newTime) > parseInt(oldTime)) {
                                // é–‹å§‹æ™‚é–“ãŒé…ããªã‚‹å ´åˆ
                                let newStartInMin;
                                if (String(newTime).includes(':')) {
                                    const [h, m] = String(newTime).split(':').map(Number);
                                    newStartInMin = h * 60 + (isNaN(m) ? 0 : m);
                                } else {
                                    newStartInMin = parseInt(newTime) * 60;
                                }
                                isAffected = reservationStartInMin < newStartInMin;
                                console.log(`ğŸ” Start time delaying check: ${reservationStartInMin} < ${newStartInMin} = ${isAffected}`);
                            } else {
                                // é–‹å§‹æ™‚é–“ãŒæ—©ããªã‚‹å ´åˆ
                                let oldStartInMin, newStartInMin;
                                if (String(oldTime).includes(':')) {
                                    const [h, m] = String(oldTime).split(':').map(Number);
                                    oldStartInMin = h * 60 + (isNaN(m) ? 0 : m);
                                } else {
                                    oldStartInMin = parseInt(oldTime) * 60;
                                }
                                if (String(newTime).includes(':')) {
                                    const [h, m] = String(newTime).split(':').map(Number);
                                    newStartInMin = h * 60 + (isNaN(m) ? 0 : m);
                                } else {
                                    newStartInMin = parseInt(newTime) * 60;
                                }
                                isAffected = reservationStartInMin >= newStartInMin && reservationStartInMin < oldStartInMin;
                                console.log(`ğŸ” Start time advancing check: ${reservationStartInMin} >= ${newStartInMin} AND ${reservationStartInMin} < ${oldStartInMin} = ${isAffected}`);
                            }
                        }
                        if (isAffected) {
                            affectedReservations.push({
                                id: reservation.id,
                                customer: reservation.customer,
                                start_time: reservation.time,
                                end_time: `${Math.floor(reservationEndInMin/60)}:${(reservationEndInMin%60).toString().padStart(2,'0')}`,
                                date: weekKey,
                                dayName: dayNames[day]
                            });
                            console.log(`ğŸ” Added affected reservation: ${reservation.id}`);
                        }
                    }
                });
            });
            
            console.log(`ğŸ” Found ${affectedReservations.length} affected reservations for day ${day} (${dayNames[day]}) - ${field} time change`);
            return affectedReservations;
        }
        
        // ã‚·ãƒ•ãƒˆå¤‰æ›´ã®ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’è¡¨ç¤º
        function showShiftChangeConfirmation(affectedReservations, day, oldTime, newTime, field) {
            return new Promise((resolve) => {
                const dayNames = ['æ—¥', 'æœˆ', 'ç«', 'æ°´', 'æœ¨', 'é‡‘', 'åœŸ'];
                const fieldName = field === 'start' ? 'é–‹å§‹æ™‚é–“' : 'çµ‚äº†æ™‚é–“';
                
                // æ—¢å­˜ã®ãƒ¢ãƒ¼ãƒ€ãƒ«ãŒã‚ã‚Œã°å‰Šé™¤
                const existingModal = document.getElementById('shiftChangeModal');
                if (existingModal) {
                    existingModal.remove();
                }
                
                const modal = document.createElement('div');
                modal.id = 'shiftChangeModal';
                modal.className = 'modal fade';
                modal.setAttribute('tabindex', '-1');
                modal.setAttribute('aria-labelledby', 'shiftChangeModalLabel');
                modal.setAttribute('aria-hidden', 'true');
                modal.innerHTML = `
                    <div class="modal-dialog modal-lg">
                        <div class="modal-content">
                            <div class="modal-header bg-warning text-dark">
                                <h5 class="modal-title" id="shiftChangeModalLabel">âš ï¸ å–¶æ¥­æ™‚é–“å¤‰æ›´ã®ç¢ºèª</h5>
                                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                            </div>
                            <div class="modal-body">
                                <div class="alert alert-warning mb-1">
                                    <strong>å–¶æ¥­æ™‚é–“ã®å¤‰æ›´ã«ã‚ˆã‚Šå½±éŸ¿ã‚’å—ã‘ã‚‹äºˆç´„ãŒã‚ã‚Šã¾ã™:</strong><br>
                                    ${dayNames[day]}æ›œæ—¥ ${fieldName}: ${oldTime}:00 â†’ ${newTime}:00
                                </div>
                                
                                <div class="table-responsive mb-1" style="max-height: 300px; overflow-y: hidden;">
                                    <table class="table table-sm mb-0">
                                        <thead>
                                            <tr>
                                                <th style="font-size: 1rem; padding: 0.3rem;">æ—¥æ™‚</th>
                                                <th style="font-size: 1rem; padding: 0.3rem;">ãŠå®¢æ§˜</th>
                                                <th style="font-size: 1rem; padding: 0.3rem;">æ™‚é–“</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            ${affectedReservations.map(reservation => `
                                                <tr>
                                                    <td style="font-size: 1rem; padding: 0.3rem;">${reservation.date}</td>
                                                    <td style="font-size: 1rem; padding: 0.3rem;">${reservation.customer}</td>
                                                    <td style="font-size: 1rem; padding: 0.3rem;">${reservation.start_time}-${reservation.end_time}</td>
                                                </tr>
                                            `).join('')}
                                        </tbody>
                                    </table>
                                </div>
                                
                                <div class="alert alert-danger mb-0">
                                    <strong>ã‚¨ãƒ©ãƒ¼:</strong> å–¶æ¥­æ™‚é–“ã‚’å¤‰æ›´ã™ã‚‹ã¨ã€ã“ã‚Œã‚‰ã®äºˆç´„ãŒå–¶æ¥­æ™‚é–“å¤–ã«ãªã£ã¦ã—ã¾ã„ã¾ã™ã€‚å¤‰æ›´ã¯ã§ãã¾ã›ã‚“ã€‚
                                </div>
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-primary" id="cancelShiftChange">OK</button>
                            </div>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¨­å®š
                const cancelBtn = modal.querySelector('#cancelShiftChange');
                const closeBtn = modal.querySelector('.btn-close');
                
                cancelBtn.addEventListener('click', () => {
                    modal.remove();
                    resolve(false);
                });
                
                closeBtn.addEventListener('click', () => {
                    modal.remove();
                    resolve(false);
                });
                
                // ãƒ¢ãƒ¼ãƒ€ãƒ«ã®å¤–å´ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹
                modal.addEventListener('click', (event) => {
                    if (event.target === modal) {
                        modal.remove();
                        resolve(false);
                    }
                });
                
                // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’è¡¨ç¤º
                modal.style.display = 'block';
                modal.classList.add('show');
                modal.setAttribute('aria-modal', 'true');
                modal.setAttribute('role', 'dialog');
                
                // èƒŒæ™¯ã‚’æš—ãã™ã‚‹
                const backdrop = document.createElement('div');
                backdrop.className = 'modal-backdrop fade show';
                backdrop.id = 'shiftChangeBackdrop';
                document.body.appendChild(backdrop);
                
                        // ESCã‚­ãƒ¼ã§é–‰ã˜ã‚‹
        const handleEscKey = (event) => {
            if (event.key === 'Escape') {
                modal.remove();
                backdrop.remove();
                document.removeEventListener('keydown', handleEscKey);
                resolve(false);
            }
        };
        document.addEventListener('keydown', handleEscKey);
        
        // ãƒ¢ãƒ¼ãƒ€ãƒ«ã¨ãƒãƒƒã‚¯ãƒ‰ãƒ­ãƒƒãƒ—ã‚’å‰Šé™¤ã™ã‚‹é–¢æ•°
        const cleanup = () => {
            if (modal) modal.remove();
            if (backdrop) backdrop.remove();
            document.removeEventListener('keydown', handleEscKey);
        };
        
        // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚’è¨­å®š
        cancelBtn.addEventListener('click', cleanup);
        closeBtn.addEventListener('click', cleanup);
        modal.addEventListener('click', (event) => {
            if (event.target === modal) {
                cleanup();
                resolve(false);
            }
        });
    });
        }

        // æ—¥ä»˜ã‚­ãƒ¼ã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
        function formatDateKey(date) {
            return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
        }

        // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤º
function showMessage(message, type = 'info') {
            const messageDiv = document.createElement('div');
            messageDiv.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                z-index: 2000;
                padding: 12px 20px;
                border-radius: 6px;
                color: white;
                font-weight: 500;
                animation: slideInRight 0.3s ease;
                background: ${type === 'success' ? '#28a745' : type === 'error' ? '#dc3545' : type === 'warning' ? '#ffc107' : '#007bff'};
                color: ${type === 'warning' ? '#212529' : 'white'};
            `;
            messageDiv.textContent = message;
            
            document.body.appendChild(messageDiv);
            
  setTimeout(() => {
                messageDiv.style.animation = 'slideOutRight 0.3s ease';
                setTimeout(() => document.body.removeChild(messageDiv), 300);
  }, 3000);
}

        // ãƒ¢ãƒ¼ãƒ€ãƒ«ã®å¤–å´ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹
        window.onclick = function(event) {
            const modal = document.getElementById('settingsModal');
            if (event.target === modal) {
                closeSettingsModal();
            }
            
            // ãƒŸãƒ‹ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã®å¤–å´ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹
            const miniCalendar = document.getElementById('miniCalendar');
            const miniCalendarContainer = document.querySelector('.mini-calendar-container');
            if (miniCalendar && !miniCalendarContainer.contains(event.target)) {
                miniCalendar.classList.remove('show');
            }
        }

        // ãƒŸãƒ‹ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼é–¢é€£ã®é–¢æ•°
        function toggleMiniCalendar() {
            const miniCalendar = document.getElementById('miniCalendar');
            miniCalendar.classList.toggle('show');
        }

        function renderMiniCalendar() {
            const year = miniCalendarMonth.getFullYear();
            const month = miniCalendarMonth.getMonth();
            
            console.log('ğŸ“… Rendering mini calendar for:', year, 'å¹´', monthNames[month]);
            
            // ã‚¿ã‚¤ãƒˆãƒ«ã‚’æ›´æ–°
            document.getElementById('miniCalendarTitle').textContent = 
                `${year}å¹´ ${monthNames[month]}`;
            
            // æœˆã®æœ€åˆã®æ—¥ã¨æœ€å¾Œã®æ—¥ã‚’å–å¾—
            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            
            // æœ€åˆã®é€±ã®é–‹å§‹æ—¥ã‚’å–å¾—ï¼ˆæ—¥æ›œæ—¥ã‹ã‚‰ï¼‰
            const startDate = new Date(firstDay);
            startDate.setDate(startDate.getDate() - firstDay.getDay());
            
            // æœ€å¾Œã®é€±ã®çµ‚äº†æ—¥ã‚’å–å¾—ï¼ˆåœŸæ›œæ—¥ã¾ã§ï¼‰
            const endDate = new Date(lastDay);
            endDate.setDate(endDate.getDate() + (6 - lastDay.getDay()));
            
            const daysContainer = document.getElementById('miniCalendarDays');
            daysContainer.innerHTML = '';
            
            // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã®æ—¥ä»˜ã‚»ãƒ«ã‚’ç”Ÿæˆ
            const current = new Date(startDate);
            while (current <= endDate) {
                const dayDiv = document.createElement('div');
                dayDiv.className = 'mini-calendar-day';
                dayDiv.textContent = current.getDate();
                
                // ä»Šæœˆä»¥å¤–ã®æ—¥ä»˜
                if (current.getMonth() !== month) {
                    dayDiv.classList.add('other-month');
                }
                
                // ä»Šæ—¥ã®æ—¥ä»˜
                const today = new Date();
                if (current.toDateString() === today.toDateString()) {
                    dayDiv.classList.add('today');
                }
                
                // ã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸæ—¥ä»˜ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
                if (clickedDate && 
                    current.getFullYear() === clickedDate.getFullYear() && 
                    current.getMonth() === clickedDate.getMonth() && 
                    current.getDate() === clickedDate.getDate()) {
                    dayDiv.classList.add('clicked-day');
                }
                
                // ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ - å®‰å…¨ãªæ—¥ä»˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆ
                const clickDate = new Date(current.getFullYear(), current.getMonth(), current.getDate(), 12, 0, 0, 0);
                dayDiv.addEventListener('click', () => {
                    selectWeekFromDate(clickDate);
                });
                
                daysContainer.appendChild(dayDiv);
                current.setDate(current.getDate() + 1);
            }
        }

        function selectWeekFromDate(date) {
            console.log('ğŸ” Original clicked date:', date);
            console.log('ğŸ” Date details:', {
                year: date.getFullYear(),
                month: date.getMonth() + 1,
                date: date.getDate(),
                dayOfWeek: date.getDay(),
                toString: date.toString()
            });
            
            // æ—¥ä»˜ã‚’å®‰å…¨ã«å‡¦ç† - ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³ã®å½±éŸ¿ã‚’é¿ã‘ã‚‹
            const safeDate = new Date(
                date.getFullYear(),
                date.getMonth(),
                date.getDate(),
                12, 0, 0, 0  // æ­£åˆã«è¨­å®šã—ã¦ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³ã®å•é¡Œã‚’å›é¿
            );
            
            console.log('ğŸ“… Safe date for calculation:', safeDate);
            
            // æŒ‡å®šã•ã‚ŒãŸæ—¥ä»˜ãŒå«ã¾ã‚Œã‚‹é€±ã®é–‹å§‹æ—¥ï¼ˆæ—¥æ›œæ—¥ï¼‰ã‚’è¨ˆç®—
            const dayOfWeek = safeDate.getDay();
            const targetDate = safeDate.getDate() - dayOfWeek;
            
            console.log('Target date calculation:', safeDate.getDate(), '-', dayOfWeek, '=', targetDate);
            
            // é€±ã®é–‹å§‹æ—¥ã‚’å®‰å…¨ã«ä½œæˆ
            const weekStart = new Date(
                safeDate.getFullYear(),
                safeDate.getMonth(),
                targetDate,
                12, 0, 0, 0
            );
            
            console.log('ğŸ“… Calculated week start:', weekStart);
            console.log('ğŸ” Week start details:', {
                year: weekStart.getFullYear(),
                month: weekStart.getMonth() + 1,
                date: weekStart.getDate()
            });
            
            // ã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸæ—¥ä»˜ã‚’ä¿å­˜
            clickedDate = safeDate;
            
            // é€±ã‚’æ›´æ–°
            currentWeekStart = weekStart;
            
            // ã‚·ãƒ•ãƒˆè¨­å®šã¨äºˆç´„ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ã€è¡¨ç¤ºã‚’æ›´æ–°
            Promise.all([
                loadShiftSettingsFromBackend(),
                loadReservationsFromBackend()
            ]).then(() => {
                renderWeekView();
            });
            
            // ãƒŸãƒ‹ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚’é–‰ã˜ã‚‹
            document.getElementById('miniCalendar').classList.remove('show');
            
            // ãƒŸãƒ‹ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚’å†æç”»ï¼ˆé¸æŠçŠ¶æ…‹ã‚’æ›´æ–°ï¼‰
            renderMiniCalendar();
        }

        function previousMiniCalendarMonth() {
            const currentDate = miniCalendarMonth;
            const prevMonth = new Date(
                currentDate.getFullYear(),
                currentDate.getMonth() - 1,
                15, // æœˆã®ä¸­æ—¬ã«è¨­å®š
                12, 0, 0, 0
            );
            
            console.log('â¬…ï¸ Moving to previous month:', prevMonth);
            miniCalendarMonth = prevMonth;
            renderMiniCalendar();
        }

        function nextMiniCalendarMonth() {
            const currentDate = miniCalendarMonth;
            const nextMonth = new Date(
                currentDate.getFullYear(),
                currentDate.getMonth() + 1,
                15, // æœˆã®ä¸­æ—¬ã«è¨­å®š
                12, 0, 0, 0
            );
            
            console.log('â¡ï¸ Moving to next month:', nextMonth);
            miniCalendarMonth = nextMonth;
            renderMiniCalendar();
        }

        function previousMiniCalendarYear() {
            const currentDate = miniCalendarMonth;
            const prevYear = new Date(
                currentDate.getFullYear() - 1,
                currentDate.getMonth(),
                15, // æœˆã®ä¸­æ—¬ã«è¨­å®š
                12, 0, 0, 0
            );
            
            console.log('â¬…ï¸â¬…ï¸ Moving to previous year:', prevYear);
            miniCalendarMonth = prevYear;
            renderMiniCalendar();
        }

        function nextMiniCalendarYear() {
            const currentDate = miniCalendarMonth;
            const nextYear = new Date(
                currentDate.getFullYear() + 1,
                currentDate.getMonth(),
                15, // æœˆã®ä¸­æ—¬ã«è¨­å®š
                12, 0, 0, 0
            );
            
            console.log('â¡ï¸â¡ï¸ Moving to next year:', nextYear);
            miniCalendarMonth = nextYear;
            renderMiniCalendar();
        }

        // äºˆç´„ä½œæˆãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
        function openBookingModal(date, time) {
            document.getElementById('bookingDate').value = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${time}`;
            document.getElementById('bookingTime').value = time;
            document.getElementById('bookingDuration').value = ''; // ã‚³ãƒ¼ã‚¹é¸æŠã‚’ãƒªã‚»ãƒƒãƒˆ
            document.getElementById('customerName').value = '';
            document.getElementById('customerPhone').value = '';
            document.getElementById('customerEmail').value = '';
            document.getElementById('bookingNote').value = '';
            document.getElementById('bookingStatus').value = 'tentative';
            document.getElementById('bookingModal').style.display = 'block';
        }

        // äºˆç´„ä½œæˆãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
        function closeBookingModal() {
            document.getElementById('bookingModal').style.display = 'none';
            // ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
            isEditingReservation = false;
            currentReservation = null;
            reservationToEdit = null;
        }

        // äºˆç´„ã‚’ä½œæˆãƒ»æ›´æ–°
        function createBooking() {
            const dateTime = document.getElementById('bookingDate').value;
            const duration = document.getElementById('bookingDuration').value;
            const customerName = document.getElementById('customerName').value;
            const customerPhone = document.getElementById('customerPhone').value;
            const customerEmail = document.getElementById('customerEmail').value;
            const bookingNote = document.getElementById('bookingNote').value;
            const bookingStatus = document.getElementById('bookingStatus').value;

            console.log('ğŸ”„ Creating/Updating booking, isEditing:', isEditingReservation);

            if (!dateTime || !duration || !customerName || !customerPhone) {
                showMessage('äºˆç´„æ—¥æ™‚ã€ã‚³ãƒ¼ã‚¹ã€ãŠå®¢æ§˜åã€é›»è©±ç•ªå·ã¯å¿…é ˆã§ã™ã€‚', 'error');
                return;
            }

            // å–¶æ¥­æ™‚é–“å†…ã«åã¾ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            const [dateStr, timeStr] = dateTime.split(' ');
            const reservationDate = new Date(dateStr);
            const dayOfWeek = reservationDate.getDay();
            const newDuration = parseInt(duration);
            const defaultInterval = 10; // æ–°è¦äºˆç´„ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆé–“éš”
            
            const validation = validateReservationTimeWithinBusinessHours({
                time: timeStr,
                start_time: dateTime,
                duration: newDuration
            }, newDuration, defaultInterval);
            
            if (!validation.valid) {
                showMessage(validation.message, 'error');
                return;
            }
            
            // é‡è¤‡ãƒã‚§ãƒƒã‚¯
            const overlapValidation = validateReservationOverlap({
                time: timeStr,
                start_time: dateTime,
                duration: newDuration
            }, newDuration, defaultInterval);
            
            if (!overlapValidation.valid) {
                showMessage(overlapValidation.message, 'error');
                return;
            }

            // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã«é€ä¿¡ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚’æº–å‚™
            const bookingData = {
                reservation: {
                    start_time: dateTime,
                    course: `${duration}åˆ†`,
                    name: customerName,
                    note: bookingNote,
                    status: bookingStatus,
                    user_attributes: {
                        name: customerName,
                        phone_number: customerPhone,
                        email: customerEmail
                    }
                }
            };

            // CSRFãƒˆãƒ¼ã‚¯ãƒ³ã‚’å–å¾—
  const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');
            console.log('CSRF Token:', csrfToken);
            console.log('Sending booking data:', bookingData);

            // ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ã§é‡è¤‡ãƒã‚§ãƒƒã‚¯
            if (!isEditingReservation && checkForOverlap(dateTime, duration)) {
                showMessage('ã“ã®æ™‚é–“å¸¯ã«ã¯æ—¢ã«äºˆç´„ãŒã‚ã‚Šã¾ã™ã€‚åˆ¥ã®æ™‚é–“ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚', 'error');
                return;
            }

            // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã«é€ä¿¡ï¼ˆç·¨é›†ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã¯æ›´æ–°ã€æ–°è¦ã®å ´åˆã¯ä½œæˆï¼‰
            const url = isEditingReservation ? 
                `/admin/reservations/${reservationToEdit.id}/update_booking` : 
                '/admin/reservations/create_booking';
            const method = isEditingReservation ? 'PATCH' : 'POST';
            
            fetch(url, {
                method: method,
    headers: {
      'Content-Type': 'application/json',
      'X-CSRF-Token': csrfToken
    },
                body: JSON.stringify(bookingData)
  })
  .then(response => {
                console.log('Response status:', response.status);
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return response.json();
  })
  .then(data => {
    if (data.success) {
                    // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‹ã‚‰è¿”ã•ã‚ŒãŸäºˆç´„ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨
                    const reservationData = data.reservation;
                    
                    if (isEditingReservation) {
                        // ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ï¼šæ—¢å­˜ã®äºˆç´„ã‚’æ›´æ–°
                        const updatedReservation = {
                            id: reservationData.id,
                            userId: reservationData.user_id || reservationData.user?.id,
                            time: reservationData.start_time.split('T')[1].substring(0, 5), // HH:MMå½¢å¼ã«å¤‰æ›
                            duration: extractDurationFromCourse(reservationData.course),
                            customer: reservationData.name || reservationData.user?.name || 'æœªè¨­å®š',
                            phone: reservationData.user?.phone_number || '',
                            email: reservationData.user?.email || '',
                            note: reservationData.note || '',
                            status: reservationData.status,
                            createdAt: reservationData.created_at,
                            updatedAt: reservationData.updated_at,
                            effective_interval_minutes: reservationData.effective_interval_minutes ?? 10
                        };
                        
                        // æ—¢å­˜ã®äºˆç´„ã‚’æ›´æ–°
                        // å¤ã„æ—¥ä»˜ã‚­ãƒ¼ã‚’ç‰¹å®šï¼ˆreservationsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰è©²å½“ã™ã‚‹æ—¥ä»˜ã‚­ãƒ¼ã‚’æ¢ã™ï¼‰
                        let oldDateKey = null;
                        for (const dateKey of Object.keys(reservations)) {
                            const dayReservations = reservations[dateKey];
                            const foundReservation = dayReservations.find(r => r.id === reservationToEdit.id);
                            if (foundReservation) {
                                oldDateKey = dateKey;
                                break;
                            }
                        }
                        
                        const newDateKey = formatDateKey(new Date(reservationData.start_time));
                        
                        // å¤ã„æ—¥ä»˜ã‹ã‚‰å‰Šé™¤
                        if (oldDateKey && reservations[oldDateKey]) {
                            reservations[oldDateKey] = reservations[oldDateKey].filter(r => r.id !== reservationToEdit.id);
                            if (reservations[oldDateKey].length === 0) {
                                delete reservations[oldDateKey];
                            }
                        }
                        
                        // æ–°ã—ã„æ—¥ä»˜ã«è¿½åŠ 
                        if (!reservations[newDateKey]) {
                            reservations[newDateKey] = [];
                        }
                        reservations[newDateKey].push(updatedReservation);
                        
                        
                        
                        // ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
                        isEditingReservation = false;
                        currentReservation = null;
                        reservationToEdit = null;
                        
                        showMessage('äºˆç´„ãŒæ›´æ–°ã•ã‚Œã¾ã—ãŸã€‚', 'success');
                    } else {
                        // æ–°è¦ä½œæˆãƒ¢ãƒ¼ãƒ‰ï¼šæ–°ã—ã„äºˆç´„ã‚’è¿½åŠ 
                        const reservation = {
                            id: reservationData.id,
                            userId: reservationData.user_id || reservationData.user?.id,
                            time: reservationData.start_time.split('T')[1].substring(0, 5), // HH:MMå½¢å¼ã«å¤‰æ›
                            duration: extractDurationFromCourse(reservationData.course),
                            customer: reservationData.name || reservationData.user?.name || 'æœªè¨­å®š',
                            phone: reservationData.user?.phone_number || '',
                            email: reservationData.user?.email || '',
                            note: reservationData.note || '',
                            status: reservationData.status,
                            createdAt: reservationData.created_at,
                            updatedAt: reservationData.updated_at,
                            effective_interval_minutes: reservationData.effective_interval_minutes ?? 10
                        };

                        const dateKey = formatDateKey(new Date(reservationData.start_time));
                        if (!reservations[dateKey]) {
                            reservations[dateKey] = [];
                        }
                        reservations[dateKey].push(reservation);

                        
                        
                        showMessage('äºˆç´„ãŒä½œæˆã•ã‚Œã¾ã—ãŸã€‚', 'success');
                    }

                    // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚’å†æç”»
                    generateTimeSlots();

                    closeBookingModal();
    } else {
                    showMessage(`äºˆç´„ã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ: ${data.message}`, 'error');
    }
  })
  .catch(error => {
                console.error('Error creating booking:', error);
                showMessage('äºˆç´„ã®ä½œæˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚', 'error');
            });
        }

        // äºˆç´„è©³ç´°ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
        function openReservationDetailModal(reservation) {

            // æœ€æ–°ã®äºˆç´„ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            let latestReservation = null;
            for (const dateKey of Object.keys(reservations)) {
                const dayReservations = reservations[dateKey];
                const foundReservation = dayReservations.find(r => r.id === reservation.id);
                if (foundReservation) {
                    latestReservation = foundReservation;
                    break;
                }
            }
            
            // æœ€æ–°ã®ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯å…ƒã®ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨
            if (!latestReservation) {
                latestReservation = reservation;
            }
            
            console.log('ğŸ” Opening modal with reservation data:', {
                original: {
                    time: reservation.time,
                    date: reservation.date,
                    dateKey: reservation.dateKey,
                    start_time: reservation.start_time,
                    createdAt: reservation.createdAt,
                    updatedAt: reservation.updatedAt
                },
                latest: {
                    time: latestReservation.time,
                    createdAt: latestReservation.createdAt,
                    updatedAt: latestReservation.updatedAt,
                    date: latestReservation.date,
                    dateKey: latestReservation.dateKey,
                    start_time: latestReservation.start_time,
                    fullReservationObject: latestReservation
                }
            });
            
            // äºˆç´„ãƒ‡ãƒ¼ã‚¿ã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯
            if (!validateReservationData(latestReservation)) {
                showMessage('äºˆç´„ãƒ‡ãƒ¼ã‚¿ãŒç„¡åŠ¹ã§ã™', 'error');
                return;
            }
            
            // ç¾åœ¨ã®äºˆç´„ã‚’ä¿å­˜ï¼ˆæœ€æ–°ã®ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨ï¼‰
            currentReservation = latestReservation;
            
            // äºˆç´„ã®å®Ÿéš›ã®æ—¥ä»˜ã‚’ç‰¹å®š
            let actualDate = '';
            for (const dateKey of Object.keys(reservations)) {
                const dayReservations = reservations[dateKey];
                const foundReservation = dayReservations.find(r => r.id === latestReservation.id);
                if (foundReservation) {
                    const [year, month, day] = dateKey.split('-').map(Number);
                    const date = new Date(year, month - 1, day);
                    actualDate = date.toLocaleDateString('ja-JP', { 
                        year: 'numeric', 
                        month: 'long', 
                        day: 'numeric',
                        weekday: 'long'
                    });
                    break;
                }
            }
            
            // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã«å¿œã˜ãŸè‰²ã¨ã‚¢ã‚¤ã‚³ãƒ³ã‚’è¨­å®š
            const statusConfig = {
                'tentative': { color: 'warning', icon: 'â³', text: 'ä»®äºˆç´„' },
                'confirmed': { color: 'success', icon: 'âœ“', text: 'ç¢ºèªæ¸ˆã¿' },
                'completed': { color: 'info', icon: 'âœ…', text: 'å®Œäº†' }
            };
            
            const status = statusConfig[latestReservation.status] || { color: 'secondary', icon: 'â“', text: latestReservation.status };
            
            // Create customer name HTML
            const customerNameHTML = latestReservation.userId ? 
                `<a href="/admin/users/${latestReservation.userId}" target="_blank" class="customer-link">${latestReservation.customer}</a>` : 
                latestReservation.customer;
            
            const modalContent = document.getElementById('reservationDetailContent');
            modalContent.innerHTML = `
                <div class="reservation-detail-container">
                    <!-- ç·¨é›†ãƒ•ã‚©ãƒ¼ãƒ  -->
                    <form id="reservationEditForm" onsubmit="saveReservationChanges(event)">
                    <!-- ãƒ˜ãƒƒãƒ€ãƒ¼æƒ…å ± -->
                    <div class="reservation-header">
                        <div class="header-top">
                            <div class="customer-name-header">
                                <span class="customer-name-large">${latestReservation.customer}</span>
                                    <button type="button" class="btn btn-sm btn-outline-light change-user-btn" onclick="openUserSelectionModal()">
                                        <i class="fas fa-user-edit"></i> å¤‰æ›´
                                    </button>
                            </div>
                            <div class="reservation-status status-${status.color}">
                                    <select id="edit-status" class="form-select status-select" onchange="updateCalendarOnStatusChange()">
                                        <option value="tentative" ${latestReservation.status === 'tentative' ? 'selected' : ''}>ä»®äºˆç´„</option>
                                        <option value="confirmed" ${latestReservation.status === 'confirmed' ? 'selected' : ''}>ç¢ºèªæ¸ˆã¿</option>
                                        <option value="completed" ${latestReservation.status === 'completed' ? 'selected' : ''}>å®Œäº†</option>
                                    </select>
                            </div>
                        </div>
                        <div class="header-bottom">
                            <div class="header-detail-item">
                                <span class="header-label">äºˆç´„æ—¥æ™‚</span>
                                <span class="header-value">${actualDate || 'æ—¥ä»˜ä¸æ˜'} ${latestReservation.time}</span>
                            </div>
                            <div class="header-detail-item">
                                <span class="header-label">ã‚³ãƒ¼ã‚¹</span>
                                    <select id="edit-course" class="form-select course-select" onchange="updateCalendarOnCourseChange()">
                                        <option value="40åˆ†" ${latestReservation.duration === 40 ? 'selected' : ''}>40åˆ†</option>
                                        <option value="60åˆ†" ${latestReservation.duration === 60 ? 'selected' : ''}>60åˆ†</option>
                                        <option value="80åˆ†" ${latestReservation.duration === 80 ? 'selected' : ''}>80åˆ†</option>
                                    </select>
                                </div>
                                <div class="header-detail-item">
                                    <span class="header-label">æº–å‚™æ™‚é–“</span>
                                    <span class="header-value">
                                        <select id="edit-interval" class="interval-select" onchange="updateIntervalOnChange()">
                                            <option value="0" ${(latestReservation.effective_interval_minutes ?? 10) === 0 ? 'selected' : ''}>0åˆ†</option>
                                            <option value="5" ${(latestReservation.effective_interval_minutes ?? 10) === 5 ? 'selected' : ''}>5åˆ†</option>
                                            <option value="10" ${(latestReservation.effective_interval_minutes ?? 10) === 10 ? 'selected' : ''}>10åˆ†</option>
                                            <option value="15" ${(latestReservation.effective_interval_minutes ?? 10) === 15 ? 'selected' : ''}>15åˆ†</option>
                                            <option value="20" ${(latestReservation.effective_interval_minutes ?? 10) === 20 ? 'selected' : ''}>20åˆ†</option>
                                            <option value="30" ${(latestReservation.effective_interval_minutes ?? 10) === 30 ? 'selected' : ''}>30åˆ†</option>
                                        </select>
                                    </span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- ãŠå®¢æ§˜åŸºæœ¬æƒ…å ± -->
                    <div class="customer-basic-info">
                        <div class="customer-phone">
                            ${latestReservation.phone || 'é›»è©±ç•ªå·æœªè¨˜å…¥'}
                        </div>
                        <div class="customer-email">
                            ${latestReservation.email || 'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹æœªè¨˜å…¥'}
                        </div>
                    </div>
                    
                        <!-- ãƒ¡ãƒ¢ -->
                        <div class="notes-section">
                            <div class="section-title">ãƒ¡ãƒ¢</div>
                            <textarea id="edit-note" class="form-control" rows="3" placeholder="ãƒ¡ãƒ¢ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„">${latestReservation.note || ''}</textarea>
                        </div>
                    </form>
                    
                    <!-- å›æ•°åˆ¸ã¨åˆ©ç”¨å±¥æ­´ã‚’æ¨ªä¸¦ã³ã§è¡¨ç¤º -->
                    <div class="tickets-history-container">
                    <!-- å›æ•°åˆ¸ -->
                    <div class="tickets-section">
                        <div class="section-title">å›æ•°åˆ¸</div>
                        <div class="tickets-content" id="tickets-content">
                            <div class="loading">èª­ã¿è¾¼ã¿ä¸­...</div>
                        </div>
                    </div>
                    
                        <!-- åˆ©ç”¨å±¥æ­´ -->
                    <div class="reservation-history-section">
                            <div class="section-title">åˆ©ç”¨å±¥æ­´</div>
                        <div class="history-content" id="history-content">
                            <div class="loading">èª­ã¿è¾¼ã¿ä¸­...</div>
                        </div>
                        </div>
                    </div>
                    
                    <!-- ã‚·ã‚¹ãƒ†ãƒ æƒ…å ± -->
                    <div class="system-info-section">
                        <div class="detail-item">
                            <span class="detail-label">ä½œæˆæ—¥æ™‚</span>
                            <span class="detail-value">${new Date(latestReservation.createdAt).toLocaleString('ja-JP')}</span>
                        </div>
                        ${(function() {
                            console.log('ğŸ” Checking timestamps for å¤‰æ›´æ—¥æ™‚:', {
                                createdAt: latestReservation.createdAt,
                                updatedAt: latestReservation.updatedAt,
                                created_at: latestReservation.created_at,
                                updated_at: latestReservation.updated_at,
                                createdTime: new Date(latestReservation.createdAt).getTime(),
                                updatedTime: latestReservation.updatedAt ? new Date(latestReservation.updatedAt).getTime() : 'null',
                                isDifferent: latestReservation.updatedAt && new Date(latestReservation.updatedAt).getTime() !== new Date(latestReservation.createdAt).getTime(),
                                allFields: Object.keys(latestReservation)
                            });
                            
                            // Check multiple possible timestamp field combinations
                            const createdTimestamp = latestReservation.createdAt || latestReservation.created_at;
                            const updatedTimestamp = latestReservation.updatedAt || latestReservation.updated_at;
                            
                            console.log('ğŸ” Final timestamp check:', {
                                createdTimestamp,
                                updatedTimestamp,
                                hasDifferentTimestamps: updatedTimestamp && createdTimestamp && new Date(updatedTimestamp).getTime() !== new Date(createdTimestamp).getTime()
                            });
                            
                            if (updatedTimestamp && createdTimestamp && new Date(updatedTimestamp).getTime() !== new Date(createdTimestamp).getTime()) {
                                return `
                        <div class="detail-item">
                            <span class="detail-label">å¤‰æ›´æ—¥æ™‚</span>
                            <span class="detail-value">${new Date(updatedTimestamp).toLocaleString('ja-JP')}</span>
                        </div>`;
                            } else {
                                return '';
                            }
                        })()}
                    </div>
                </div>
            `;
            document.getElementById('reservationDetailModal').style.display = 'block';
            
            // Add click event listener to customer link
            setTimeout(() => {
                const customerLink = document.querySelector('.customer-link');
                if (customerLink) {
        
                    customerLink.addEventListener('click', function(e) {
            
                        e.preventDefault();
                        window.open(this.href, '_blank');
                    });
                } else {
                    console.log('âŒ Customer link not found');
                }
            }, 100);
            
            // ãƒã‚±ãƒƒãƒˆã¨äºˆç´„å±¥æ­´ã‚’èª­ã¿è¾¼ã¿ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼IDãƒ™ãƒ¼ã‚¹ï¼‰
            if (latestReservation.userId) {
                loadTicketsAndHistoryForUser(latestReservation.userId);
            } else {
            loadTicketsAndHistory(latestReservation);
            }
            
            // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒªã‚¹ãƒˆã¯æ¤œç´¢æ™‚ã«å‹•çš„ã«èª­ã¿è¾¼ã¿
        }

        // äºˆç´„è©³ç´°ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
        function closeReservationDetailModal() {
            document.getElementById('reservationDetailModal').style.display = 'none';
            currentReservation = null; // ç¾åœ¨ã®äºˆç´„ã‚’ãƒªã‚»ãƒƒãƒˆ
        }

        // ãƒ¢ãƒ¼ãƒ€ãƒ«å¤–ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹æ©Ÿèƒ½
        function setupModalClickOutside() {
            const modal = document.getElementById('reservationDetailModal');
            if (modal) {
                modal.addEventListener('click', function(event) {
                    // ãƒ¢ãƒ¼ãƒ€ãƒ«èƒŒæ™¯ï¼ˆ.modalï¼‰ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸå ´åˆã®ã¿é–‰ã˜ã‚‹
                    if (event.target === modal) {
                        closeReservationDetailModal();
                    }
                });
            }
        }

        // ãƒã‚±ãƒƒãƒˆã¨åˆ©ç”¨å±¥æ­´ã‚’èª­ã¿è¾¼ã¿
        function loadTicketsAndHistory(reservation) {
            // ãƒã‚±ãƒƒãƒˆæƒ…å ±ã‚’èª­ã¿è¾¼ã¿
            loadTickets(reservation);
            // åˆ©ç”¨å±¥æ­´ã‚’èª­ã¿è¾¼ã¿
            loadReservationHistory(reservation);
        }

        // ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã§ãƒã‚±ãƒƒãƒˆã¨åˆ©ç”¨å±¥æ­´ã‚’èª­ã¿è¾¼ã¿
        function loadTicketsAndHistoryForUser(userId) {
            // ãƒã‚±ãƒƒãƒˆæƒ…å ±ã‚’èª­ã¿è¾¼ã¿
            loadTicketsForUser(userId);
            // åˆ©ç”¨å±¥æ­´ã‚’èª­ã¿è¾¼ã¿
            loadReservationHistoryForUser(userId);
        }

        // ãƒã‚±ãƒƒãƒˆæƒ…å ±ã‚’èª­ã¿è¾¼ã¿
        function loadTickets(reservation) {

            
            const ticketsContent = document.getElementById('tickets-content');
            if (!ticketsContent) {
                console.error('âŒ Tickets content element not found');
                return;
            }

            // äºˆç´„ãƒ‡ãƒ¼ã‚¿ã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯
            if (!validateReservationData(reservation)) {
                ticketsContent.innerHTML = '<div class="no-data">äºˆç´„ãƒ‡ãƒ¼ã‚¿ãŒç„¡åŠ¹ã§ã™</div>';
                return;
            }

            // ãƒ¦ãƒ¼ã‚¶ãƒ¼IDãŒã‚ã‚‹å ´åˆã¯ãƒã‚±ãƒƒãƒˆæƒ…å ±ã‚’å–å¾—
            if (reservation.userId) {
    
    
                
                // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã‚’è¿½åŠ 
                fetch(`/admin/reservations/${reservation.id}/tickets`, {
                    headers: {
                        'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]')?.getAttribute('content')
                    }
                })
    .then(response => {
                        console.log('ğŸ“¡ Response status:', response.status);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
      return response.json();
    })
                    .then(data => {
            
                        if (data.success) {
                            displayTickets(data.tickets);
                        } else {
                            console.warn('âš ï¸ No tickets data:', data.message);
                            ticketsContent.innerHTML = '<div class="no-data">ãƒã‚±ãƒƒãƒˆæƒ…å ±ãŒã‚ã‚Šã¾ã›ã‚“</div>';
                        }
    })
    .catch(error => {
                        console.error('âŒ Error loading tickets:', error);
                        console.error('âŒ Error details:', {
                            message: error.message,
                            stack: error.stack,
                            reservationId: reservation.id,
                            userId: reservation.userId
                        });
                        ticketsContent.innerHTML = '<div class="no-data">ãƒã‚±ãƒƒãƒˆæƒ…å ±ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ</div>';
                    });
            } else {
                console.warn('âš ï¸ No user ID found for reservation');
                ticketsContent.innerHTML = '<div class="no-data">ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ãŒã‚ã‚Šã¾ã›ã‚“</div>';
            }
        }

        // ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã§ãƒã‚±ãƒƒãƒˆæƒ…å ±ã‚’èª­ã¿è¾¼ã¿
        function loadTicketsForUser(userId) {
            const ticketsContent = document.getElementById('tickets-content');
            if (!ticketsContent) {
                console.error('âŒ Tickets content element not found');
                return;
            }

            // ãƒ¦ãƒ¼ã‚¶ãƒ¼IDãŒã‚ã‚‹å ´åˆã¯ãƒã‚±ãƒƒãƒˆæƒ…å ±ã‚’å–å¾—
            if (userId) {
                fetch(`/admin/users/${userId}/tickets.json`)
                    .then(response => {
                        console.log('ğŸ“¡ User tickets response status:', response.status);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(tickets => {
                        console.log('ğŸ“¡ User tickets data:', tickets);
                        displayUserTickets(tickets);
                    })
                    .catch(error => {
                        console.error('âŒ Error loading user tickets:', error);
                        ticketsContent.innerHTML = '<div class="no-data">ãƒã‚±ãƒƒãƒˆæƒ…å ±ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ</div>';
                    });
            } else {
                console.warn('âš ï¸ No user ID provided');
                ticketsContent.innerHTML = '<div class="no-data">ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ãŒã‚ã‚Šã¾ã›ã‚“</div>';
            }
        }

        // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒã‚±ãƒƒãƒˆæƒ…å ±ã‚’è¡¨ç¤º
        function displayUserTickets(tickets) {
            const ticketsContent = document.getElementById('tickets-content');
            if (!ticketsContent) {
                console.error('âŒ Tickets content element not found in displayUserTickets');
                return;
            }

            if (!tickets || tickets.length === 0) {
                console.log('â„¹ï¸ No user tickets to display');
                ticketsContent.innerHTML = '<div class="no-data">ãƒã‚±ãƒƒãƒˆãŒã‚ã‚Šã¾ã›ã‚“</div>';
                return;
            }

            // Sort tickets by newest first (assuming created_at or issued_at field exists)
            const sortedTickets = tickets.sort((a, b) => {
                const dateA = new Date(a.created_at || a.issued_at || a.expires_at || 0);
                const dateB = new Date(b.created_at || b.issued_at || b.expires_at || 0);
                return dateB - dateA; // Newest first
            });

            // Limit to 5 tickets like the original
            const limitedTickets = sortedTickets.slice(0, 5);

            const ticketsHtml = limitedTickets.map(ticket => {
                const isExpired = ticket.remaining === 0 || new Date(ticket.expires_at) < new Date();
                const expiryDate = ticket.expires_at ? new Date(ticket.expires_at).toLocaleDateString('ja-JP') : 'ç„¡æœŸé™';
                
                return `
                    <div class="ticket-item ${isExpired ? 'expired' : ''}">
                        <div class="ticket-checkbox">â–¡</div>
                        <div class="ticket-info">
                            <div class="ticket-name">${ticket.name}</div>
                            <div class="ticket-details">æ®‹${ticket.remaining}æš / æœ‰åŠ¹æœŸé™:${expiryDate}</div>
                        </div>
                    </div>
                `;
            }).join('');

            ticketsContent.innerHTML = ticketsHtml;
        }

        // ãƒã‚±ãƒƒãƒˆæƒ…å ±ã‚’è¡¨ç¤º
        function displayTickets(tickets) {

            
            const ticketsContent = document.getElementById('tickets-content');
            if (!ticketsContent) {
                console.error('âŒ Tickets content element not found in displayTickets');
                return;
            }

            if (!tickets || tickets.length === 0) {
                console.log('â„¹ï¸ No tickets to display');
                ticketsContent.innerHTML = '<div class="no-data">ãƒã‚±ãƒƒãƒˆãŒã‚ã‚Šã¾ã›ã‚“</div>';
                return;
            }


            
            const ticketsHtml = tickets.map(ticket => {
                const isExpired = ticket.remaining_count === 0 || new Date(ticket.expiry_date) < new Date();
                const expiryDate = new Date(ticket.expiry_date).toLocaleDateString('ja-JP');
                

                
                return `
                    <div class="ticket-item ${isExpired ? 'expired' : ''}">
                        <div class="ticket-checkbox">â–¡</div>
                        <div class="ticket-info">
                            <div class="ticket-name">${ticket.ticket_template_name}</div>
                            <div class="ticket-details">æ®‹${ticket.remaining_count}${ticket.unit_type} / æœ‰åŠ¹æœŸé™:${expiryDate}</div>
          </div>
        </div>
      `;
            }).join('');


            ticketsContent.innerHTML = ticketsHtml;
        }

        // ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã§åˆ©ç”¨å±¥æ­´ã‚’èª­ã¿è¾¼ã¿
        function loadReservationHistoryForUser(userId) {
            const historyContent = document.getElementById('history-content');
            if (!historyContent) return;

            // ãƒ¦ãƒ¼ã‚¶ãƒ¼IDãŒã‚ã‚‹å ´åˆã¯åˆ©ç”¨å±¥æ­´ã‚’å–å¾—
            if (userId) {
                fetch(`/admin/users/${userId}/history.json`)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        console.log('ğŸ“¡ User history data:', data);
                        if (data.success) {
                            displayReservationHistory(data.usages);
                        } else {
                            historyContent.innerHTML = '<div class="no-data">åˆ©ç”¨å±¥æ­´ãŒã‚ã‚Šã¾ã›ã‚“</div>';
                        }
                    })
                    .catch(error => {
                        console.error('âŒ Error loading user history:', error);
                        historyContent.innerHTML = '<div class="no-data">åˆ©ç”¨å±¥æ­´ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ</div>';
                    });
            } else {
                historyContent.innerHTML = '<div class="no-data">ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ãŒã‚ã‚Šã¾ã›ã‚“</div>';
            }
        }

        // åˆ©ç”¨å±¥æ­´ã‚’èª­ã¿è¾¼ã¿
        function loadReservationHistory(reservation) {

            
            const historyContent = document.getElementById('history-content');
            if (!historyContent) return;

            // äºˆç´„ãƒ‡ãƒ¼ã‚¿ã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯
            if (!validateReservationData(reservation)) {
                historyContent.innerHTML = '<div class="no-data">äºˆç´„ãƒ‡ãƒ¼ã‚¿ãŒç„¡åŠ¹ã§ã™</div>';
                return;
            }

            // ãƒ¦ãƒ¼ã‚¶ãƒ¼IDãŒã‚ã‚‹å ´åˆã¯åˆ©ç”¨å±¥æ­´ã‚’å–å¾—
            if (reservation.userId) {
                fetch(`/admin/reservations/${reservation.id}/history`, {
                    headers: {
                        'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]')?.getAttribute('content')
                    }
                })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data.success) {
                            displayReservationHistory(data.usages);
                        } else {
                            historyContent.innerHTML = '<div class="no-data">åˆ©ç”¨å±¥æ­´ãŒã‚ã‚Šã¾ã›ã‚“</div>';
                        }
                    })
                    .catch(error => {
                        console.error('âŒ Error loading usage history:', error);
                        console.error('âŒ Error details:', {
                            message: error.message,
                            stack: error.stack,
                            reservationId: reservation.id,
                            userId: reservation.userId
                        });
                        historyContent.innerHTML = '<div class="no-data">åˆ©ç”¨å±¥æ­´ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ</div>';
                    });
            } else {
                historyContent.innerHTML = '<div class="no-data">ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ãŒã‚ã‚Šã¾ã›ã‚“</div>';
            }
        }

        // åˆ©ç”¨å±¥æ­´ã‚’è¡¨ç¤º
        function displayReservationHistory(usages) {
            const historyContent = document.getElementById('history-content');
            if (!historyContent) return;

            if (!usages || usages.length === 0) {
                historyContent.innerHTML = '<div class="no-data">åˆ©ç”¨å±¥æ­´ãŒã‚ã‚Šã¾ã›ã‚“</div>';
                return;
            }

            const historyHtml = usages.map(usage => {
                // Backend returns date and time as separate fields
                const displayDate = usage.date || 'Unknown Date';
                const displayTime = usage.time || 'Unknown Time';
                const displayName = usage.course || usage.ticket_name || 'Unknown';
                const typeIcon = usage.type === 'reservation' ? 'ğŸ“…' : 'ğŸ«';
                const typeText = usage.type === 'reservation' ? 'äºˆç´„' : 'ãƒã‚±ãƒƒãƒˆä½¿ç”¨';
                
                return `
                    <div class="history-item-compact">
                        <span class="history-icon-small">${typeIcon}</span>
                        <span class="history-content-compact">
                            <strong>${displayName}</strong> - ${displayDate} ${displayTime} (${typeText})
                        </span>
                    </div>
                `;
            }).join('');

            historyContent.innerHTML = historyHtml;
        }



        // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚¢ã‚¤ã‚³ãƒ³ã‚’å–å¾—
        function getStatusIcon(status) {
            const statusIcons = {
                'confirmed': 'âœ…',
                'tentative': 'â³',
                'cancelled': 'âŒ',
                'completed': 'âœ…',
                'no_show': 'âš ï¸'
            };
            return statusIcons[status] || 'â“';
        }



        // äºˆç´„ã‚’ç·¨é›†
        function editReservation() {
            if (!currentReservation) {
                showMessage('ç·¨é›†ã™ã‚‹äºˆç´„ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚', 'error');
                return;
            }
            
            console.log('âœï¸ Editing reservation:', currentReservation);
            
            // ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ãƒ•ãƒ©ã‚°ã‚’è¨­å®š
            isEditingReservation = true;
            
            // äºˆç´„ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ï¼ˆãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹å‰ã«ï¼‰
            reservationToEdit = { ...currentReservation };
            
            // äºˆç´„ã®å®Ÿéš›ã®æ—¥ä»˜ã‚’ç‰¹å®šï¼ˆreservationsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰è©²å½“ã™ã‚‹æ—¥ä»˜ã‚­ãƒ¼ã‚’æ¢ã™ï¼‰
            let actualReservationDate = null;
            let foundDateKey = null;
            
            // ã™ã¹ã¦ã®æ—¥ä»˜ã‚­ãƒ¼ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦è©²å½“ã™ã‚‹äºˆç´„ã‚’æ¢ã™
            for (const dateKey of Object.keys(reservations)) {
                const dayReservations = reservations[dateKey];
                const foundReservation = dayReservations.find(r => r.id === currentReservation.id);
                
                if (foundReservation) {
                    foundDateKey = dateKey;
                    // æ—¥ä»˜ã‚­ãƒ¼ã‹ã‚‰å®Ÿéš›ã®æ—¥ä»˜ã‚’è¨ˆç®—
                    const [year, month, day] = dateKey.split('-').map(Number);
                    const [hours, minutes] = currentReservation.time.split(':').map(Number);
                    actualReservationDate = new Date(year, month - 1, day, hours, minutes, 0, 0);
                    break;
                }
            }
            
            // è¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯createdAtã‹ã‚‰è¨ˆç®—ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
            if (!actualReservationDate) {
                console.warn('âš ï¸ Could not find reservation in date keys, using createdAt as fallback');
                actualReservationDate = new Date(reservationToEdit.createdAt);
                const [hours, minutes] = reservationToEdit.time.split(':').map(Number);
                actualReservationDate.setHours(hours, minutes, 0, 0);
            }
            
            console.log('ğŸ“… Actual reservation date:', actualReservationDate, 'from date key:', foundDateKey);
            
            // äºˆç´„è©³ç´°ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
            closeReservationDetailModal();
            
            // äºˆç´„ç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
            openBookingModal(actualReservationDate, reservationToEdit.time);
            
            // ãƒ•ã‚©ãƒ¼ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æ—¢å­˜ã®äºˆç´„ãƒ‡ãƒ¼ã‚¿ã§åŸ‹ã‚ã‚‹ï¼ˆãƒ¢ãƒ¼ãƒ€ãƒ«ãŒé–‹ã„ãŸå¾Œã«å®Ÿè¡Œï¼‰
            setTimeout(() => {
                const customerNameField = document.getElementById('customerName');
                const customerPhoneField = document.getElementById('customerPhone');
                const customerEmailField = document.getElementById('customerEmail');
                const bookingDurationField = document.getElementById('bookingDuration');
                const bookingNoteField = document.getElementById('bookingNote');
                const bookingStatusField = document.getElementById('bookingStatus');
                
                if (customerNameField) customerNameField.value = reservationToEdit.customer;
                if (customerPhoneField) customerPhoneField.value = reservationToEdit.phone;
                if (customerEmailField) customerEmailField.value = reservationToEdit.email;
                if (bookingDurationField) bookingDurationField.value = reservationToEdit.duration;
                if (bookingNoteField) bookingNoteField.value = reservationToEdit.note;
                if (bookingStatusField) bookingStatusField.value = reservationToEdit.status;
            }, 200);
            
            showMessage('äºˆç´„ã‚’ç·¨é›†ã§ãã¾ã™ã€‚', 'info');
        }

        // äºˆç´„ã‚’å‰Šé™¤
        function deleteReservation() {
            if (!currentReservation) {
                showMessage('å‰Šé™¤ã™ã‚‹äºˆç´„ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚', 'error');
    return;
  }
  
            const confirmed = confirm(`ã“ã®äºˆç´„ã‚’å®Œå…¨ã«å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ\n\nãŠå®¢æ§˜: ${currentReservation.customer}\næ—¥æ™‚: ${currentReservation.time}\nã‚³ãƒ¼ã‚¹: ${currentReservation.duration}åˆ†\n\nã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚`);
            
            if (!confirmed) {
                return;
            }
            
            console.log('ğŸ—‘ï¸ Deleting reservation:', currentReservation);
            
            // è¦–è¦šçš„ãªãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯: å‰Šé™¤ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é–‹å§‹
            const reservationBlocks = document.querySelectorAll('.reservation-block');
            reservationBlocks.forEach(block => {
                if (block.textContent.includes(currentReservation.customer) && 
                    block.textContent.includes(currentReservation.time)) {
                    block.classList.add('deleting');
                }
            });
            
            // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã«å‰Šé™¤ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡
            fetch('/admin/reservations/delete_reservation', {
    method: 'DELETE',
    headers: {
      'Content-Type': 'application/json',
                    'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]')?.getAttribute('content')
    },
                body: JSON.stringify({
                    reservation_id: currentReservation.id
  })
  })
            .then(response => response.json())
  .then(data => {
    if (data.success) {
                    console.log('âœ… Reservation deleted successfully');
                    
                    // ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰äºˆç´„ã‚’å‰Šé™¤
                    // äºˆç´„ã®å®Ÿéš›ã®æ—¥ä»˜ã‚’ç‰¹å®šã™ã‚‹ãŸã‚ã«ã€ã™ã¹ã¦ã®æ—¥ä»˜ã‚­ãƒ¼ã‚’ãƒã‚§ãƒƒã‚¯
                    console.log('ğŸ—‘ï¸ Searching for reservation ID:', currentReservation.id, 'in all date keys');
                    console.log('ğŸ—‘ï¸ Available date keys:', Object.keys(reservations));
                    
                    let foundDateKey = null;
                    let foundReservation = null;
                    
                    // ã™ã¹ã¦ã®æ—¥ä»˜ã‚­ãƒ¼ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦è©²å½“ã™ã‚‹äºˆç´„ã‚’æ¢ã™
                    for (const dateKey of Object.keys(reservations)) {
                        const dayReservations = reservations[dateKey];
                        const matchingReservation = dayReservations.find(r => r.id === currentReservation.id);
                        
                        if (matchingReservation) {
                            foundDateKey = dateKey;
                            foundReservation = matchingReservation;
                            console.log(`ğŸ—‘ï¸ Found reservation in date key: ${dateKey}`);
                            break;
                        }
                    }
                    
                    if (foundDateKey && foundReservation) {
                        const beforeCount = reservations[foundDateKey].length;
                        reservations[foundDateKey] = reservations[foundDateKey].filter(r => r.id !== currentReservation.id);
                        const afterCount = reservations[foundDateKey].length;
                        
                        console.log(`ğŸ—‘ï¸ Removed reservation: ${beforeCount} â†’ ${afterCount} reservations for ${foundDateKey}`);
                        
                        if (reservations[foundDateKey].length === 0) {
                            delete reservations[foundDateKey];
                            console.log(`ğŸ—‘ï¸ Deleted empty date key: ${foundDateKey}`);
                        }
  } else {
                        console.warn(`âš ï¸ Reservation ID ${currentReservation.id} not found in any date key`);
                        console.warn(`âš ï¸ Available reservations:`, reservations);
                    }
                    
                    // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚’å†æç”»
                    generateTimeSlots();
      
      // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
                    closeReservationDetailModal();
                    
                    // æˆåŠŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
                    showMessage('äºˆç´„ãŒå‰Šé™¤ã•ã‚Œã¾ã—ãŸã€‚', 'success');
                    
                    // ãƒ‡ãƒãƒƒã‚°: å‰Šé™¤å¾Œã®äºˆç´„ãƒ‡ãƒ¼ã‚¿ã‚’ç¢ºèª
                    console.log('âœ… After deletion - reservations data:', reservations);
    } else {
                    console.error('âŒ Failed to delete reservation:', data.message);
                    showMessage(`äºˆç´„ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ: ${data.message}`, 'error');
    }
  })
  .catch(error => {
                console.error('âŒ Error deleting reservation:', error);
                showMessage('äºˆç´„ã®å‰Šé™¤ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚', 'error');
            });
        }

        // äºˆç´„ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ï¼ˆå‰Šé™¤ï¼‰
        function cancelReservation() {
            if (!currentReservation) {
                showMessage('ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã™ã‚‹äºˆç´„ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚', 'error');
                return;
            }
            
            const confirmed = confirm(`ã“ã®äºˆç´„ã‚’å®Œå…¨ã«å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ\n\nãŠå®¢æ§˜: ${currentReservation.customer}\næ—¥æ™‚: ${currentReservation.time}\nã‚³ãƒ¼ã‚¹: ${currentReservation.duration}åˆ†\n\nã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚`);
            
            if (!confirmed) {
    return;
  }
  

            
            // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã«å‰Šé™¤ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡
            fetch('/admin/reservations/delete_reservation', {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]')?.getAttribute('content')
                },
                body: JSON.stringify({ reservation_id: currentReservation.id })
            })
            .then(response => response.json())
  .then(data => {
    if (data.success) {

                    

                    
                    // ã‚­ãƒ£ãƒ³ã‚»ãƒ«è¡¨ç¤ºã‚¨ãƒªã‚¢ã«è¿½åŠ ï¼ˆå‰Šé™¤å‰ã«äºˆç´„ãƒ‡ãƒ¼ã‚¿ã¨æ—¥ä»˜ã‚’ä¿å­˜ï¼‰
                    const reservationToCancel = { ...currentReservation };
                    
                    // äºˆç´„ã®å®Ÿéš›ã®æ—¥ä»˜ã‚’ç‰¹å®šï¼ˆdateKeyã‹ã‚‰æŠ½å‡ºï¼‰- å‰Šé™¤å‰ã«å®Ÿè¡Œ
                    let actualReservationDate = null;
                    let foundDateKey = null;
                    
                    // ã™ã¹ã¦ã®æ—¥ä»˜ã‚­ãƒ¼ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦è©²å½“ã™ã‚‹äºˆç´„ã‚’æ¢ã™
                    for (const dateKey of Object.keys(reservations)) {
                        const dayReservations = reservations[dateKey];
                        const foundReservation = dayReservations.find(r => r.id === reservationToCancel.id);
                        
                        if (foundReservation) {
                            foundDateKey = dateKey;
                            const [year, month, day] = dateKey.split('-').map(Number);
                            actualReservationDate = new Date(year, month - 1, day);
                            break;
                        }
                    }
                    
                    // è¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯createdAtã‹ã‚‰è¨ˆç®—
                    if (!actualReservationDate) {
                        actualReservationDate = new Date(reservationToCancel.createdAt);
                    }
                    
                    // ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰äºˆç´„ã‚’å‰Šé™¤
                    if (foundDateKey) {
                        const beforeCount = reservations[foundDateKey].length;
                        reservations[foundDateKey] = reservations[foundDateKey].filter(r => r.id !== reservationToCancel.id);
                        const afterCount = reservations[foundDateKey].length;
                        
                        if (reservations[foundDateKey].length === 0) {
                            delete reservations[foundDateKey];
                        }
                    }
                    
                    addToCancellationDisplay({
                        ...reservationToCancel,
                        start_time: actualReservationDate.toISOString()
                    });
                    
                    // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚’å†æç”»
                    generateTimeSlots();
                    
                    // ã‚­ãƒ£ãƒ³ã‚»ãƒ«è¡¨ç¤ºã‚’æ›´æ–°ï¼ˆDOMæ“ä½œå¾Œã«ç¢ºå®Ÿã«æ›´æ–°ï¼‰
                    setTimeout(() => {
                        updateCancellationDisplay();
                    }, 50);
                    
                    // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
                    closeReservationDetailModal();
                    
                    showMessage('äºˆç´„ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ï¼ˆå‰Šé™¤ï¼‰ã•ã‚Œã¾ã—ãŸã€‚', 'success');
                } else {
                    console.error('âŒ Failed to cancel reservation:', data.message);
                    showMessage(`äºˆç´„ã®ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã«å¤±æ•—ã—ã¾ã—ãŸ: ${data.message}`, 'error');
    }
  })
  .catch(error => {
                console.error('âŒ Error cancelling reservation:', error);
                showMessage('äºˆç´„ã®ã‚­ãƒ£ãƒ³ã‚»ãƒ«ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚', 'error');
            });
        }

        // ã‚³ãƒ¼ã‚¹ã‹ã‚‰æ™‚é–“ã‚’æŠ½å‡ºã™ã‚‹é–¢æ•°
        function extractDurationFromCourse(courseString) {
            if (!courseString) return 60;
            
            const match = courseString.match(/(\d+)åˆ†/);
            return match ? parseInt(match[1]) : 60;
        }

        // é‡è¤‡ãƒã‚§ãƒƒã‚¯é–¢æ•°
        function checkForOverlap(dateTime, duration) {
            const startTime = new Date(dateTime);
            const endTime = new Date(startTime.getTime() + parseInt(duration) * 60 * 1000);
            const dateKey = formatDateKey(startTime);
            
            // æŒ‡å®šæ—¥ã®äºˆç´„ã‚’å–å¾—
            const dayReservations = reservations[dateKey] || [];
            
            // é‡è¤‡ãƒã‚§ãƒƒã‚¯ï¼ˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«æ™‚é–“ã‚‚å«ã‚€ï¼‰
            for (const reservation of dayReservations) {
                const reservationStart = new Date(`${dateKey}T${reservation.time}`);
                const reservationEnd = new Date(reservationStart.getTime() + reservation.duration * 60 * 1000);
                
                // ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«æ™‚é–“ã‚’å–å¾—ï¼ˆeffective_interval_minutesã‚’ä½¿ç”¨ï¼‰
                const intervalMinutes = reservation.effective_interval_minutes ?? 10;
                const reservationEndWithInterval = new Date(reservationEnd.getTime() + intervalMinutes * 60 * 1000);
                
                // ç¾åœ¨ã®äºˆç´„ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«æ™‚é–“ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ10åˆ†ï¼‰
                const currentIntervalMinutes = 10; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ10åˆ†
                const currentEndWithInterval = new Date(endTime.getTime() + currentIntervalMinutes * 60 * 1000);
                
                // é‡è¤‡åˆ¤å®šï¼ˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«æ™‚é–“ã‚‚å«ã‚€ï¼‰
                if (startTime < reservationEndWithInterval && currentEndWithInterval > reservationStart) {
                    return true; // é‡è¤‡ã‚ã‚Š
                }
            }
            
            return false; // é‡è¤‡ãªã—
        }

        // äºˆç´„å¯èƒ½æ™‚é–“ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆã™ã‚‹é–¢æ•°
        function highlightAvailableSlots() {
            const dateTime = document.getElementById('bookingDate')?.value;
            const duration = document.getElementById('bookingDuration')?.value;
            
            if (!dateTime || !duration) return;
            
            const startTime = new Date(dateTime);
            const endTime = new Date(startTime.getTime() + parseInt(duration) * 60 * 1000);
            const dateKey = formatDateKey(startTime);
            
            // æ—¢å­˜ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’ã‚¯ãƒªã‚¢
            document.querySelectorAll('.time-slot').forEach(slot => {
                slot.classList.remove('overlap-warning', 'available-slot');
            });
            
            // æŒ‡å®šæ—¥ã®äºˆç´„ã‚’å–å¾—
            const dayReservations = reservations[dateKey] || [];
            
            // å„æ™‚é–“ã‚¹ãƒ­ãƒƒãƒˆã‚’ãƒã‚§ãƒƒã‚¯
            document.querySelectorAll('.time-slot').forEach(slot => {
                const slotTime = slot.getAttribute('data-time');
                if (!slotTime) return;
                
                const slotStart = new Date(`${dateKey}T${slotTime}`);
                const slotEnd = new Date(slotStart.getTime() + parseInt(duration) * 60 * 1000);
                
                // é‡è¤‡ãƒã‚§ãƒƒã‚¯ï¼ˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«æ™‚é–“ã‚‚å«ã‚€ï¼‰
                let hasOverlap = false;
                for (const reservation of dayReservations) {
                    const reservationStart = new Date(`${dateKey}T${reservation.time}`);
                    const reservationEnd = new Date(reservationStart.getTime() + reservation.duration * 60 * 1000);
                    
                    // ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«æ™‚é–“ã‚’å–å¾—ï¼ˆeffective_interval_minutesã‚’ä½¿ç”¨ï¼‰
                    const intervalMinutes = reservation.effective_interval_minutes ?? 10;
                    const reservationEndWithInterval = new Date(reservationEnd.getTime() + intervalMinutes * 60 * 1000);
                    
                    // ç¾åœ¨ã®ã‚¹ãƒ­ãƒƒãƒˆã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«æ™‚é–“ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ10åˆ†ï¼‰
                    const currentIntervalMinutes = 10; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ10åˆ†
                    const slotEndWithInterval = new Date(slotEnd.getTime() + currentIntervalMinutes * 60 * 1000);
                    
                    if (slotStart < reservationEndWithInterval && slotEndWithInterval > reservationStart) {
                        hasOverlap = true;
                        break;
                    }
                }
                
                if (hasOverlap) {
                    slot.classList.add('overlap-warning');
                } else {
                    slot.classList.add('available-slot');
                }
            });
        }

        // ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—æ©Ÿèƒ½
        let isDragging = false;
        let draggedReservationData = null;

        function handleDragStart(e) {
            console.log('ğŸ¯ handleDragStart called for target:', e.target);
            isDragging = true;
            
            // The target should be the reservation block itself
            const reservationBlock = e.target;
            
            if (!reservationBlock || !reservationBlock.classList.contains('reservation-block')) {
                console.error('âŒ Target is not a reservation block');
                return;
            }
            
            const reservationId = reservationBlock.dataset.reservationId;
            
            if (!reservationId) {
                console.error('âŒ Reservation ID not found');
                return;
            }
            
            console.log('ğŸ¯ Drag started for reservation:', reservationId, 'from block:', reservationBlock);
            
            // Store the original reservation data for better debugging
            const reservationData = JSON.parse(reservationBlock.dataset.reservationData);
            draggedReservationData = reservationData; // Store globally
            
            console.log('ğŸ¯ Original reservation data:', {
                id: reservationData.id,
                customer: reservationData.customer,
                time: reservationData.time,
                date: reservationBlock.dataset.originalDateKey
            });
            
            e.dataTransfer.setData('text/plain', reservationId);
            reservationBlock.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            
            // Use the original block as the drag image so it follows the cursor
            e.dataTransfer.setDragImage(reservationBlock, 50, 25);
            
            // Prevent other drag events from firing
            e.stopPropagation();
        }

        function handleDragEnd(e) {
            // The target should be the reservation block itself
            const reservationBlock = e.target;
            
            if (reservationBlock && reservationBlock.classList.contains('reservation-block')) {
                reservationBlock.classList.remove('dragging');
            }
            
            document.querySelectorAll('.schedule-cell').forEach(cell => {
                cell.classList.remove('drag-over');
                cell.classList.remove('drag-over-invalid');
            });
            
                            // å°‘ã—é…å»¶ã—ã¦ã‹ã‚‰ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆèª¤ã‚¯ãƒªãƒƒã‚¯ã‚’é˜²ãï¼‰
                setTimeout(() => {
                    isDragging = false;
                    draggedReservationData = null; // Clear global data
                }, 100);
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            
            const cell = e.target.closest('.schedule-cell');
            if (cell) {
                // Clear all previous drag-over states
                document.querySelectorAll('.schedule-cell').forEach(c => {
                    c.classList.remove('drag-over');
                    c.classList.remove('drag-over-invalid');
                });
                
                // Get the reservation data from global variable
                if (draggedReservationData) {
                    const reservationData = draggedReservationData;
                    const duration = reservationData.duration || 60;
                    const interval = reservationData.effective_interval_minutes ?? 10;
                    const totalDuration = duration + interval;
                    
                    // Calculate how many cells this reservation would occupy (10-minute slots)
                    const cellsToOccupy = Math.ceil(totalDuration / 10);
                    
                    // Check if all required cells are within business hours
                    let currentCell = cell;
                    let allCellsValid = true;
                    let cellsToCheck = [];
                    
                    // First, collect all cells that would be occupied
                    for (let i = 0; i < cellsToOccupy && currentCell; i++) {
                        cellsToCheck.push(currentCell);
                        
                        // Move to the next row (next time slot) in the same day column
                        const currentRow = currentCell.parentElement;
                        const nextRow = currentRow.nextElementSibling;
                        if (nextRow) {
                            const nextCell = nextRow.querySelector(`[data-day="${currentCell.dataset.day}"]`);
                            if (nextCell && nextCell.classList.contains('schedule-cell')) {
                                currentCell = nextCell;
                            } else {
                                break; // No more cells in this day column
                            }
                        } else {
                            break; // No more rows
                        }
                    }
                    
                    // Check if all cells are within business hours
                    for (let checkCell of cellsToCheck) {
                        const dayOfWeek = parseInt(checkCell.dataset.day);
                        const timeStr = checkCell.dataset.time;
                        
                        if (!isBusinessHour(dayOfWeek, timeStr)) {
                            allCellsValid = false;
                            break;
                        }
                    }
                    
                    // Only highlight if all cells are valid
                    if (allCellsValid) {
                        for (let checkCell of cellsToCheck) {
                            checkCell.classList.add('drag-over');
                        }
                    } else {
                        // Show invalid drop effect and visual feedback
                        e.dataTransfer.dropEffect = 'none';
                        for (let checkCell of cellsToCheck) {
                            checkCell.classList.add('drag-over-invalid');
                        }
                    }
                } else {
                    // If no dragged data, check if current cell is within business hours
                    const dayOfWeek = parseInt(cell.dataset.day);
                    const timeStr = cell.dataset.time;
                    
                    if (isBusinessHour(dayOfWeek, timeStr)) {
                        cell.classList.add('drag-over');
                    } else {
                        e.dataTransfer.dropEffect = 'none';
                    }
                }
            }
        }

        function handleDragEnter(e) {
            e.preventDefault();
            if (e.target.classList.contains('schedule-cell')) {
                e.target.classList.add('drag-over');
            }
        }

        function handleDragLeave(e) {
            if (e.target.classList.contains('schedule-cell')) {
                e.target.classList.remove('drag-over');
            }
        }

        function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            
            // ãƒ‰ãƒ©ãƒƒã‚°ã‚ªãƒ¼ãƒãƒ¼çŠ¶æ…‹ã‚’ã‚¯ãƒªã‚¢
            document.querySelectorAll('.schedule-cell').forEach(cell => {
                cell.classList.remove('drag-over');
                cell.classList.remove('drag-over-invalid');
            });
            
            const cell = e.target.closest('.schedule-cell');
            if (!cell) return;
            
            const reservationId = e.dataTransfer.getData('text/plain');
            console.log('ğŸ¯ Drop detected for reservation:', reservationId, 'at cell:', cell.dataset.day, cell.dataset.time);
            
            if (!reservationId || reservationId.trim() === '') {
                console.log('âŒ Empty reservation ID, ignoring drop');
                return;
            }
            
            const reservationBlock = document.querySelector(`[data-reservation-id="${reservationId}"]`);
            
            if (!reservationBlock) {
                console.log('âŒ Reservation block not found for ID:', reservationId);
                return;
            }
            
            const reservationData = JSON.parse(reservationBlock.dataset.reservationData);
            const newDay = parseInt(cell.dataset.day);
            const newTime = cell.dataset.time;
            
            // Check if the target time slot is within business hours
            if (!isBusinessHour(newDay, newTime)) {
                showMessage('å–¶æ¥­æ™‚é–“å¤–ã®ãŸã‚ã€ã“ã®æ™‚é–“ã«äºˆç´„ã‚’ç§»å‹•ã§ãã¾ã›ã‚“ã€‚', 'error');
                return;
            }
            
            // Check if all required time slots for the reservation are within business hours
            const duration = reservationData.duration || 60;
            const interval = reservationData.effective_interval_minutes ?? 10;
            const totalDuration = duration + interval;
            const cellsToOccupy = Math.ceil(totalDuration / 10);
            
            let currentCell = cell;
            let allSlotsValid = true;
            
            for (let i = 0; i < cellsToOccupy && currentCell; i++) {
                const dayOfWeek = parseInt(currentCell.dataset.day);
                const timeStr = currentCell.dataset.time;
                
                if (!isBusinessHour(dayOfWeek, timeStr)) {
                    allSlotsValid = false;
                    break;
                }
                
                // Move to the next row (next time slot) in the same day column
                const currentRow = currentCell.parentElement;
                const nextRow = currentRow.nextElementSibling;
                if (nextRow) {
                    const nextCell = nextRow.querySelector(`[data-day="${currentCell.dataset.day}"]`);
                    if (nextCell && nextCell.classList.contains('schedule-cell')) {
                        currentCell = nextCell;
                    } else {
                        break; // No more cells in this day column
                    }
                } else {
                    break; // No more rows
                }
            }
            
            if (!allSlotsValid) {
                showMessage('äºˆç´„æ™‚é–“ãŒå–¶æ¥­æ™‚é–“å¤–ã«åŠã¶ãŸã‚ã€ã“ã®ä½ç½®ã«ç§»å‹•ã§ãã¾ã›ã‚“ã€‚', 'error');
                return;
            }
            
            // æ–°ã—ã„æ—¥ä»˜ã‚’è¨ˆç®—
            const newDate = new Date(currentWeekStart);
            newDate.setDate(newDate.getDate() + newDay);
            const newDateKey = formatDateKey(newDate);
            
            // é‡è¤‡ãƒã‚§ãƒƒã‚¯
            console.log('ğŸ” Checking for overlap:', {
                reservationId: reservationData.id,
                from: `${reservationBlock.dataset.originalDateKey} ${reservationBlock.dataset.originalTimeStr}`,
                to: `${newDateKey} ${newTime}`,
                duration: reservationData.duration,
                interval: reservationData.effective_interval_minutes ?? 10
            });
            
            // åŒã˜å ´æ‰€ã«ãƒ‰ãƒ­ãƒƒãƒ—ã—ãŸå ´åˆã¯ä½•ã‚‚ã—ãªã„
            if (reservationBlock.dataset.originalDateKey === newDateKey && 
                reservationBlock.dataset.originalTimeStr === newTime) {
                console.log('â­ï¸ Dropped in same location, ignoring');
                return;
            }
            
            if (checkForOverlapOnDrop(newDateKey, newTime, reservationData)) {
                showMessage('ã“ã®æ™‚é–“å¸¯ã«ã¯æ—¢ã«äºˆç´„ãŒã‚ã‚Šã¾ã™ã€‚åˆ¥ã®æ™‚é–“ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚', 'error');
                return;
            }
            
            console.log('âœ… Proceeding with reservation update');
            
            // Prevent multiple updates for the same reservation
            if (reservationBlock.dataset.updating === 'true') {
                console.log('â­ï¸ Reservation already being updated, skipping');
                return;
            }
            
            reservationBlock.dataset.updating = 'true';
            updateReservationTime(reservationData.id, newDateKey, newTime);
        }

        // ãƒ‰ãƒ­ãƒƒãƒ—æ™‚ã®é‡è¤‡ãƒã‚§ãƒƒã‚¯
        function checkForOverlapOnDrop(dateKey, timeStr, reservationData) {
            const startTime = new Date(`${dateKey}T${timeStr}`);
            const endTime = new Date(startTime.getTime() + reservationData.duration * 60 * 1000);
            
            // æŒ‡å®šæ—¥ã®äºˆç´„ã‚’å–å¾—ï¼ˆè‡ªåˆ†ä»¥å¤–ï¼‰
            const dayReservations = reservations[dateKey] || [];
            
            console.log('ğŸ” Checking overlaps for:', {
                dateKey: dateKey,
                timeStr: timeStr,
                reservationId: reservationData.id,
                duration: reservationData.duration,
                dayReservations: dayReservations.length
            });
            
            // é‡è¤‡ãƒã‚§ãƒƒã‚¯ï¼ˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«æ™‚é–“ã‚‚å«ã‚€ï¼‰
            for (const reservation of dayReservations) {
                if (reservation.id === reservationData.id) {
                    console.log('â­ï¸ Skipping self:', reservation.id);
                    continue; // è‡ªåˆ†ã¯é™¤å¤–
                }
                
                const reservationStart = new Date(`${dateKey}T${reservation.time}`);
                const reservationEnd = new Date(reservationStart.getTime() + reservation.duration * 60 * 1000);
                
                // ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«æ™‚é–“ã‚’å–å¾—ï¼ˆeffective_interval_minutesã‚’ä½¿ç”¨ï¼‰
                const intervalMinutes = reservation.effective_interval_minutes ?? 10;
                const reservationEndWithInterval = new Date(reservationEnd.getTime() + intervalMinutes * 60 * 1000);
                
                // ç¾åœ¨ã®äºˆç´„ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«æ™‚é–“
                const currentIntervalMinutes = reservationData.effective_interval_minutes ?? 10;
                const currentEndWithInterval = new Date(endTime.getTime() + currentIntervalMinutes * 60 * 1000);
                
                console.log('ğŸ” Comparing with reservation:', {
                    existingId: reservation.id,
                    existingTime: `${reservation.time} - ${new Date(reservationEndWithInterval).toTimeString().slice(0, 5)}`,
                    newTime: `${timeStr} - ${new Date(currentEndWithInterval).toTimeString().slice(0, 5)}`,
                    existingInterval: intervalMinutes,
                    newInterval: currentIntervalMinutes
                });
                
                // é‡è¤‡åˆ¤å®šï¼ˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«æ™‚é–“ã‚‚å«ã‚€ï¼‰
                if (startTime < reservationEndWithInterval && currentEndWithInterval > reservationStart) {
                    console.log('ğŸš« Overlap detected:', {
                        newReservation: `${timeStr} - ${new Date(currentEndWithInterval).toTimeString().slice(0, 5)}`,
                        existingReservation: `${reservation.time} - ${new Date(reservationEndWithInterval).toTimeString().slice(0, 5)}`,
                        date: dateKey
                    });
                    return true; // é‡è¤‡ã‚ã‚Š
                }
            }
            
            console.log('âœ… No overlaps detected');
            return false; // é‡è¤‡ãªã—
        }

        // äºˆç´„æ™‚é–“ã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
        function updateReservationTime(reservationId, newDateKey, newTime) {
            // å…ƒã®äºˆç´„ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            const originalDateKey = document.querySelector(`[data-reservation-id="${reservationId}"]`)?.dataset.originalDateKey;
            const originalTimeStr = document.querySelector(`[data-reservation-id="${reservationId}"]`)?.dataset.originalTimeStr;
            
            if (!originalDateKey || !originalTimeStr) {
                showMessage('äºˆç´„ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚', 'error');
                return;
            }
            
            // æ–°ã—ã„é–‹å§‹æ™‚é–“ã‚’ISOå½¢å¼ã§ä½œæˆ
            const newStartTime = `${newDateKey}T${newTime}`;
            
            // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã«æ›´æ–°ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡
            const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');
            
            // äºˆç´„ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¦ã‚³ãƒ¼ã‚¹æƒ…å ±ã‚‚å«ã‚ã‚‹
            const reservationBlock = document.querySelector(`[data-reservation-id="${reservationId}"]`);
            const reservationData = reservationBlock ? JSON.parse(reservationBlock.dataset.reservationData) : null;
            
            fetch(`/admin/reservations/${reservationId}/update_booking`, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-Token': csrfToken
                },
                body: JSON.stringify({
                    reservation: {
                        start_time: newStartTime,
                        course: reservationData ? `${reservationData.duration}åˆ†` : undefined
                    }
                })
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(errorData => {
                        throw new Error(`HTTP error! status: ${response.status}, message: ${errorData.message || 'Unknown error'}`);
                    }).catch(() => {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    });
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    // ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°
                    updateLocalReservationData(reservationId, newDateKey, newTime);
                    
                    // updatedAtãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æ›´æ–°
                    if (data.reservation && data.reservation.updated_at) {
                        // ã‚°ãƒ­ãƒ¼ãƒãƒ«reservationsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®updatedAtã‚’æ›´æ–°
                        const reservationIndex = reservations[newDateKey].findIndex(r => r.id === parseInt(reservationId));
                        if (reservationIndex !== -1) {
                            reservations[newDateKey][reservationIndex].updatedAt = data.reservation.updated_at;
                        }
                        
                        // ç¾åœ¨é–‹ã„ã¦ã„ã‚‹ãƒ¢ãƒ¼ãƒ€ãƒ«ã®å¤‰æ›´æ—¥æ™‚ã‚’å³åº§ã«æ›´æ–°
                        if (currentReservation && currentReservation.id === parseInt(reservationId)) {
                            console.log('ğŸ”„ Updating currentReservation after drag-and-drop:', {
                                before: {
                                    time: currentReservation.time,
                                    date: currentReservation.date,
                                    dateKey: currentReservation.dateKey,
                                    start_time: currentReservation.start_time
                                }
                            });
                            
                            currentReservation.updatedAt = data.reservation.updated_at;
                            // æ—¥ä»˜ã¨æ™‚é–“ã‚‚æ›´æ–°
                            currentReservation.time = newTime;
                            currentReservation.date = newDateKey;
                            currentReservation.dateKey = newDateKey;
                            // start_timeã‚‚æ›´æ–°
                            const [hours, minutes] = newTime.split(':');
                            const newStartTime = new Date(`${newDateKey}T${hours}:${minutes}:00+09:00`);
                            currentReservation.start_time = newStartTime.toISOString();
                            
                            console.log('ğŸ”„ Updated currentReservation after drag-and-drop:', {
                                after: {
                                    time: currentReservation.time,
                                    date: currentReservation.date,
                                    dateKey: currentReservation.dateKey,
                                    start_time: currentReservation.start_time
                                }
                            });
                            
                            updateModalUpdatedAt(data.reservation.updated_at);
                        } else {
                            console.log('âŒ currentReservation not found or ID mismatch:', {
                                currentReservation: currentReservation ? currentReservation.id : 'null',
                                reservationId: reservationId
                            });
                            
                            // ãƒ¢ãƒ¼ãƒ€ãƒ«ãŒé–‹ã„ã¦ã„ã‚‹å ´åˆã¯ã€æœ€æ–°ã®ãƒ‡ãƒ¼ã‚¿ã§currentReservationã‚’æ›´æ–°
                            const modal = document.getElementById('reservationDetailModal');
                            console.log('ğŸ” Modal display status:', modal ? modal.style.display : 'modal not found');
                            
                            if (modal && modal.style.display === 'block') {
                                console.log('ğŸ” Modal is open, updating currentReservation...');
                                // æœ€æ–°ã®äºˆç´„ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¦currentReservationã‚’æ›´æ–°
                                for (const dateKey of Object.keys(reservations)) {
                                    const dayReservations = reservations[dateKey];
                                    const foundReservation = dayReservations.find(r => r.id === parseInt(reservationId));
                                    if (foundReservation) {
                                        currentReservation = foundReservation;
                                        console.log('ğŸ”„ Updated currentReservation from reservations data:', {
                                            time: currentReservation.time,
                                            date: currentReservation.date,
                                            dateKey: currentReservation.dateKey,
                                            start_time: currentReservation.start_time
                                        });
                                        break;
                                    }
                                }
                            } else {
                                console.log('ğŸ” Modal is not open, skipping currentReservation update');
                            }
                        }
                    }
                    
                    // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚’å†æç”»
                    console.log('ğŸ”„ Regenerating calendar after reservation move');
                    generateTimeSlots();
                    
                    showMessage('äºˆç´„æ™‚é–“ãŒæ›´æ–°ã•ã‚Œã¾ã—ãŸã€‚', 'success');
                } else {
                    showMessage(`äºˆç´„ã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ: ${data.message}`, 'error');
                }
                
                // Reset updating flag
                const reservationBlock = document.querySelector(`[data-reservation-id="${reservationId}"]`);
                if (reservationBlock) {
                    reservationBlock.dataset.updating = 'false';
                }
            })
            .catch(error => {
                console.error('Error updating reservation:', error);
                showMessage('äºˆç´„ã®æ›´æ–°ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚', 'error');
                
                // Reset updating flag on error
                const reservationBlock = document.querySelector(`[data-reservation-id="${reservationId}"]`);
                if (reservationBlock) {
                    reservationBlock.dataset.updating = 'false';
                }
            });
        }

        // ãƒ­ãƒ¼ã‚«ãƒ«äºˆç´„ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°
        function updateLocalReservationData(reservationId, newDateKey, newTime) {
            console.log('ğŸ”„ Updating local reservation data:', {
                reservationId: reservationId,
                newDateKey: newDateKey,
                newTime: newTime
            });
            
            // å…ƒã®äºˆç´„ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            let originalReservationData = null;
            let originalDateKey = null;
            
            // å…ƒã®äºˆç´„ã‚’è¦‹ã¤ã‘ã¦å‰Šé™¤
            for (const dateKey of Object.keys(reservations)) {
                const reservationIndex = reservations[dateKey].findIndex(r => r.id === parseInt(reservationId));
                if (reservationIndex !== -1) {
                    originalReservationData = { ...reservations[dateKey][reservationIndex] };
                    originalDateKey = dateKey;
                    reservations[dateKey].splice(reservationIndex, 1);
                    
                    // ç©ºã®é…åˆ—ã®å ´åˆã¯æ—¥ä»˜ã‚­ãƒ¼ã‚’å‰Šé™¤
                    if (reservations[dateKey].length === 0) {
                        delete reservations[dateKey];
                    }
                    break;
                }
            }
            
            if (!originalReservationData) {
                console.error('âŒ Original reservation data not found for ID:', reservationId);
                return;
            }
            
            // æ–°ã—ã„å ´æ‰€ã«äºˆç´„ã‚’è¿½åŠ 
            if (!reservations[newDateKey]) {
                reservations[newDateKey] = [];
            }
            
            // äºˆç´„ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°
            const updatedReservationData = {
                ...originalReservationData,
                time: newTime,
                date: newDateKey,
                dateKey: newDateKey,
                // start_timeã‚‚æ›´æ–°
                start_time: new Date(`${newDateKey}T${newTime}:00+09:00`).toISOString()
            };
            
            reservations[newDateKey].push(updatedReservationData);
            
            // DOMè¦ç´ ã®ãƒ‡ãƒ¼ã‚¿å±æ€§ã‚‚æ›´æ–°
            const reservationBlock = document.querySelector(`[data-reservation-id="${reservationId}"]`);
            if (reservationBlock) {
                reservationBlock.dataset.originalDateKey = newDateKey;
                reservationBlock.dataset.originalTimeStr = newTime;
                reservationBlock.dataset.reservationData = JSON.stringify(updatedReservationData);
            }
            
            console.log('âœ… Local reservation data updated:', {
                from: originalDateKey,
                to: newDateKey,
                reservationId: reservationId
            });
        }

        // äºˆç´„ãƒ‡ãƒ¼ã‚¿ã®å¦¥å½“æ€§ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹é–¢æ•°
        function validateReservationData(reservation) {
            if (!reservation) {
                console.error('âŒ Reservation is null or undefined');
                return false;
            }
            
            if (!reservation.id || reservation.id === 'null' || reservation.id === null) {
                console.error('âŒ Invalid reservation ID:', reservation.id);
                return false;
            }
            
            if (!reservation.userId || reservation.userId === 'null' || reservation.userId === null) {
                console.warn('âš ï¸ No user ID for reservation:', reservation.id);
                // Don't return false - allow modal to open without userId
            }
            

            
            return true;
        }

                // ãƒ¦ãƒ¼ã‚¶ãƒ¼æ¤œç´¢æ©Ÿèƒ½
        function setupUserSearch() {
            const customerNameInput = document.getElementById('customerName');
            const searchResults = document.getElementById('userSearchResults');
            
            if (!customerNameInput || !searchResults) return;
            
            // å…¥åŠ›ã‚¤ãƒ™ãƒ³ãƒˆ
            customerNameInput.addEventListener('input', function() {
                const query = this.value.trim();
                
                // ãƒ‡ãƒã‚¦ãƒ³ã‚¹å‡¦ç†
                if (searchTimeout) {
                    clearTimeout(searchTimeout);
                }
                
                if (query.length < 2) {
                    hideUserSearchResults();
                    return;
                }
                
                searchTimeout = setTimeout(() => {
                    searchUsers(query);
                }, 300);
            });
            
            // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã‚¢ã‚¦ãƒˆæ™‚ã«çµæœã‚’éš ã™
            customerNameInput.addEventListener('blur', function() {
                setTimeout(() => {
                    hideUserSearchResults();
                }, 200);
            });
            
            // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹æ™‚ã«çµæœã‚’è¡¨ç¤ºï¼ˆå…¥åŠ›ãŒã‚ã‚‹å ´åˆï¼‰
            customerNameInput.addEventListener('focus', function() {
                const query = this.value.trim();
                if (query.length >= 2) {
                    searchUsers(query);
                }
            });
        }
        
        function searchUsers(query) {

            
            fetch(`/admin/reservations/search_users?query=${encodeURIComponent(query)}`)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        displayUserSearchResults(data.users);
    } else {
                        console.error('âŒ User search failed:', data.message);
                        hideUserSearchResults();
    }
  })
  .catch(error => {
                    console.error('âŒ Error searching users:', error);
                    hideUserSearchResults();
                });
        }
        
        function displayUserSearchResults(users) {
            const searchResults = document.getElementById('userSearchResults');
            if (!searchResults) return;
            
            if (users.length === 0) {
                searchResults.innerHTML = '<div class="user-search-item">è©²å½“ã™ã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“</div>';
                searchResults.style.display = 'block';
                return;
            }
            
            const resultsHtml = users.map(user => `
                <div class="user-search-item" onclick="selectUser(${user.id}, '${user.name}', '${user.phone_number}', '${user.email}')">
                    <div class="user-name">${user.name}</div>
                    <div class="user-details">
                        ğŸ“ ${user.phone_number || 'æœªè¨­å®š'} | ğŸ“§ ${user.email || 'æœªè¨­å®š'}
                        ${user.active_tickets > 0 ? `<span class="user-tickets"> | ğŸ« æ®‹${user.active_tickets}æš</span>` : ''}
                        ${user.last_visit !== 'ãªã—' ? ` | ğŸ“… æœ€çµ‚æ¥åº—: ${user.last_visit}` : ''}
                    </div>
                </div>
            `).join('');
            
            searchResults.innerHTML = resultsHtml;
            searchResults.style.display = 'block';
        }
        
        function selectUser(userId, name, phone, email) {

            
            // ãƒ•ã‚©ãƒ¼ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æ›´æ–°
            document.getElementById('customerName').value = name;
            document.getElementById('customerPhone').value = phone;
            document.getElementById('customerEmail').value = email;
            
            // æ¤œç´¢çµæœã‚’éš ã™
            hideUserSearchResults();
            
            // æˆåŠŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
            showMessage(`æ—¢å­˜ãƒ¦ãƒ¼ã‚¶ãƒ¼ã€Œ${name}ã€ã‚’é¸æŠã—ã¾ã—ãŸ`, 'success');
        }
        
        function hideUserSearchResults() {
            console.log('ğŸ” hideUserSearchResults called');
            const searchResults = document.getElementById('userSelectionSearchResults');
            if (searchResults) {
                searchResults.style.display = 'none';
                searchResults.innerHTML = ''; // Also clear the content
                console.log('ğŸ” Search results hidden and cleared');
            } else {
                console.log('ğŸ” Search results element not found for hiding');
            }
        }

        // ã‚­ãƒ£ãƒ³ã‚»ãƒ«è¡¨ç¤ºã‚¨ãƒªã‚¢ã«äºˆç´„ã‚’è¿½åŠ 
        function addToCancellationDisplay(reservation) {
            if (!reservation) {
                console.error('âŒ Reservation is null or undefined');
                return;
            }
            
            // äºˆç´„ã®å®Ÿéš›ã®æ—¥ä»˜ã‚’ç‰¹å®š
            let actualReservationDate = null;
            
            // start_timeãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆã¯ãã‚Œã‚’ä½¿ç”¨ï¼ˆæœ€å„ªå…ˆï¼‰
            if (reservation.start_time) {
                actualReservationDate = new Date(reservation.start_time);
            } else {
                // reservationsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰æ¤œç´¢
                for (const dateKey of Object.keys(reservations)) {
                    const dayReservations = reservations[dateKey];
                    const foundReservation = dayReservations.find(r => r.id === reservation.id);
                    if (foundReservation) {
                        const [year, month, day] = dateKey.split('-').map(Number);
                        actualReservationDate = new Date(year, month - 1, day);
                        break;
                    }
                }
                
                // è¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯createdAtã‹ã‚‰è¨ˆç®—
                if (!actualReservationDate) {
                    actualReservationDate = new Date(reservation.createdAt);
                }
            }
            
            const cancellationData = {
                id: reservation.id,
                customer: reservation.customer,
                time: reservation.time,
                duration: reservation.duration,
                date: actualReservationDate.toLocaleDateString('ja-JP'),
                cancelledAt: new Date().toLocaleString('ja-JP')
            };
            
            cancelledReservations.unshift(cancellationData); // æœ€æ–°ã‚’å…ˆé ­ã«è¿½åŠ 
  
  // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜
            saveCancelledReservations();
            

            
            // å³åº§ã«æ›´æ–°ã‚’è©¦è¡Œï¼ˆæ¬¡ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã§å®Ÿè¡Œï¼‰
            requestAnimationFrame(() => {
                updateCancellationDisplayImmediately();
            });
        }

        // ã‚­ãƒ£ãƒ³ã‚»ãƒ«è¡¨ç¤ºã‚¨ãƒªã‚¢ã‚’æ›´æ–°ï¼ˆå³åº§ã«å®Ÿè¡Œï¼‰
        // ç¾åœ¨ã®é€±ã®ã‚­ãƒ£ãƒ³ã‚»ãƒ«å±¥æ­´ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
        function getCurrentWeekCancellations() {
            const weekStart = new Date(currentWeekStart);
            const weekEnd = new Date(currentWeekStart);
            weekEnd.setDate(weekEnd.getDate() + 6);
            
            return cancelledReservations.filter(reservation => {
                const reservationDate = new Date(reservation.date);
                return reservationDate >= weekStart && reservationDate <= weekEnd;
            });
        }

        function updateCancellationDisplayImmediately() {
            const btn = document.getElementById('showCancellationsBtn');
            const countSpan = document.getElementById('cancellation-count');
            const display = document.getElementById('cancellation-display');
            const list = document.getElementById('cancellation-list');
            
            // ç¾åœ¨ã®é€±ã®ã‚­ãƒ£ãƒ³ã‚»ãƒ«å±¥æ­´ã‚’å–å¾—
            const currentWeekCancellations = getCurrentWeekCancellations();
            
            console.log('ğŸ”„ Attempting to update cancellation display, total count:', cancelledReservations.length, 'current week:', currentWeekCancellations.length);
            console.log('ğŸ” Elements found:', { btn: !!btn, countSpan: !!countSpan, display: !!display, list: !!list });
            
            // ãƒœã‚¿ãƒ³ãŒå­˜åœ¨ã™ã‚‹å ´åˆã¯å³åº§ã«æ›´æ–°ï¼ˆspanãŒãªãã¦ã‚‚ãƒœã‚¿ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ç›´æ¥æ›´æ–°ï¼‰
            if (btn) {
                console.log('ğŸ”„ Updating cancellation display immediately, current week count:', currentWeekCancellations.length);
                
                // ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã‚’æ›´æ–°ï¼ˆspanãŒãªãã¦ã‚‚ç›´æ¥ãƒ†ã‚­ã‚¹ãƒˆã‚’æ›´æ–°ï¼‰
                if (currentWeekCancellations.length === 0) {
                    btn.disabled = false;
                    btn.textContent = `âŒ ã‚­ãƒ£ãƒ³ã‚»ãƒ«å±¥æ­´ (0)`;
                    if (display) {
                        display.style.display = 'none';
                    }
                    console.log('âœ… Updated cancellation display for 0 cancellations in current week');
    } else {
                    btn.disabled = false;
                    btn.textContent = `âŒ ã‚­ãƒ£ãƒ³ã‚»ãƒ«å±¥æ­´ (${currentWeekCancellations.length})`;
                    console.log('âœ… Updated cancellation display for', currentWeekCancellations.length, 'cancellations in current week');
                }
                
                // spanãŒå­˜åœ¨ã™ã‚‹å ´åˆã¯ãã‚Œã‚‚æ›´æ–°
                if (countSpan) {
                    countSpan.textContent = currentWeekCancellations.length;
                }
                
                // ãƒªã‚¹ãƒˆã‚’æ›´æ–°ï¼ˆè¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹å ´åˆã®ã¿ï¼‰
                if (display && display.style.display === 'block' && list) {
                    const listHtml = currentWeekCancellations.map(reservation => `
                        <div class="cancellation-item">
                            <div class="cancellation-info">
                                <div class="cancellation-customer">${reservation.customer}</div>
                                <div class="cancellation-details">
                                    ğŸ“… ${reservation.date} <span class="cancellation-time">${reservation.time}</span> | 
                                    â±ï¸ ${reservation.duration}åˆ† | 
                                    ğŸ—‘ï¸ ${reservation.cancelledAt}
                                </div>
                            </div>
                        </div>
                    `).join('');
                    
                    list.innerHTML = listHtml;
                }
            } else {
                if (!domReady) {
                    console.log('âš ï¸ DOM not ready yet, will update when ready');
                    // DOMãŒæº–å‚™ã§ãã¦ã„ãªã„å ´åˆã¯å¾Œã§æ›´æ–°
                    setTimeout(() => {
                        updateCancellationDisplayImmediately();
                    }, 200);
                } else {
                    console.log('âš ï¸ Cancellation button not found, will update later');
                    // è¦ç´ ãŒæº–å‚™ã§ãã¦ã„ãªã„å ´åˆã¯å¾Œã§æ›´æ–°ï¼ˆã‚ˆã‚Šé•·ã„é–“éš”ã§ï¼‰
                    setTimeout(() => {
                        updateCancellationDisplayImmediately();
                    }, 100);
                }
            }
        }

        // ã‚­ãƒ£ãƒ³ã‚»ãƒ«è¡¨ç¤ºã‚¨ãƒªã‚¢ã‚’æ›´æ–°ï¼ˆå¾…æ©Ÿç‰ˆï¼‰
        function updateCancellationDisplay() {
            // å³åº§ã«æ›´æ–°ã‚’è©¦è¡Œ
            updateCancellationDisplayImmediately();
        }

        // ã‚­ãƒ£ãƒ³ã‚»ãƒ«è¡¨ç¤ºã‚¨ãƒªã‚¢ã®è¡¨ç¤º/éè¡¨ç¤ºã‚’åˆ‡ã‚Šæ›¿ãˆ
        function toggleCancellationDisplay() {
            const display = document.getElementById('cancellation-display');
            const btn = document.getElementById('showCancellationsBtn');
            const list = document.getElementById('cancellation-list');
            
            // è¦ç´ ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³
            if (!display || !btn || !list) {
                console.error('âŒ Cancellation display elements not found');
                showMessage('ã‚­ãƒ£ãƒ³ã‚»ãƒ«è¡¨ç¤ºã‚¨ãƒªã‚¢ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚', 'error');
                return;
            }
            
            if (display.style.display === 'none') {
                // è¡¨ç¤ºã™ã‚‹
                display.style.display = 'block';
                btn.classList.add('active');
                
                // ç¾åœ¨ã®é€±ã®ã‚­ãƒ£ãƒ³ã‚»ãƒ«å±¥æ­´ã‚’å–å¾—ã—ã¦ãƒªã‚¹ãƒˆã‚’æ›´æ–°
                const currentWeekCancellations = getCurrentWeekCancellations();
                const listHtml = currentWeekCancellations.map(reservation => `
                    <div class="cancellation-item">
                        <div class="cancellation-info">
                            <div class="cancellation-customer">${reservation.customer}</div>
                            <div class="cancellation-details">
                                ğŸ“… ${reservation.date} <span class="cancellation-time">${reservation.time}</span> | 
                                â±ï¸ ${reservation.duration}åˆ† | 
                                ğŸ—‘ï¸ ${reservation.cancelledAt}
                            </div>
                        </div>
                    </div>
                `).join('');
                
                list.innerHTML = listHtml;
                
                showMessage('ã‚­ãƒ£ãƒ³ã‚»ãƒ«å±¥æ­´ã‚’è¡¨ç¤ºã—ã¾ã—ãŸã€‚', 'info');
            } else {
                // éè¡¨ç¤ºã«ã™ã‚‹
                display.style.display = 'none';
                btn.classList.remove('active');
                showMessage('ã‚­ãƒ£ãƒ³ã‚»ãƒ«å±¥æ­´ã‚’éè¡¨ç¤ºã«ã—ã¾ã—ãŸã€‚', 'info');
            }
        }

        // ã‚­ãƒ£ãƒ³ã‚»ãƒ«è¡¨ç¤ºã‚¨ãƒªã‚¢ã‚’ã‚¯ãƒªã‚¢
        function clearCancellationDisplay() {
            console.log('ğŸ—‘ï¸ Clearing cancellation display...');
            
            // ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢
            cancelledReservations = [];
            
            // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‹ã‚‰ã‚‚å‰Šé™¤
            localStorage.removeItem('cancelledReservations');
            
            // è¦ç´ ã‚’å–å¾—
            const display = document.getElementById('cancellation-display');
            const btn = document.getElementById('showCancellationsBtn');
            const countSpan = document.getElementById('cancellation-count');
            const list = document.getElementById('cancellation-list');
            
            // è¦ç´ ãŒå­˜åœ¨ã™ã‚‹å ´åˆã®ã¿æ“ä½œ
            if (btn && countSpan) {
                // ã‚«ã‚¦ãƒ³ãƒˆã‚’æ›´æ–°
                countSpan.textContent = '0';
                btn.textContent = 'âŒ ã‚­ãƒ£ãƒ³ã‚»ãƒ«å±¥æ­´ (0)';
                btn.disabled = false;
            }
            
            if (display) {
                display.style.display = 'none';
            }
            
            if (btn) {
                btn.classList.remove('active');
            }
            
            if (list) {
                list.innerHTML = '';
            }
            
            console.log('âœ… Cancellation display cleared successfully');
            
            // å³åº§ã«æ›´æ–°
            updateCancellationDisplayImmediately();
            
            showMessage('ã‚­ãƒ£ãƒ³ã‚»ãƒ«å±¥æ­´ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸã€‚', 'info');
        }
        
        // ã‚­ãƒ£ãƒ³ã‚»ãƒ«è¡¨ç¤ºã®åˆæœŸåŒ–ï¼ˆå³åº§ã«å®Ÿè¡Œï¼‰
        function initializeCancellationDisplay() {
            console.log('ğŸš€ Starting cancellation display initialization...');
            loadCancelledReservations();
            
            // å³åº§ã«æ›´æ–°ã‚’è©¦è¡Œ
            setTimeout(() => {
                updateCancellationDisplayImmediately();
                cancellationDisplayReady = true;
                console.log('âœ… Cancellation display initialized successfully');
            }, 100);
        }
        
        // åˆæœŸåŒ–å®Ÿè¡Œ
        init();
        
        // DOMãŒå®Œå…¨ã«èª­ã¿è¾¼ã¾ã‚Œã¦ã‹ã‚‰ã‚­ãƒ£ãƒ³ã‚»ãƒ«è¡¨ç¤ºã‚’åˆæœŸåŒ–
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                domReady = true;
                setTimeout(() => {
                    initializeCancellationDisplay();
                }, 100);
            });
        } else {
            // DOMãŒæ—¢ã«èª­ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹å ´åˆ
            domReady = true;
            setTimeout(() => {
                initializeCancellationDisplay();
            }, 100);
        }
        
        // ãƒ¦ãƒ¼ã‚¶ãƒ¼æ¤œç´¢æ©Ÿèƒ½ã‚’åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', function() {
            setupUserSearch();
        });
</script> 
</body>
</html> 