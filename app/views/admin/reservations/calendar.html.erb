<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="csrf-token" content="<%= form_authenticity_token %>">
    <title>äºˆç´„ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ </title>
    <%= stylesheet_link_tag 'calendar', media: 'all' %>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ“… äºˆç´„ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ </h1>
            <div class="header-controls">
                <div class="week-nav">
                    <button class="nav-btn" onclick="previousWeek()">â† å‰é€±</button>
                    <div class="current-week" id="currentWeek">èª­ã¿è¾¼ã¿ä¸­...</div>
                    <button class="nav-btn" onclick="nextWeek()">æ¬¡é€± â†’</button>
                </div>
                <div class="action-buttons">
                    <button class="btn btn-primary" onclick="openBulkReservationModal()">ğŸ“… ä¸€æ‹¬äºˆç´„ä½œæˆ</button>
                </div>
                <div class="mini-calendar-container">
                    <button class="mini-calendar-btn" onclick="toggleMiniCalendar()">
                        ğŸ“… é€±ã‚’é¸æŠ
                    </button>
                    <div class="mini-calendar" id="miniCalendar">
                        <div class="mini-calendar-header">
                            <button class="mini-calendar-year-btn" onclick="previousMiniCalendarYear()" title="å‰å¹´">â€¹â€¹</button>
                            <button class="mini-calendar-nav-btn" onclick="previousMiniCalendarMonth()" title="å‰æœˆ">â€¹</button>
                            <div class="mini-calendar-title" id="miniCalendarTitle">èª­ã¿è¾¼ã¿ä¸­...</div>
                            <button class="mini-calendar-nav-btn" onclick="nextMiniCalendarMonth()" title="ç¿Œæœˆ">â€º</button>
                            <button class="mini-calendar-year-btn" onclick="nextMiniCalendarYear()" title="ç¿Œå¹´">â€ºâ€º</button>
                        </div>
                        <div class="mini-calendar-weekdays">
                            <div class="mini-calendar-weekday">æ—¥</div>
                            <div class="mini-calendar-weekday">æœˆ</div>
                            <div class="mini-calendar-weekday">ç«</div>
                            <div class="mini-calendar-weekday">æ°´</div>
                            <div class="mini-calendar-weekday">æœ¨</div>
                            <div class="mini-calendar-weekday">é‡‘</div>
                            <div class="mini-calendar-weekday">åœŸ</div>
                        </div>
                        <div class="mini-calendar-days" id="miniCalendarDays">
                            <!-- å‹•çš„ã«ç”Ÿæˆã•ã‚Œã‚‹ -->
                        </div>
                    </div>
                </div>
                <button id="showCancellationsBtn" onclick="toggleCancellationDisplay()" class="cancellation-btn">
                    âŒ ã‚­ãƒ£ãƒ³ã‚»ãƒ«å±¥æ­´ (<span id="cancellation-count">0</span>)
                </button>
                <button class="settings-btn" onclick="openSettingsModal()">
                    âš™ï¸ äºˆç´„å¯èƒ½æ—¥æ™‚ã‚’ç·¨é›†
                </button>
            </div>
        </div>
        
        <div id="cancellation-display" class="cancellation-display" style="display: none;">
            <div class="cancellation-header">
                <h3>âŒ ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚ŒãŸäºˆç´„</h3>
                <button onclick="clearCancellationDisplay()" class="clear-btn">ã‚¯ãƒªã‚¢</button>
            </div>
            <div id="cancellation-list" class="cancellation-list">
                <!-- ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚ŒãŸäºˆç´„ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™ -->
            </div>
        </div>

        <div class="schedule-container">
            <div class="schedule-header">
                <div class="time-column-header">æ™‚åˆ»</div>
                <div class="day-header sunday">æ—¥<br><span style="font-size: 12px;">8/10</span></div>
                <div class="day-header">æœˆ<br><span style="font-size: 12px;">8/11</span></div>
                <div class="day-header">ç«<br><span style="font-size: 12px;">8/12</span></div>
                <div class="day-header">æ°´<br><span style="font-size: 12px;">8/13</span></div>
                <div class="day-header">æœ¨<br><span style="font-size: 12px;">8/14</span></div>
                <div class="day-header">é‡‘<br><span style="font-size: 12px;">8/15</span></div>
                <div class="day-header saturday">åœŸ<br><span style="font-size: 12px;">8/16</span></div>
            </div>
            
            <div class="schedule-body" id="scheduleBody">
                <!-- æ™‚é–“ã‚¹ãƒ­ãƒƒãƒˆã¯å‹•çš„ã«ç”Ÿæˆã•ã‚Œã‚‹ -->
            </div>
        </div>
    </div>

    <!-- è¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>âš™ï¸ äºˆç´„å¯èƒ½æ—¥æ™‚ã‚’ç·¨é›†</h2>
                <span class="close" onclick="closeSettingsModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="settings-tabs">
                    <button class="tab-button active" onclick="switchTab('general')">ä¸€å›é™ã‚Šã®å¤‰æ›´</button>
                    <button class="tab-button" onclick="switchTab('recurring')">å®šæœŸçš„ãªã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«</button>
                </div>

                <!-- ä¸€å›é™ã‚Šã®å¤‰æ›´ã‚¿ãƒ– -->
                <div id="general-tab" class="tab-content active">
                    <div id="week-info" style="margin-bottom: 20px; padding: 12px; background: #f8f9fa; border-radius: 6px; border-left: 4px solid #007bff;">
                        <strong>ç¾åœ¨ã®é€±:</strong> <span id="current-week-display"></span>
                        <br><small id="schedule-type-info" style="color: #666;"></small>
                    </div>
                    
                    <div id="daySettings">
                        <!-- æ›œæ—¥åˆ¥è¨­å®šãŒå‹•çš„ã«ç”Ÿæˆã•ã‚Œã‚‹ -->
      </div>
    </div>

                <!-- å®šæœŸçš„ãªã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¿ãƒ– -->
                <div id="recurring-tab" class="tab-content">
                    <p style="margin-bottom: 20px; color: #666;">ä»Šå¾Œã®é€±ã«é©ç”¨ã™ã‚‹ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è¨­å®š</p>
                    
                    <div id="recurringDaySettings">
                        <!-- å®šæœŸçš„ãªè¨­å®šãŒå‹•çš„ã«ç”Ÿæˆã•ã‚Œã‚‹ -->
        </div>
        </div>
        </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeSettingsModal()">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                <button class="btn btn-success" onclick="saveSettings()">å®Œäº†</button>
          </div>
        </div>
        </div>

    <!-- äºˆç´„ä½œæˆãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="bookingModal" class="booking-modal">
        <div class="booking-modal-content">
            <div class="booking-modal-header">
                <h2>ğŸ“… æ–°è¦äºˆç´„ä½œæˆ</h2>
                <span class="booking-modal-close" onclick="closeBookingModal()">&times;</span>
            </div>
            <div class="booking-modal-body">
                <!-- äºˆç´„æ—¥æ™‚æƒ…å ±ã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
                <div class="booking-info-section">
                    <div class="booking-datetime">
                        <span id="bookingDisplayDate"></span> <strong id="bookingDisplayTime"></strong>
                    </div>
                </div>

                <!-- äºˆç´„ãƒ•ã‚©ãƒ¼ãƒ ã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
                <div class="booking-form-section">
                    <div class="booking-field">
                        <label class="booking-label">ğŸ¯ ã‚³ãƒ¼ã‚¹é¸æŠ</label>
                        <select id="bookingDuration" class="booking-select" required>
                            <option value="">ã‚³ãƒ¼ã‚¹ã‚’é¸æŠã—ã¦ãã ã•ã„</option>
                            <option value="40">40åˆ†ã‚³ãƒ¼ã‚¹</option>
                            <option value="60">60åˆ†ã‚³ãƒ¼ã‚¹</option>
                            <option value="80">80åˆ†ã‚³ãƒ¼ã‚¹</option>
                        </select>
                    </div>
                    
                    <div class="booking-field">
                        <label class="booking-label">ğŸ‘¤ ãŠå®¢æ§˜å <span style="color: #e74c3c; font-weight: 700;">*</span></label>
                        <input type="text" id="customerName" class="booking-input" required placeholder="å±±ç”°å¤ªéƒ" autocomplete="off">
                        <div id="userSearchResults" class="user-search-results" style="display: none;"></div>
                    </div>
                    
                    <div class="booking-field">
                        <label class="booking-label">ğŸ“ é›»è©±ç•ªå· <span style="color: #e74c3c; font-weight: 700;">*</span></label>
                        <input type="tel" id="customerPhone" class="booking-input" required placeholder="090-1234-5678">
                    </div>
                    
                    <div class="booking-field">
                        <label class="booking-label">ğŸ“§ ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹</label>
                        <input type="email" id="customerEmail" class="booking-input" placeholder="example@email.com">
                    </div>
                    
                    <div class="booking-field">
                        <label class="booking-label">ğŸ“ å‚™è€ƒãƒ»ã”è¦æœ›</label>
                        <textarea id="bookingNote" class="booking-textarea" rows="3" placeholder="ã”è¦æœ›ã‚„ã”è³ªå•ãŒã‚ã‚Œã°ã”è¨˜å…¥ãã ã•ã„"></textarea>
                    </div>
                    
                    <div class="booking-field">
                        <label class="booking-label">ğŸ·ï¸ äºˆç´„ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹</label>
                        <select id="bookingStatus" class="booking-select">
                            <option value="tentative">ä»®äºˆç´„</option>
                            <option value="confirmed">ç¢ºå®š</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="booking-modal-footer">
                <button type="button" class="booking-btn booking-btn-cancel" onclick="closeBookingModal()">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                <button type="button" class="booking-btn booking-btn-create" id="submitBookingBtn" onclick="createBooking()">ğŸ“… äºˆç´„ä½œæˆ</button>
            </div>
        </div>
    </div>

    <!-- ä¼‘æ†©ä½œæˆãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="breakModal" class="break-modal">
        <div class="break-modal-content">
            <div class="break-modal-header">
                <h2>â˜• ä¼‘æ†©ä½œæˆ</h2>
                <span class="break-modal-close" onclick="closeBreakModal()">&times;</span>
            </div>
            <div class="break-modal-body">
                <div class="break-info-section">
                    <div class="break-datetime">
                        <span id="breakDisplayDate"></span> <strong id="breakDisplayTime"></strong>
                    </div>
                </div>

                <div class="break-form-section">
                    <div class="break-field">
                        <label class="break-label">ğŸŠ ä¼‘æ†©ã‚¿ã‚¤ãƒˆãƒ«</label>
                        <select id="breakTitle" class="break-select" required onchange="handleBreakTitleChange()">
                            <option value="">é¸æŠã—ã¦ãã ã•ã„</option>
                            <option value="ä¼‘æ†©">â˜• ä¼‘æ†©</option>
                            <option value="æº–å‚™æ™‚é–“">âš™ï¸ æº–å‚™æ™‚é–“</option>
                            <option value="æ¥­å‹™">ğŸ’¼ æ¥­å‹™</option>
                            <option value="ãƒŸãƒ¼ãƒ†ã‚£ãƒ³ã‚°">ğŸ¤ ãƒŸãƒ¼ãƒ†ã‚£ãƒ³ã‚°</option>
                            <option value="ãã®ä»–">ğŸ“ ãã®ä»–</option>
                        </select>
                    </div>
                    
                    <div class="break-field" id="customBreakTitle" style="display: none;">
                        <label class="break-label">ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚¤ãƒˆãƒ«</label>
                        <input type="text" id="customBreakTitleInput" class="break-input" placeholder="ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚¤ãƒˆãƒ«ã‚’å…¥åŠ›">
                    </div>

                    <div class="break-field">
                        <label class="break-label">â° ä¼‘æ†©æ™‚é–“</label>
                        <select id="breakDuration" class="break-select" required>
                            <option value="">é¸æŠã—ã¦ãã ã•ã„</option>
                            <option value="15">15åˆ†</option>
                            <option value="30">30åˆ†</option>
                            <option value="45">45åˆ†</option>
                            <option value="60">1æ™‚é–“</option>
                            <option value="90">1æ™‚é–“30åˆ†</option>
                            <option value="120">2æ™‚é–“</option>
                            <option value="180">3æ™‚é–“</option>
                        </select>
                    </div>

                    <div class="break-field">
                        <label class="break-label">ğŸ“ ãƒ¡ãƒ¢</label>
                        <textarea id="breakNote" class="break-textarea" rows="2" placeholder="å¿…è¦ã«å¿œã˜ã¦ãƒ¡ãƒ¢ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„"></textarea>
                    </div>
                </div>
            </div>
            <div class="break-modal-footer">
                <button type="button" class="break-btn break-btn-create" onclick="createBreak()">â˜• ä¼‘æ†©ä½œæˆ</button>
                <button type="button" class="break-btn break-btn-cancel" onclick="closeBreakModal()">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
            </div>
        </div>
    </div>

    <!-- ä¼‘æ†©è©³ç´°ãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="breakDetailModal" class="break-detail-modal">
        <div class="break-detail-modal-content">
            <div class="break-detail-modal-header">
                <h2 id="breakDetailTitle">â˜• ä¼‘æ†©è©³ç´°</h2>
                <span class="break-detail-modal-close" onclick="closeBreakDetailModal()">&times;</span>
            </div>
            <div class="break-detail-modal-body">
                <div class="break-detail-info">
                    <div class="break-detail-datetime">
                        <span id="breakDetailDate"></span> <strong id="breakDetailTime"></strong>
                    </div>
                    <div class="break-detail-duration">
                        <span id="breakDetailDuration"></span>
                    </div>
                </div>

                <div class="break-detail-form">
                    <div class="break-detail-field">
                        <label class="break-detail-label">ğŸŠ ä¼‘æ†©ã‚¿ã‚¤ãƒˆãƒ«</label>
                        <select id="editBreakTitle" class="break-detail-select" onchange="handleEditBreakTitleChange()">
                            <option value="ä¼‘æ†©">â˜• ä¼‘æ†©</option>
                            <option value="æº–å‚™æ™‚é–“">âš™ï¸ æº–å‚™æ™‚é–“</option>
                            <option value="æ¥­å‹™">ğŸ’¼ æ¥­å‹™</option>
                            <option value="ãƒŸãƒ¼ãƒ†ã‚£ãƒ³ã‚°">ğŸ¤ ãƒŸãƒ¼ãƒ†ã‚£ãƒ³ã‚°</option>
                            <option value="ãã®ä»–">ğŸ“ ãã®ä»–</option>
                        </select>
                    </div>
                    
                    <div class="break-detail-field" id="editCustomBreakTitle" style="display: none;">
                        <label class="break-detail-label">ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚¤ãƒˆãƒ«</label>
                        <input type="text" id="editCustomBreakTitleInput" class="break-detail-input" placeholder="ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚¤ãƒˆãƒ«ã‚’å…¥åŠ›">
                    </div>

                    <div class="break-detail-field">
                        <label class="break-detail-label">â° ä¼‘æ†©æ™‚é–“</label>
                        <select id="editBreakDuration" class="break-detail-select">
                            <option value="15">15åˆ†</option>
                            <option value="30">30åˆ†</option>
                            <option value="45">45åˆ†</option>
                            <option value="60">1æ™‚é–“</option>
                            <option value="90">1æ™‚é–“30åˆ†</option>
                            <option value="120">2æ™‚é–“</option>
                            <option value="180">3æ™‚é–“</option>
                        </select>
                    </div>

                    <div class="break-detail-field">
                        <label class="break-detail-label">ğŸ“ ãƒ¡ãƒ¢</label>
                        <textarea id="editBreakNote" class="break-detail-textarea" rows="3" placeholder="å¿…è¦ã«å¿œã˜ã¦ãƒ¡ãƒ¢ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„"></textarea>
                    </div>
                </div>
            </div>
            <div class="break-detail-modal-footer">
                <button type="button" class="break-detail-btn break-detail-btn-save" onclick="saveBreakChanges()">ğŸ’¾ ä¿å­˜</button>
                <button type="button" class="break-detail-btn break-detail-btn-delete" onclick="deleteBreakReservation()">ğŸ—‘ï¸ å‰Šé™¤</button>
                <button type="button" class="break-detail-btn break-detail-btn-cancel" onclick="closeBreakDetailModal()">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
        </div>
        </div>
      </div>

    <!-- ä¸€æ‹¬äºˆç´„ä½œæˆãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="bulkReservationModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>ğŸ“… ä¸€æ‹¬äºˆç´„ä½œæˆ</h2>
                <span class="close" onclick="closeBulkReservationModal()">&times;</span>
            </div>
            <div class="modal-body">
                <form id="bulkReservationForm">
                    <div class="form-group mb-3">
                        <label for="bulkStartDate" class="form-label">é–‹å§‹æ—¥</label>
                        <input type="date" id="bulkStartDate" class="form-control" required>
                    </div>
                    
                    <div class="form-group mb-3">
                        <label for="bulkEndDate" class="form-label">çµ‚äº†æ—¥</label>
                        <input type="date" id="bulkEndDate" class="form-control" required>
                    </div>
                    
                    <div class="form-group mb-3">
                        <label for="bulkStartTime" class="form-label">é–‹å§‹æ™‚é–“</label>
                        <input type="time" id="bulkStartTime" class="form-control" required>
                    </div>
                    
                    <div class="form-group mb-3">
                        <label for="bulkDuration" class="form-label">ã‚³ãƒ¼ã‚¹é¸æŠ</label>
                        <select id="bulkDuration" class="form-select" required>
                            <option value="">ã‚³ãƒ¼ã‚¹ã‚’é¸æŠã—ã¦ãã ã•ã„</option>
                            <option value="40">40åˆ†ã‚³ãƒ¼ã‚¹</option>
                            <option value="60">60åˆ†ã‚³ãƒ¼ã‚¹</option>
                            <option value="80">80åˆ†ã‚³ãƒ¼ã‚¹</option>
                        </select>
                    </div>
                    
                    <div class="form-group mb-3">
                        <label for="bulkDaysOfWeek" class="form-label">å¯¾è±¡æ›œæ—¥</label>
                        <div class="checkbox-group" id="bulkDaysOfWeek">
                            <label class="checkbox-item">
                                <input type="checkbox" id="bulkDay0" value="0" checked> æ—¥
                            </label>
                            <label class="checkbox-item">
                                <input type="checkbox" id="bulkDay1" value="1" checked> æœˆ
                            </label>
                            <label class="checkbox-item">
                                <input type="checkbox" id="bulkDay2" value="2" checked> ç«
                            </label>
                            <label class="checkbox-item">
                                <input type="checkbox" id="bulkDay3" value="3" checked> æ°´
                            </label>
                            <label class="checkbox-item">
                                <input type="checkbox" id="bulkDay4" value="4" checked> æœ¨
                            </label>
                            <label class="checkbox-item">
                                <input type="checkbox" id="bulkDay5" value="5" checked> é‡‘
                            </label>
                            <label class="checkbox-item">
                                <input type="checkbox" id="bulkDay6" value="6" checked> åœŸ
                            </label>
                        </div>
                    </div>
                    
                    <div class="form-group mb-3">
                        <label for="bulkCustomerName" class="form-label">ãŠå®¢æ§˜å</label>
                        <div class="position-relative">
                            <input type="text" id="bulkCustomerName" class="form-control" required placeholder="å±±ç”°å¤ªéƒ" autocomplete="off">
                            <div id="bulkUserSearchResults" class="user-search-results" style="display: none;"></div>
                        </div>
                    </div>
                    
                    <div class="form-group mb-3">
                        <label for="bulkCustomerPhone" class="form-label">é›»è©±ç•ªå·</label>
                        <input type="tel" id="bulkCustomerPhone" class="form-control" required placeholder="090-1234-5678">
                    </div>
                    
                    <div class="form-group mb-3">
                        <label for="bulkCustomerEmail" class="form-label">ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹</label>
                        <input type="email" id="bulkCustomerEmail" class="form-control" placeholder="example@email.com">
                    </div>
                    
                    <div class="form-group mb-3">
                        <label for="bulkNote" class="form-label">å‚™è€ƒ</label>
                        <textarea id="bulkNote" class="form-control" rows="3" placeholder="ã”è¦æœ›ã‚„ã”è³ªå•ãŒã‚ã‚Œã°ã”è¨˜å…¥ãã ã•ã„"></textarea>
                    </div>
                    
                    <div class="form-group mb-3">
                        <label for="bulkStatus" class="form-label">äºˆç´„ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹</label>
                        <select id="bulkStatus" class="form-select">
                            <option value="tentative">ä»®äºˆç´„</option>
                            <option value="confirmed">ç¢ºå®š</option>
                        </select>
                    </div>
                    
                    <div class="bulk-preview mb-3">
                        <h4>ä½œæˆäºˆå®šã®äºˆç´„</h4>
                        <div id="bulkPreviewList" class="bulk-preview-list">
                            <!-- ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™ -->
                        </div>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeBulkReservationModal()">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                <button class="btn btn-info" onclick="previewBulkReservations()">ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</button>
                <button class="btn btn-success" id="submitBulkBtn" onclick="createBulkReservations()" disabled>ä¸€æ‹¬ä½œæˆ</button>
            </div>
        </div>
    </div>

     <!-- äºˆç´„è©³ç´°ãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="reservationDetailModal" class="modal">
        <div class="modal-content">
            <div class="modal-body" id="reservationDetailContent">
                <span class="close" onclick="closeReservationDetailModal()">&times;</span>
                <!-- å‹•çš„ã«ç”Ÿæˆã•ã‚Œã‚‹ -->
            </div>
            <div class="modal-footer">
                                 <button type="submit" class="btn btn-primary" form="reservationEditForm" onclick="console.log('ğŸ’¾ Save button clicked')">ä¿å­˜</button>
                 <button type="button" class="btn btn-warning" onclick="cancelReservationFromCalendar()">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                 <button type="button" class="btn btn-danger" onclick="deleteReservationFromCalendar()">å‰Šé™¤</button>
                 <button type="button" class="btn btn-secondary" onclick="closeReservationDetailModal()">é–‰ã˜ã‚‹</button>
            </div>
        </div>
    </div>
    <!-- ãƒ¦ãƒ¼ã‚¶ãƒ¼é¸æŠãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="userSelectionModal" class="modal">
        <div class="modal-content">
            <div class="modal-body">
                <span class="close" onclick="closeUserSelectionModal()">&times;</span>
                <h3>ãŠå®¢æ§˜ã®å¤‰æ›´</h3>
                <div class="user-selection-settings">
                    <div class="form-group">
                        <label for="userSearchInput" class="form-label">ãŠå®¢æ§˜ã‚’æ¤œç´¢ã—ã¦ãã ã•ã„</label>
                        <input type="text" id="userSearchInput" class="form-control" placeholder="ãŠå®¢æ§˜åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„..." autocomplete="off">
                    </div>
                    <div class="user-search-results" id="userSelectionSearchResults">
                        <!-- æ¤œç´¢çµæœãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™ -->
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" onclick="closeUserSelectionModal()">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                        <button class="btn btn-primary" onclick="return saveUserSelection()" id="saveUserBtn" disabled>å¤‰æ›´</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        (function() {
            // ä»Šæ—¥ã®é€±ã®é–‹å§‹æ—¥ï¼ˆæ—¥æ›œæ—¥ï¼‰ã‚’è¨ˆç®—
            let globalCurrentDate = new Date();
            let currentWeekStart = new Date(globalCurrentDate);
            currentWeekStart.setDate(globalCurrentDate.getDate() - globalCurrentDate.getDay()); // æ—¥æ›œæ—¥ã«è¨­å®š
            let weeklySchedules = {}; // é€±åˆ¥ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼ˆé€±ã®ã‚­ãƒ¼ã§ä¿å­˜ï¼‰
            let defaultSchedule = {}; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
            let reservations = {}; // äºˆç´„ãƒ‡ãƒ¼ã‚¿
            let miniCalendarMonth = new Date(globalCurrentDate.getFullYear(), globalCurrentDate.getMonth(), 1); // ãƒŸãƒ‹ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã®è¡¨ç¤ºæœˆï¼ˆç¾åœ¨ã®æœˆï¼‰
            let clickedDate = null; // ã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸæ—¥ä»˜
            let currentReservation = null; // ç¾åœ¨è¡¨ç¤ºä¸­ã®äºˆç´„
            let searchTimeout = null; // æ¤œç´¢ã®ãƒ‡ãƒã‚¦ãƒ³ã‚¹ç”¨
            let isEditingReservation = false; // äºˆç´„ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ãƒ•ãƒ©ã‚°
            let reservationToEdit = null; // ç·¨é›†å¯¾è±¡ã®äºˆç´„ãƒ‡ãƒ¼ã‚¿
            let cancelledReservations = []; // ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚ŒãŸäºˆç´„ã®ãƒªã‚¹ãƒˆ
            let cancellationDisplayReady = false; // ã‚­ãƒ£ãƒ³ã‚»ãƒ«è¡¨ç¤ºã®æº–å‚™å®Œäº†ãƒ•ãƒ©ã‚°
            let domReady = false; // DOMã®æº–å‚™å®Œäº†ãƒ•ãƒ©ã‚°

        // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‹ã‚‰ã‚­ãƒ£ãƒ³ã‚»ãƒ«å±¥æ­´ã‚’èª­ã¿è¾¼ã¿
        function loadCancelledReservations() {
            try {
                const stored = localStorage.getItem('cancelledReservations');
                if (stored) {
                    cancelledReservations = JSON.parse(stored);
        
                }
            } catch (error) {
                console.error('âŒ Error loading cancelled reservations:', error);
                cancelledReservations = [];
            }
        }

        // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ã‚­ãƒ£ãƒ³ã‚»ãƒ«å±¥æ­´ã‚’ä¿å­˜
        function saveCancelledReservations() {
            try {
                localStorage.setItem('cancelledReservations', JSON.stringify(cancelledReservations));
    
            } catch (error) {
                console.error('âŒ Error saving cancelled reservations:', error);
            }
        }
        
        // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‹ã‚‰äºˆç´„ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿
        <% if @reservations.present? %>
            console.log('ğŸ”„ Loading server-side reservations:', <%= @reservations.count %>);
            <% @reservations.each do |reservation| %>
                (function() {
                    const reservationDateKey = '<%= reservation.start_time.strftime('%Y-%m-%d') %>';
                    if (!reservations[reservationDateKey]) {
                        reservations[reservationDateKey] = [];
                    }
                    const reservationData = {
                        id: <%= reservation.id %>,
                        time: '<%= reservation.start_time.strftime('%H:%M') %>',
                        start_time: '<%= reservation.start_time.iso8601 %>', // Add start_time for validation
                        date: '<%= reservation.start_time.strftime('%Y-%m-%d') %>', // Add date for validation
                        duration: <%= extract_course_duration(reservation.course) %>,
                        customer: '<%= j(reservation.name || reservation.user&.name || 'æœªè¨­å®š') %>',
                        phone: '<%= j(reservation.user&.phone_number || '') %>',
                        email: '<%= j(reservation.user&.email || '') %>',
                        note: '<%= j(reservation.note || '') %>',
                        status: '<%= reservation.status %>',
                        is_break: false,
                        createdAt: '<%= reservation.created_at.iso8601 %>',
                        updatedAt: '<%= reservation.updated_at.iso8601 %>',
                        userId: <%= reservation.user_id || 'null' %>,
                        effective_interval_minutes: <%= reservation.effective_interval_minutes || 0 %>,
                        individual_interval_minutes: <%= reservation.individual_interval_minutes || 'null' %>
                    };
                    reservations[reservationDateKey].push(reservationData);
                    console.log('ğŸ“… Server-side reservation loaded:', {
                        date: reservationDateKey,
                        id: reservationData.id,
                        userId: reservationData.userId,
                        customer: reservationData.customer,
                        createdAt: reservationData.createdAt,
                        updatedAt: reservationData.updatedAt,
                        effective_interval_minutes: reservationData.effective_interval_minutes,
                        individual_interval_minutes: reservationData.individual_interval_minutes
                    });
                })();
            <% end %>
        <% else %>
            console.log('â„¹ï¸ No server-side reservations found');
        <% end %>
        
        // æ›œæ—¥ã®åå‰
        const dayNames = ['æ—¥', 'æœˆ', 'ç«', 'æ°´', 'æœ¨', 'é‡‘', 'åœŸ'];
        const dayNamesLong = ['æ—¥æ›œæ—¥', 'æœˆæ›œæ—¥', 'ç«æ›œæ—¥', 'æ°´æ›œæ—¥', 'æœ¨æ›œæ—¥', 'é‡‘æ›œæ—¥', 'åœŸæ›œæ—¥'];
        
        // æœˆã®åå‰
        const monthNames = ['1æœˆ', '2æœˆ', '3æœˆ', '4æœˆ', '5æœˆ', '6æœˆ', '7æœˆ', '8æœˆ', '9æœˆ', '10æœˆ', '11æœˆ', '12æœˆ'];
        
        // åˆæœŸåŒ–
        function init() {
            // ãƒ¢ãƒ¼ãƒ€ãƒ«å¤–ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹æ©Ÿèƒ½ã‚’è¨­å®š
            setupModalClickOutside();
            
            Promise.all([
                loadShiftSettingsFromBackend(),
                loadReservationsFromBackend()
            ]).then(() => {
                renderWeekView();
                renderDaySettings();
                renderMiniCalendar();
                showDragHint();
            });
        }

        // ãƒ‰ãƒ©ãƒƒã‚°ãƒ’ãƒ³ãƒˆã‚’è¡¨ç¤º
        function showDragHint() {
            // ãƒ’ãƒ³ãƒˆè¦ç´ ã‚’ä½œæˆ
            const hint = document.createElement('div');
            hint.className = 'drag-hint';
            hint.textContent = 'ğŸ’¡ äºˆç´„ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦æ™‚é–“ã‚’å¤‰æ›´ã§ãã¾ã™';
            document.body.appendChild(hint);
            
            // 3ç§’å¾Œã«è¡¨ç¤º
            setTimeout(() => {
                hint.classList.add('show');
            }, 1000);
            
            // 5ç§’å¾Œã«éè¡¨ç¤º
            setTimeout(() => {
                hint.classList.remove('show');
                setTimeout(() => {
                    if (hint.parentNode) {
                        hint.parentNode.removeChild(hint);
                    }
                }, 300);
            }, 5000);
        }

        // ãƒ¦ãƒ¼ã‚¶ãƒ¼æ¤œç´¢çµæœè¡¨ç¤ºé–¢æ•°
        function displayUserSearchResultsForModal(users) {
            console.log('ğŸ” displayUserSearchResultsForModal called with users:', users);
            const resultsContainer = document.getElementById('userSelectionSearchResults');
            
            if (!users || users.length === 0) {
                resultsContainer.innerHTML = '<div class="no-results">è©²å½“ã™ã‚‹ãŠå®¢æ§˜ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“</div>';
                resultsContainer.style.display = 'block';
                return;
            }
            
            const resultsHTML = users.map(user => `
                <div class="user-result-item" onclick="selectUserForModal({userId: ${user.id}, name: '${user.name}', phone: '${user.phone_number}', email: '${user.email}'})">
                    <div class="user-name">${user.name}</div>
                    <div class="user-details">${user.phone_number} | ${user.email}</div>
                </div>
            `).join('');
            
            resultsContainer.innerHTML = resultsHTML;
            resultsContainer.style.display = 'block';
            console.log('ğŸ” Search results displayed:', users.length, 'users');
        }

        // ãƒ¦ãƒ¼ã‚¶ãƒ¼é¸æŠé–¢æ•°
        function selectUserForModal(userData) {
            console.log('ğŸ” selectUserForModal called with:', userData);
            
            // Set the global selectedUser that the existing saveUserSelection function expects
            window.selectedUser = {
                id: userData.userId,
                name: userData.name,
                phone_number: userData.phone,
                email: userData.email
            };
            
            console.log('âœ… Set window.selectedUser:', window.selectedUser);
            
            // Hide search results and enable save button
            hideUserSearchResults();
            document.getElementById('saveUserBtn').disabled = false;
        }

        // ãƒ¦ãƒ¼ã‚¶ãƒ¼æ¤œç´¢çµæœã‚’éš ã™é–¢æ•°
        function hideUserSearchResults() {
            console.log('ğŸ” hideUserSearchResults called');
            const resultsContainer = document.getElementById('userSelectionSearchResults');
            resultsContainer.style.display = 'none';
            resultsContainer.innerHTML = '';
            console.log('ğŸ” Search results hidden and cleared');
        }

        function handleUserSearch(query) {
            console.log('ğŸ” handleUserSearch called with query:', query);
            
            if (query.length < 2) {
                console.log('ğŸ” Query too short, hiding results');
                hideUserSearchResults();
                return;
            }
            
            console.log('ğŸ” Setting timeout for search');
            clearTimeout(window.searchTimeout);
            window.searchTimeout = setTimeout(() => {
                console.log('ğŸ” Calling searchUsersForModal with:', query);
                searchUsersForModal(query);
            }, 300);
        }

        function searchUsersForModal(query) {
            console.log('ğŸ” searchUsersForModal called with query:', query);
            
            fetch(`/admin/users/search?q=${encodeURIComponent(query)}`)
                .then(response => {
                    console.log('ğŸ” Search response status:', response.status);
                    return response.json();
                })
                .then(data => {
                    console.log('ğŸ” Search response data:', data);
                    if (data.success) {
                        displayUserSearchResultsForModal(data.users);
                    }
                })
                .catch(error => {
                    console.error('âŒ Search error:', error);
                });
        }

        // äºˆç´„å¤‰æ›´ã‚’ä¿å­˜
        function saveReservationChanges(event) {
            if (event && event.preventDefault) {
            event.preventDefault();
            }
            
            if (!currentReservation) {
                showMessage('äºˆç´„ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚', 'error');
                return false;
            }

            // ãƒ•ã‚©ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            const courseSelect = document.getElementById('edit-course');
            const statusSelect = document.getElementById('edit-status');
            const noteTextarea = document.getElementById('edit-note');
            
            console.log('ğŸ“ Form elements found:', {
                courseSelect: courseSelect ? 'found' : 'not found',
                statusSelect: statusSelect ? 'found' : 'not found',
                noteTextarea: noteTextarea ? 'found' : 'not found'
            });
            
            const newCourse = courseSelect ? courseSelect.value : `${currentReservation.duration}åˆ†`;
            const newDuration = extractDurationFromCourse(newCourse);
            const currentInterval = currentReservation.effective_interval_minutes ?? 10;
            
            // å–¶æ¥­æ™‚é–“å†…ã«åã¾ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ - use proper validation object like other functions
            let reservationDate = currentReservation.date;
            if (!reservationDate) {
                // Fallback: search reservations object for this reservation's date
                console.log('ğŸ” Save validation fallback: searching reservations object for reservation ID:', currentReservation.id);
                for (const [dateKey, dayReservations] of Object.entries(reservations)) {
                    const foundReservation = dayReservations.find(r => r.id === currentReservation.id);
                    if (foundReservation) {
                        reservationDate = dateKey;
                        console.log('ğŸŸ© Found reservation date in save validation fallback:', reservationDate);
                        break;
                    }
                }
            }
            
            const validationReservation = {
                ...currentReservation,
                date: reservationDate,
                time: currentReservation.time || currentReservation.startTime
            };
            
            console.log('ğŸ” Save validation reservation object:', validationReservation);
            
            const businessHoursValidation = validateReservationTimeWithinBusinessHours(validationReservation, newDuration, currentInterval);
            if (!businessHoursValidation.valid) {
                showMessage(businessHoursValidation.message, 'error');
                return;
            }
            
            // é‡è¤‡ãƒã‚§ãƒƒã‚¯
            const overlapValidation = validateReservationOverlap(validationReservation, newDuration, currentInterval, currentReservation.id);
            if (!overlapValidation.valid) {
                showMessage(overlapValidation.message, 'error');
                return;
            }
            
            const formData = {
                reservation: {
                    course: newCourse,
                    status: statusSelect ? statusSelect.value : currentReservation.status,
                    note: noteTextarea ? noteTextarea.value : currentReservation.note || ''
                }
            };
            
            // ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã‚’é€ä¿¡
            if (currentReservation.userId) {
                formData.reservation.user_id = currentReservation.userId;
            }

            // å¿…è¦ãªå€¤ã‚’ä¿å­˜ã—ã¦ã‹ã‚‰ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
            const reservationId = currentReservation.id;
            const originalUserId = currentReservation.userId;
            const reservationForUpdates = { ...currentReservation }; // å®Œå…¨ãªã‚³ãƒ”ãƒ¼ã‚’ä¿å­˜
            
            // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’å³åº§ã«é–‰ã˜ã‚‹ï¼ˆãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãªæ„Ÿè¦šã®ãŸã‚ï¼‰
            showMessage('äºˆç´„ã‚’æ›´æ–°ä¸­...', 'info');
            closeReservationDetailModal();

            // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã«æ›´æ–°ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡
            const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');
            
            fetch(`/admin/reservations/${reservationId}/update_booking`, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-Token': csrfToken
                },
                body: JSON.stringify(formData)
            })
            .then(response => {
                console.log('ğŸ“¡ Response status:', response.status);
                console.log('ğŸ“¡ Response headers:', response.headers);
                
                if (!response.ok) {
                    // Try to get error details from response
                    return response.text().then(responseText => {
                        console.log('ğŸ“¡ Error response text:', responseText);
                        
                        let errorMessage = `HTTP error! status: ${response.status}`;
                        
                        // Try to parse as JSON for detailed error message
                        try {
                            const errorData = JSON.parse(responseText);
                            if (errorData.message) {
                                errorMessage += `, message: ${errorData.message}`;
                            }
                            if (errorData.errors) {
                                errorMessage += `, errors: ${JSON.stringify(errorData.errors)}`;
                            }
                        } catch (e) {
                            console.log('ğŸ“¡ Could not parse error response as JSON:', e);
                            // If it's not JSON, use the raw text if it's not too long
                            if (responseText && responseText.length < 200) {
                                errorMessage += `, response: ${responseText}`;
                            }
                        }
                        
                        throw new Error(errorMessage);
                    });
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    // ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°
                    const reservationData = data.reservation;
                    console.log('ğŸ” Backend response - reservationData.note:', reservationData.note);
                    console.log('ğŸ” reservationForUpdates before update:', reservationForUpdates);
                    
                    const updatedReservation = {
                        ...reservationForUpdates,
                        customer: reservationData.name || reservationData.user?.name || 'æœªè¨­å®š',
                        phone: reservationData.user?.phone_number || '',
                        email: reservationData.user?.email || '',
                        duration: extractDurationFromCourse(reservationData.course),
                        status: reservationData.status,
                        note: reservationData.note || '',
                        updatedAt: reservationData.updated_at,
                        userId: window.currentUserId || reservationForUpdates.userId // æ–°ã—ã„ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã‚’è¨­å®š
                    };
                    
                    console.log('ğŸ” updatedReservation.note after construction:', updatedReservation.note);
                    
                    // ã‚°ãƒ­ãƒ¼ãƒãƒ«reservationsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ›´æ–°
                    // Fix date key calculation - use the date field directly if available
                    let reservationDate;
                    if (reservationForUpdates.date) {
                        reservationDate = new Date(reservationForUpdates.date);
                    } else if (reservationForUpdates.start_time) {
                        reservationDate = new Date(reservationForUpdates.start_time);
                    } else {
                        // Fallback: find the date from global reservations object
                        for (const [dateKey, dayReservations] of Object.entries(reservations)) {
                            if (dayReservations.find(r => r.id === reservationId)) {
                                reservationDate = new Date(dateKey);
                                break;
                            }
                        }
                    }
                    
                    const reservationDateKey = reservationDate ? formatDateKey(reservationDate) : null;
                    console.log('ğŸ” Global update debug:', {
                        reservationId: reservationId,
                        reservationForUpdates_date: reservationForUpdates.date,
                        reservationForUpdates_start_time: reservationForUpdates.start_time,
                        reservationForUpdates_time: reservationForUpdates.time,
                        calculatedDate: reservationDate,
                        reservationDateKey: reservationDateKey,
                        hasDateKey: reservations[reservationDateKey] ? 'yes' : 'no',
                        availableKeys: Object.keys(reservations)
                    });
                    
                    if (reservations[reservationDateKey]) {
                        const reservationIndex = reservations[reservationDateKey].findIndex(r => r.id === reservationId);
                        console.log('ğŸ” Looking for reservation index:', reservationIndex, 'in array of length:', reservations[reservationDateKey].length);
                        if (reservationIndex !== -1) {
                            console.log('ğŸ”„ BEFORE - Global reservation note:', reservations[reservationDateKey][reservationIndex].note);
                            reservations[reservationDateKey][reservationIndex] = updatedReservation;
                            console.log('ğŸ”„ AFTER - Global reservation note:', reservations[reservationDateKey][reservationIndex].note);
                        } else {
                            console.log('âŒ Reservation not found in global object!');
                        }
                    } else {
                        console.log('âŒ Date key not found in global reservations object!');
                    }
                    
                    // ãƒ¢ãƒ¼ãƒ€ãƒ«å†…ã®å¤‰æ›´æ—¥æ™‚ã‚’æ›´æ–°
                    let updateTimestamp = reservationData.updated_at;
                    if (!updateTimestamp) {
                        // Backend doesn't provide updated_at, use current time
                        updateTimestamp = new Date().toISOString();
                        console.log('ğŸ” Backend missing updated_at, using current time:', updateTimestamp);
                    }
                    console.log('ğŸ” About to call updateModalUpdatedAt with:', updateTimestamp);
                    updateModalUpdatedAt(updateTimestamp);
                    
                    // ãƒ¢ãƒ¼ãƒ€ãƒ«å†…ã®ãƒ¡ãƒ¢ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æ›´æ–°
                    const noteElement = document.getElementById('edit-note');
                    if (noteElement && reservationData.note !== undefined) {
                        console.log('ğŸ”„ Before update - note element value:', noteElement.value);
                        console.log('ğŸ”„ Setting note field to:', reservationData.note);
                        noteElement.value = reservationData.note || '';
                        console.log('ğŸ”„ After update - note element value:', noteElement.value);
                        
                        // Force the textarea to reflect the new value
                        noteElement.defaultValue = reservationData.note || '';
                        
                        // Trigger input event to ensure any listeners are notified
                        noteElement.dispatchEvent(new Event('input', { bubbles: true }));
                    }
                    
                    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå¤‰æ›´ã•ã‚ŒãŸå ´åˆã€ãƒ¢ãƒ¼ãƒ€ãƒ«ã®ãƒã‚±ãƒƒãƒˆã¨å±¥æ­´ã‚’å†èª­ã¿è¾¼ã¿
                    console.log('ğŸ” User change check:', {
                        windowCurrentUserId: window.currentUserId,
                        originalUserId: originalUserId,
                        updatedReservationCustomer: updatedReservation.customer,
                        isUserChanged: window.currentUserId && window.currentUserId !== originalUserId
                    });
                    
                    if (window.currentUserId && window.currentUserId !== originalUserId) {
                        console.log('ğŸ”„ User changed, reloading modal data for new user:', window.currentUserId);
                        
                        // ãƒ¢ãƒ¼ãƒ€ãƒ«ã®é¡§å®¢åã‚’æ›´æ–°
                        const customerNameElement = document.querySelector('.customer-name-large');
                        console.log('ğŸ” Customer name element found:', customerNameElement);
                        if (customerNameElement) {
                            console.log('ğŸ”„ Updating customer name from:', customerNameElement.textContent, 'to:', updatedReservation.customer);
                            customerNameElement.textContent = updatedReservation.customer;
                            console.log('ğŸ”„ Updated customer name display to:', updatedReservation.customer);
                        } else {
                            console.error('âŒ Customer name element not found!');
                        }
                        
                        // ãƒã‚±ãƒƒãƒˆæƒ…å ±ã‚’å†èª­ã¿è¾¼ã¿
                        loadTicketsForUser(window.currentUserId);
                        
                        // å±¥æ­´æƒ…å ±ã‚’å†èª­ã¿è¾¼ã¿
                        loadReservationHistoryForUser(window.currentUserId);
                    } else {
                        console.log('ğŸ” No user change detected or window.currentUserId not set');
                    }
                    
                    // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚’å†æç”»
                    generateTimeSlots();
                    
                    showMessage('äºˆç´„ãŒæ›´æ–°ã•ã‚Œã¾ã—ãŸã€‚', 'success');
                } else {
                    showMessage(`äºˆç´„ã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ: ${data.message}`, 'error');
                }
            })
            .catch(error => {
                console.error('Error updating reservation:', error);
                showMessage('äºˆç´„ã®æ›´æ–°ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚', 'error');
                // ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚’å†æç”»ã—ã¦æœ€æ–°ã®çŠ¶æ…‹ã‚’è¡¨ç¤º
                generateTimeSlots();
            });
            
            return false; // Prevent any form submission
        }

        // ãƒ¢ãƒ¼ãƒ€ãƒ«å†…ã®å¤‰æ›´æ—¥æ™‚ã‚’å³åº§ã«æ›´æ–°
        function updateModalUpdatedAt(updatedAt) {
            console.log('ğŸ” updateModalUpdatedAt called with:', updatedAt);
            
            const modal = document.getElementById('reservationDetailModal');
            console.log('ğŸ” Modal found:', modal ? 'yes' : 'no');
            if (!modal) {
                console.log('âŒ Modal not found, cannot update change date');
                return;
            }
            
            const systemInfoSection = modal.querySelector('.system-info-section');
            console.log('ğŸ” System info section found:', systemInfoSection ? 'yes' : 'no');
            if (!systemInfoSection) {
                console.log('âŒ System info section not found, cannot update change date');
                // Let's try to find what sections do exist
                const allSections = modal.querySelectorAll('div[class*="section"], div[class*="info"]');
                console.log('ğŸ” Available sections in modal:', Array.from(allSections).map(s => s.className));
                return;
            }
            
            // æ—¢å­˜ã®å¤‰æ›´æ—¥æ™‚è¦ç´ ã‚’å‰Šé™¤
            const detailItems = systemInfoSection.querySelectorAll('.detail-item');
            detailItems.forEach(item => {
                const label = item.querySelector('.detail-label');
                if (label && label.textContent === 'å¤‰æ›´æ—¥æ™‚') {
                    item.remove();
                }
            });
            
            // ä½œæˆæ—¥æ™‚è¦ç´ ã‚’å–å¾—
            let createdAtItem = null;
            detailItems.forEach(item => {
                const label = item.querySelector('.detail-label');
                if (label && label.textContent === 'ä½œæˆæ—¥æ™‚') {
                    createdAtItem = item;
                }
            });
            
            if (!createdAtItem) return;
            
            // æ–°ã—ã„å¤‰æ›´æ—¥æ™‚è¦ç´ ã‚’ä½œæˆ
            const updatedAtItem = document.createElement('div');
            updatedAtItem.className = 'detail-item';
            updatedAtItem.innerHTML = `
                <span class="detail-label">å¤‰æ›´æ—¥æ™‚</span>
                <span class="detail-value">${new Date(updatedAt).toLocaleString('ja-JP')}</span>
            `;
            
            // ä½œæˆæ—¥æ™‚ã®å¾Œã«æŒ¿å…¥
            createdAtItem.insertAdjacentElement('afterend', updatedAtItem);
            console.log('âœ… Successfully added change date/time to modal');
        }

        // Add event listener to course dropdown to update change time immediately
        document.addEventListener('DOMContentLoaded', function() {
            // Add event listener for course changes
            document.addEventListener('change', function(event) {
                if (event.target && event.target.id === 'edit-course') {
                    console.log('ğŸ” Course dropdown changed, updating change time');
                    const currentTime = new Date().toISOString();
                    updateModalUpdatedAt(currentTime);
                }
            });
        });

        // Fixed updateIntervalOnChange function for calendar.html.erb
        // Replace the existing updateIntervalOnChange function around line 703 with this version

        function updateIntervalOnChange() {
            if (!currentReservation) {
                showMessage('äºˆç´„ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚', 'error');
                return;
            }

            const newInterval = parseInt(document.getElementById('edit-interval').value);
            const currentDuration = currentReservation.duration || 60;
            
            console.log('ğŸ” updateIntervalOnChange called with:', {
                newInterval,
                currentDuration,
                currentReservation
            });
            
            console.log('ğŸ” DEBUG: Full currentReservation object:', JSON.stringify(currentReservation, null, 2));

            // Extract time and date from the current reservation - this is the key fix
            let startTime;
            let reservationDate;
            
            // Try multiple ways to get the start time
            if (currentReservation.time) {
                startTime = currentReservation.time;
            } else if (currentReservation.startTime) {
                startTime = currentReservation.startTime;
            } else {
                // Try to get from form fields as fallback
                startTime = document.getElementById('reservationTime')?.value;
            }
            
            // Try multiple ways to get the date
            if (currentReservation.date) {
                reservationDate = currentReservation.date;
            } else if (currentReservation.reservationDate) {
                reservationDate = currentReservation.reservationDate;
            } else {
                // Try to get from form fields as fallback
                reservationDate = document.getElementById('reservationDate')?.value;
            }
            
            // If we still don't have date, try to extract from any available datetime
            if (!reservationDate && currentReservation.start_time) {
                try {
                    const startDateTime = new Date(currentReservation.start_time);
                    const year = startDateTime.getFullYear();
                    const month = String(startDateTime.getMonth() + 1).padStart(2, '0');
                    const day = String(startDateTime.getDate()).padStart(2, '0');
                    reservationDate = `${year}-${month}-${day}`;
                } catch (e) {
                    console.error('âŒ Error parsing start_time:', e);
                }
            }
            
            // Final fallback: search through reservations object to find the date key
            if (!reservationDate && currentReservation.id) {
                console.log('ğŸ” Final fallback: searching reservations object for reservation ID:', currentReservation.id);
                for (const dateKey of Object.keys(reservations)) {
                    const dayReservations = reservations[dateKey];
                    if (dayReservations && dayReservations.find(r => r.id === currentReservation.id)) {
                        reservationDate = dateKey;
                        console.log('ğŸŸ© Found reservation date in fallback:', dateKey);
                        break;
                    }
                }
            }
            
            console.log('ğŸ” Interval change attempt:', {
                newInterval,
                currentDuration,
                currentReservation,
                startTime,
                date: reservationDate,
                extractedStartTime: startTime,
                extractedDate: reservationDate
            });

            // Validation - ensure we have required data
            if (!startTime || !reservationDate) {
                console.error('âŒ Missing required data for validation:', { startTime, reservationDate });
                showMessage('äºˆç´„ã®æ™‚é–“ãƒ»æ—¥ä»˜æƒ…å ±ãŒå–å¾—ã§ãã¾ã›ã‚“', 'warning');
                return;
            }

            console.log('ğŸ” About to call business hours validation with:', {
                reservation: {
                    date: reservationDate,
                    time: startTime,
                    start_time: currentReservation.start_time
                },
                duration: currentDuration,
                interval: newInterval
            });

            // Create a properly structured reservation object for validation
            const validationReservation = {
                date: reservationDate,
                time: startTime,
                start_time: currentReservation.start_time
            };

            const validation = validateReservationTimeWithinBusinessHours(
                validationReservation,
                currentDuration,
                newInterval
            );

            console.log('ğŸ” Interval change business hours validation result:', validation);

            if (!validation.valid) {
                console.log('âŒ Business hours validation failed, showing error and returning');
                showMessage(validation.message, 'error');
                // å…ƒã®å€¤ã«æˆ»ã™
                const intervalSelect = document.getElementById('edit-interval');
                intervalSelect.value = currentReservation.effective_interval_minutes ?? 10;
                return;
            }
            
            // é‡è¤‡ãƒã‚§ãƒƒã‚¯
            console.log('ğŸ” About to call overlap validation with:', {
                reservation: validationReservation,
                duration: currentDuration,
                interval: newInterval
            });
            const overlapValidation = validateReservationOverlap(validationReservation, currentDuration, newInterval, currentReservation.id);
            console.log('ğŸ” Interval change overlap validation result:', overlapValidation);
            if (!overlapValidation.valid) {
                showMessage(overlapValidation.message, 'error');
                // å…ƒã®å€¤ã«æˆ»ã™
                const intervalSelect = document.getElementById('edit-interval');
                intervalSelect.value = currentReservation.effective_interval_minutes ?? 10;
                return;
            }

            console.log('âœ… Interval change validation passed');

            const reservationId = currentReservation.id;

            // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã«æ›´æ–°ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡
            const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');
            
            const requestBody = {
                reservation: {
                individual_interval_minutes: newInterval
                }
            };
            console.log('ğŸ” Sending interval update request:', {
                reservationId,
                newInterval,
                requestBody
            });
            
            fetch(`/admin/reservations/${reservationId}/update_interval`, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-Token': csrfToken
                },
                body: JSON.stringify(requestBody)
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                console.log('ğŸ” Backend response for interval update:', data);
                if (data.success) {
                    // ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°
                    currentReservation.effective_interval_minutes = newInterval;
                    currentReservation.individual_interval_minutes = newInterval;
                    console.log('ğŸ” Updated currentReservation:', currentReservation);
                    
                    // updatedAtãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æ›´æ–°
                    let updateTimestamp = data.updated_at;
                    if (!updateTimestamp) {
                        // Backend doesn't provide updated_at, use current time
                        updateTimestamp = new Date().toISOString();
                        console.log('ğŸ” Interval update: Backend missing updated_at, using current time:', updateTimestamp);
                    }
                    currentReservation.updatedAt = updateTimestamp;
                    // ãƒ¢ãƒ¼ãƒ€ãƒ«å†…ã®å¤‰æ›´æ—¥æ™‚ã‚’æ›´æ–°
                    console.log('ğŸ” Interval update: About to call updateModalUpdatedAt with:', updateTimestamp);
                    updateModalUpdatedAt(updateTimestamp);
                        
                                            // ã‚°ãƒ­ãƒ¼ãƒãƒ«reservationsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚‚æ›´æ–°
                    const reservationDateKey = currentReservation.date || formatDateKey(new Date(currentReservation.start_time || currentReservation.time));
                    if (reservations[reservationDateKey]) {
                        const reservationIndex = reservations[reservationDateKey].findIndex(r => r.id === currentReservation.id);
                        if (reservationIndex !== -1) {
                            reservations[reservationDateKey][reservationIndex].updatedAt = updateTimestamp;
                            reservations[reservationDateKey][reservationIndex].effective_interval_minutes = newInterval;
                            reservations[reservationDateKey][reservationIndex].individual_interval_minutes = newInterval;
                            console.log('ğŸ” Updated local reservation data:', reservations[reservationDateKey][reservationIndex]);
                        }
                    }
                    
                    // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚’å†æç”»
                    generateTimeSlots();
                    
                    showMessage('æº–å‚™æ™‚é–“ãŒæ›´æ–°ã•ã‚Œã¾ã—ãŸã€‚', 'success');
                } else {
                    showMessage(`æº–å‚™æ™‚é–“ã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ: ${data.message}`, 'error');
                }
            })
            .catch(error => {
                console.error('Error updating interval:', error);
                showMessage('æº–å‚™æ™‚é–“ã®æ›´æ–°ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚', 'error');
            });
        }

        // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å¤‰æ›´æ™‚ã«ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚’å³åº§ã«æ›´æ–°
        function updateCalendarOnStatusChange() {
            if (!currentReservation) {
                return;
            }

            const newStatus = document.getElementById('edit-status').value;
            
            // ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°
            currentReservation.status = newStatus;
            
            // ã‚°ãƒ­ãƒ¼ãƒãƒ«reservationsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚‚æ›´æ–°
            const reservationDateKey = formatDateKey(new Date(currentReservation.start_time || currentReservation.time));
            if (reservations[reservationDateKey]) {
                const reservationIndex = reservations[reservationDateKey].findIndex(r => r.id === currentReservation.id);
                if (reservationIndex !== -1) {
                    reservations[reservationDateKey][reservationIndex].status = newStatus;
                }
            }
            
            // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚’å†æç”»
            generateTimeSlots();
        }

        // äºˆç´„æ™‚é–“ãŒå–¶æ¥­æ™‚é–“å†…ã«åã¾ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        // Also update the validateReservationTimeWithinBusinessHours function
        function validateReservationTimeWithinBusinessHours(reservation, newDuration, newInterval) {
            console.log('ğŸ” validateReservationTimeWithinBusinessHours called with:', {
                reservation,
                newDuration,
                newInterval
            });

            // Extract date - improved logic
            let dateToCheck = reservation.date;
            
            // If no date field, try to extract from start_time
            if (!dateToCheck && reservation.start_time) {
                try {
                    const startDateTime = new Date(reservation.start_time);
                    const year = startDateTime.getFullYear();
                    const month = String(startDateTime.getMonth() + 1).padStart(2, '0');
                    const day = String(startDateTime.getDate()).padStart(2, '0');
                    dateToCheck = `${year}-${month}-${day}`;
                } catch (e) {
                    console.error('âŒ Error parsing start_time for date:', e);
                }
            }

            // Extract start time
            let startTime = reservation.time;
            if (!startTime && reservation.start_time) {
                try {
                    const startDateTime = new Date(reservation.start_time);
                    startTime = startDateTime.toTimeString().substring(0, 5);
                } catch (e) {
                    console.error('âŒ Error parsing start_time for time:', e);
                }
            }
            
            console.log('ğŸ” Date calculation debug:', {
                start_time: reservation.start_time,
                date: reservation.date,
                dateKey: dateToCheck,
                reservationDate: reservation.start_time,
                extractedDate: dateToCheck,
                extractedStartTime: startTime
            });

            // Validation - check we have the required data
            if (!dateToCheck || !startTime) {
                console.error('âŒ Missing date or time for validation:', { dateToCheck, startTime });
                return { valid: false, message: 'äºˆç´„ã®æ—¥æ™‚æƒ…å ±ãŒä¸æ­£ã§ã™' };
            }

            // Calculate day of week correctly using the extracted date
            const reservationDate = new Date(dateToCheck + 'T00:00:00'); // Force local timezone interpretation
            const dayOfWeek = reservationDate.getDay(); // 0 = Sunday, 1 = Monday, etc.

            // Convert start time to minutes
            const [hours, minutes] = startTime.split(':').map(Number);
            const startTimeInMinutes = hours * 60 + minutes;
            const totalDuration = newDuration + newInterval;
            const endTimeInMinutes = startTimeInMinutes + totalDuration;
            
            const endHours = Math.floor(endTimeInMinutes / 60);
            const endMins = endTimeInMinutes % 60;
            const endTimeStr = `${String(endHours).padStart(2, '0')}:${String(endMins).padStart(2, '0')}`;
            
            console.log('ğŸ” Validation debug:', {
                startTime,
                startTimeInMinutes,
                totalDuration,
                endTimeInMinutes,
                endTimeStr,
                dayOfWeek,
                dayName: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][dayOfWeek],
                dateToCheck,
                reservationDate: reservationDate.toDateString()
            });

            // Check using your existing custom schedule logic
            const customScheduleDate = '2025-08-10'; // Your reference date for custom schedule
            
            // Check start time is within business hours
            const isStartTimeValid = isBusinessHourForCustomSchedule(dayOfWeek, startTimeInMinutes, customScheduleDate);
            console.log('ğŸ” Business hours check for start time:', {
                dayOfWeek,
                startTime,
                startTimeInMinutes,
                isValid: isStartTimeValid
            });
            
            if (!isStartTimeValid) {
                const message = `äºˆç´„é–‹å§‹æ™‚é–“ãŒå–¶æ¥­æ™‚é–“å¤–ï¼ˆ${startTime}ï¼‰ã®ãŸã‚ã€ã“ã®è¨­å®šã¯ã§ãã¾ã›ã‚“ã€‚`;
                console.log('âŒ Start time validation failed:', startTime, 'dayOfWeek:', dayOfWeek);
                return { valid: false, message };
            }
            
            // Check end time is within business hours - allow ending exactly at closing time
            const isEndTimeValid = isBusinessHourForEndTime(dayOfWeek, endTimeInMinutes, customScheduleDate);
            console.log('ğŸ” Business hours check for end time:', {
                dayOfWeek,
                endTimeStr,
                endTimeInMinutes,
                isValid: isEndTimeValid
            });
            
            if (!isEndTimeValid) {
                const message = `äºˆç´„çµ‚äº†æ™‚é–“ãŒå–¶æ¥­æ™‚é–“å¤–ï¼ˆ${endTimeStr}ï¼‰ã«åŠã¶ãŸã‚ã€ã“ã®è¨­å®šã¯ã§ãã¾ã›ã‚“ã€‚`;
                console.log('âŒ End time validation failed:', endTimeStr, 'dayOfWeek:', dayOfWeek);
                return { valid: false, message };
            }
            
            console.log('âœ… Validation passed');
            return { valid: true };
        }

        // å®šæœŸçš„ãªã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«å¤‰æ›´ãŒæ—¢å­˜äºˆç´„ã«ä¸ãˆã‚‹å½±éŸ¿ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆéåŒæœŸã§å…¨äºˆç´„ã‚’ãƒã‚§ãƒƒã‚¯ï¼‰
        async function checkRecurringScheduleImpact(dayOfWeek, newStartTime, newEndTime) {
            const affectedReservations = [];
            
            console.log('ğŸ” Checking recurring schedule impact:', {
                dayOfWeek,
                newStartTime,
                newEndTime,
                dayName: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][dayOfWeek]
            });
            
            try {
                // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‹ã‚‰è©²å½“æ›œæ—¥ã®å…¨äºˆç´„ã‚’å–å¾—
                const response = await fetch(`/admin/reservations/by_day_of_week?day_of_week=${dayOfWeek}&from_date=${new Date().toISOString().split('T')[0]}`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]')?.getAttribute('content')
                    }
                });
                
                if (response.ok) {
                    const allReservations = await response.json();
                    console.log(`ğŸ” Retrieved ${allReservations.length} future reservations for ${['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][dayOfWeek]}`);
                    
                    // å–å¾—ã—ãŸäºˆç´„ã‚’ãƒã‚§ãƒƒã‚¯
                    for (const reservation of allReservations) {
                        const reservationTime = reservation.time;
                        const duration = reservation.duration || 60;
                        const interval = reservation.effective_interval_minutes || 10;
                        
                        // äºˆç´„ã®é–‹å§‹æ™‚é–“ã¨çµ‚äº†æ™‚é–“ã‚’è¨ˆç®—
                        const [startHour, startMin] = reservationTime.split(':').map(Number);
                        const startTimeInMinutes = startHour * 60 + startMin;
                        const endTimeInMinutes = startTimeInMinutes + duration + interval;
                        
                        // æ–°ã—ã„å–¶æ¥­æ™‚é–“ã¨æ¯”è¼ƒ
                        const [newStartHour, newStartMin] = newStartTime.split(':').map(Number);
                        const [newEndHour, newEndMin] = newEndTime.split(':').map(Number);
                        const newStartInMinutes = newStartHour * 60 + newStartMin;
                        const newEndInMinutes = newEndHour * 60 + newEndMin;
                        
                        // äºˆç´„ãŒæ–°ã—ã„å–¶æ¥­æ™‚é–“å¤–ã«ãªã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                        if (startTimeInMinutes < newStartInMinutes || endTimeInMinutes > newEndInMinutes) {
                            affectedReservations.push({
                                ...reservation,
                                endTime: `${Math.floor(endTimeInMinutes / 60).toString().padStart(2, '0')}:${(endTimeInMinutes % 60).toString().padStart(2, '0')}`
                            });
                            
                            console.log('âš ï¸ Found affected reservation:', {
                                id: reservation.id,
                                customer: reservation.customer,
                                date: reservation.date,
                                time: reservationTime,
                                duration,
                                interval,
                                calculatedEndTime: `${Math.floor(endTimeInMinutes / 60).toString().padStart(2, '0')}:${(endTimeInMinutes % 60).toString().padStart(2, '0')}`,
                                newBusinessHours: `${newStartTime} - ${newEndTime}`,
                                reason: startTimeInMinutes < newStartInMinutes ? 'starts before business hours' : 'ends after business hours'
                            });
                        }
                    }
                } else {
                    console.error('âŒ Failed to fetch reservations for validation');
                    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ç¾åœ¨ã®reservationsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã¿ãƒã‚§ãƒƒã‚¯
                    return checkRecurringScheduleImpactLocal(dayOfWeek, newStartTime, newEndTime);
                }
            } catch (error) {
                console.error('âŒ Error fetching reservations for validation:', error);
                // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ç¾åœ¨ã®reservationsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã¿ãƒã‚§ãƒƒã‚¯
                return checkRecurringScheduleImpactLocal(dayOfWeek, newStartTime, newEndTime);
            }
            
            console.log(`ğŸ” Found ${affectedReservations.length} affected reservations for ${['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][dayOfWeek]}`);
            return affectedReservations;
        }

        // ç¾åœ¨ã®é€±ã®ç‰¹å®šã®æ›œæ—¥ã®äºˆç´„ã‚’ãƒã‚§ãƒƒã‚¯
        function checkCurrentWeekReservationsForDay(dayOfWeek) {
            const affectedReservations = [];
            
            console.log('ğŸ” Checking current week reservations for day:', {
                dayOfWeek,
                dayName: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][dayOfWeek],
                allReservationDates: Object.keys(reservations),
                currentWeekStart: currentWeekStart
            });
            
            // ç¾åœ¨ã®é€±ã®è©²å½“æ›œæ—¥ã®æ—¥ä»˜ã‚’è¨ˆç®—
            const weekStart = new Date(currentWeekStart);
            const targetDate = new Date(weekStart);
            targetDate.setDate(weekStart.getDate() + dayOfWeek);
            
            // UTCã§ã¯ãªããƒ­ãƒ¼ã‚«ãƒ«æ—¥ä»˜ã‚’ä½¿ç”¨ã—ã¦ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³ã®å•é¡Œã‚’å›é¿
            const year = targetDate.getFullYear();
            const month = String(targetDate.getMonth() + 1).padStart(2, '0');
            const day = String(targetDate.getDate()).padStart(2, '0');
            const dateKey = `${year}-${month}-${day}`;
            
            console.log('ğŸ” Checking for reservations on date:', dateKey);
            console.log('ğŸ” Date calculation details:', {
                weekStartStr: currentWeekStart,
                weekStartDateLocal: `${weekStart.getFullYear()}-${String(weekStart.getMonth() + 1).padStart(2, '0')}-${String(weekStart.getDate()).padStart(2, '0')}`,
                dayOfWeek,
                targetDateStr: dateKey,
                targetDateObj: targetDate,
                availableReservationDates: Object.keys(reservations)
            });
            
            // è©²å½“æ—¥ã®äºˆç´„ã‚’ãƒã‚§ãƒƒã‚¯
            if (reservations[dateKey]) {
                const dayReservations = reservations[dateKey];
                console.log(`ğŸ” Found ${dayReservations.length} reservations on ${dateKey}`);
                
                for (const reservation of dayReservations) {
                    affectedReservations.push({
                        id: reservation.id,
                        customer: reservation.customer || reservation.name || 'æœªè¨­å®š',
                        date: dateKey,
                        time: reservation.time || reservation.start_time?.split('T')[1]?.substring(0, 5) || 'æ™‚é–“ä¸æ˜'
                    });
                }
            }
            
            console.log('ğŸ” Total affected reservations for day toggle:', affectedReservations.length);
            return affectedReservations;
        }

        // ãƒ­ãƒ¼ã‚«ãƒ«reservationsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã¿ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹é–¢æ•°ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
        function checkRecurringScheduleImpactLocal(dayOfWeek, newStartTime, newEndTime) {
            const affectedReservations = [];
            
            // ç¾åœ¨è¡¨ç¤ºä¸­ã®äºˆç´„ã®ã¿ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆå…ƒã®ãƒ­ã‚¸ãƒƒã‚¯ï¼‰
            for (const [dateKey, dayReservations] of Object.entries(reservations)) {
                const date = new Date(dateKey + 'T00:00:00');
                const reservationDayOfWeek = date.getDay();
                
                if (reservationDayOfWeek === dayOfWeek) {
                    for (const reservation of dayReservations) {
                        const reservationTime = reservation.time;
                        const duration = reservation.duration || 60;
                        const interval = reservation.effective_interval_minutes || 10;
                        
                        const [startHour, startMin] = reservationTime.split(':').map(Number);
                        const startTimeInMinutes = startHour * 60 + startMin;
                        const endTimeInMinutes = startTimeInMinutes + duration + interval;
                        
                        const [newStartHour, newStartMin] = newStartTime.split(':').map(Number);
                        const [newEndHour, newEndMin] = newEndTime.split(':').map(Number);
                        const newStartInMinutes = newStartHour * 60 + newStartMin;
                        const newEndInMinutes = newEndHour * 60 + newEndMin;
                        
                        if (startTimeInMinutes < newStartInMinutes || endTimeInMinutes > newEndInMinutes) {
                            affectedReservations.push({
                                ...reservation,
                                date: dateKey,
                                endTime: `${Math.floor(endTimeInMinutes / 60).toString().padStart(2, '0')}:${(endTimeInMinutes % 60).toString().padStart(2, '0')}`
                            });
                        }
                    }
                }
            }
            
            return affectedReservations;
        }

        // Helper function that integrates with your existing custom schedule logic
        function isBusinessHourForCustomSchedule(dayOfWeek, timeInMinutes, customScheduleDate) {
            // Convert minutes back to time string for existing isBusinessHour function
            const hour = Math.floor(timeInMinutes / 60);
            const minute = timeInMinutes % 60;
            const timeStr = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
            
            console.log('ğŸ” Checking business hour with existing function:', {
                dayOfWeek,
                timeStr,
                timeInMinutes
            });
            
            // Use your existing isBusinessHour function if available
            if (typeof isBusinessHour === 'function') {
                const result = isBusinessHour(dayOfWeek, timeStr);
                console.log('ğŸ” Existing isBusinessHour result:', result);
                return result;
            }
            
            // Fallback: basic business hours check
            console.log('ğŸ” Using fallback business hours (9:00-18:00)');
            const businessStart = 9 * 60;  // 9:00 in minutes  
            const businessEnd = 18 * 60;   // 18:00 in minutes
            
            // Sunday check
            if (dayOfWeek === 0) {
                return false; // Sunday closed
            }
            
            return timeInMinutes >= businessStart && timeInMinutes < businessEnd;
        }

        // Business hour check for end times - allows ending exactly at closing time
        function isBusinessHourForEndTime(dayOfWeek, timeInMinutes, customScheduleDate) {
            // Convert minutes back to time string for existing isBusinessHour function
            const hour = Math.floor(timeInMinutes / 60);
            const minute = timeInMinutes % 60;
            const timeStr = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
            
            console.log('ğŸ” Checking business hour for END TIME with existing function:', {
                dayOfWeek,
                timeStr,
                timeInMinutes
            });
            
            // Use your existing isBusinessHour function if available
            if (typeof isBusinessHour === 'function') {
                // First check if it's within regular business hours
                const isWithinBusinessHours = isBusinessHour(dayOfWeek, timeStr);
                
                console.log('ğŸ” Existing isBusinessHour result for end time:', isWithinBusinessHours);
                
                // If within business hours, allow it
                if (isWithinBusinessHours) {
                    return true;
                }
                
                // If not within regular business hours, check common closing times
                // This is a simplified approach - check if it's exactly at common closing times
                const commonClosingTimes = [
                    17 * 60,  // 17:00
                    18 * 60,  // 18:00
                    19 * 60,  // 19:00
                    20 * 60,  // 20:00
                    21 * 60,  // 21:00
                    22 * 60   // 22:00
                ];
                
                const isAtClosingTime = commonClosingTimes.includes(timeInMinutes);
                console.log('ğŸ” Checking if end time is at common closing time:', {
                    endTimeInMinutes: timeInMinutes,
                    timeStr,
                    isAtClosingTime
                });
                
                if (isAtClosingTime) {
                    console.log('âœ… End time is at common closing time - allowing');
                    return true;
                }
                
                return false;
            }
            
            // Fallback: basic business hours check with closing time allowance
            console.log('ğŸ” Using fallback business hours for end time (9:00-18:00, allowing 18:00)');
            const businessStart = 9 * 60;  // 9:00 in minutes  
            const businessEnd = 18 * 60;   // 18:00 in minutes
            
            // Sunday check
            if (dayOfWeek === 0) {
                return false; // Sunday closed
            }
            
            // Allow ending exactly at closing time (note: <= instead of <)
            return timeInMinutes >= businessStart && timeInMinutes <= businessEnd;
        }

        // äºˆç´„ã®é‡è¤‡ãƒã‚§ãƒƒã‚¯
        function validateReservationOverlap(reservation, newDuration, newInterval, excludeReservationId = null) {
            if (!reservation) return { valid: false, message: 'äºˆç´„ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚' };
            
            // äºˆç´„ã®é–‹å§‹æ™‚é–“ã‚’å–å¾—
            let startTime;
            let dateKey;
            
            // å„ªå…ˆé †ä½: start_time > dateKey > date > time
            if (reservation.start_time) {
                const dateTime = new Date(reservation.start_time);
                startTime = `${dateTime.getHours().toString().padStart(2, '0')}:${dateTime.getMinutes().toString().padStart(2, '0')}`;
                dateKey = formatDateKey(dateTime);
            } else if (reservation.dateKey) {
                startTime = reservation.time;
                dateKey = reservation.dateKey;
            } else if (reservation.date && reservation.time) {
                startTime = reservation.time;
                dateKey = reservation.date;
            } else if (reservation.time) {
                startTime = reservation.time;
                // ç¾åœ¨ã®é€±ã®é–‹å§‹æ—¥ã‚’ä½¿ç”¨
                const reservationDate = new Date(currentWeekStart);
                dateKey = formatDateKey(reservationDate);
            } else {
                return { valid: false, message: 'äºˆç´„ã®é–‹å§‹æ™‚é–“ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚' };
            }
            
            const [startHour, startMin] = startTime.split(':').map(Number);
            const startTimeInMinutes = startHour * 60 + startMin;
            const totalDuration = newDuration + newInterval;
            const endTimeInMinutes = startTimeInMinutes + totalDuration;
            
            // æŒ‡å®šæ—¥ã®äºˆç´„ã‚’å–å¾—ï¼ˆè‡ªåˆ†ä»¥å¤–ï¼‰
            const dayReservations = reservations[dateKey] || [];
            
            console.log('ğŸ” Overlap validation debug:', {
                dateKey,
                startTime,
                startTimeInMinutes,
                totalDuration,
                endTimeInMinutes,
                reservationId: reservation.id,
                dayReservations: dayReservations.length,
                reservationData: {
                    start_time: reservation.start_time,
                    dateKey: reservation.dateKey,
                    date: reservation.date,
                    time: reservation.time
                }
            });
            
            // é‡è¤‡ãƒã‚§ãƒƒã‚¯ï¼ˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«æ™‚é–“ã‚‚å«ã‚€ï¼‰
            for (const existingReservation of dayReservations) {
                if (existingReservation.id === reservation.id || existingReservation.id === excludeReservationId) {
                    console.log('â­ï¸ Skipping self or excluded reservation:', existingReservation.id);
                    continue; // è‡ªåˆ†ã¾ãŸã¯é™¤å¤–å¯¾è±¡ã¯é™¤å¤–
                }
                
                const existingStart = new Date(`${dateKey}T${existingReservation.time}`);
                const existingEnd = new Date(existingStart.getTime() + existingReservation.duration * 60 * 1000);
                
                // æ—¢å­˜äºˆç´„ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«æ™‚é–“ã‚’å–å¾—
                const existingIntervalMinutes = existingReservation.effective_interval_minutes ?? 10;
                const existingEndWithInterval = new Date(existingEnd.getTime() + existingIntervalMinutes * 60 * 1000);
                
                // æ–°ã—ã„äºˆç´„ã®çµ‚äº†æ™‚é–“
                const newEnd = new Date(`${dateKey}T${startTime}`);
                newEnd.setMinutes(newEnd.getMinutes() + totalDuration);
                
                console.log('ğŸ” Comparing with existing reservation:', {
                    existingId: existingReservation.id,
                    existingTime: `${existingReservation.time} - ${new Date(existingEndWithInterval).toTimeString().slice(0, 5)}`,
                    newTime: `${startTime} - ${newEnd.toTimeString().slice(0, 5)}`,
                    existingInterval: existingIntervalMinutes,
                    newInterval: newInterval
                });
                
                // é‡è¤‡åˆ¤å®šï¼ˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«æ™‚é–“ã‚‚å«ã‚€ï¼‰
                if (startTimeInMinutes < (existingEndWithInterval.getHours() * 60 + existingEndWithInterval.getMinutes()) && 
                    endTimeInMinutes > (existingStart.getHours() * 60 + existingStart.getMinutes())) {
                    console.log('ğŸš« Overlap detected with reservation:', existingReservation.id);
                    return { 
                        valid: false, 
                        message: `äºˆç´„æ™‚é–“ãŒæ—¢å­˜ã®äºˆç´„ï¼ˆ${existingReservation.customer}æ§˜ï¼‰ã¨é‡è¤‡ã™ã‚‹ãŸã‚ã€ã“ã®è¨­å®šã¯ã§ãã¾ã›ã‚“ã€‚` 
                    };
                }
            }
            
            console.log('âœ… No overlaps detected');
            return { valid: true, message: '' };
        }

        // ã‚³ãƒ¼ã‚¹å¤‰æ›´æ™‚ã«ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚’å³åº§ã«æ›´æ–°
        function updateCalendarOnCourseChange() {
            if (!currentReservation) return;
            
            const courseSelect = document.getElementById('edit-course');
            if (!courseSelect) return;
            
            const newCourse = courseSelect.value;
            const newDuration = parseInt(newCourse);
            const currentInterval = currentReservation.effective_interval_minutes ?? 10;
            
            console.log('ğŸ”„ Course changed to:', newCourse, 'Duration:', newDuration);
            
            // å–¶æ¥­æ™‚é–“å†…ã«åã¾ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            console.log('ğŸ” Validating course change for reservation:', currentReservation);
            
            // Extract proper date and time from reservation for validation (same logic as interval change)
            let startTime = currentReservation.time || currentReservation.startTime;
            let reservationDate = currentReservation.date || currentReservation.reservationDate;
            
            // Final fallback: search through reservations object to find the date key
            if (!reservationDate && currentReservation.id) {
                console.log('ğŸ” Course change fallback: searching reservations object for reservation ID:', currentReservation.id);
                for (const dateKey of Object.keys(reservations)) {
                    const dayReservations = reservations[dateKey];
                    if (dayReservations && dayReservations.find(r => r.id === currentReservation.id)) {
                        reservationDate = dateKey;
                        console.log('ğŸŸ© Found reservation date in course change fallback:', dateKey);
                        break;
                    }
                }
            }
            
            // Create properly structured reservation object for validation
            const validationReservation = {
                date: reservationDate,
                time: startTime,
                start_time: currentReservation.start_time
            };
            
            console.log('ğŸ” Course change validation reservation:', validationReservation);
            
            const businessHoursValidation = validateReservationTimeWithinBusinessHours(validationReservation, newDuration, currentInterval);
            console.log('ğŸ” Course change business hours validation result:', businessHoursValidation);
            if (!businessHoursValidation.valid) {
                showMessage(businessHoursValidation.message, 'error');
                // å…ƒã®å€¤ã«æˆ»ã™
                courseSelect.value = currentReservation.course || currentReservation.duration.toString();
                return;
            }
            
            // é‡è¤‡ãƒã‚§ãƒƒã‚¯ - use the same properly structured reservation object and exclude current reservation
            const overlapValidation = validateReservationOverlap(validationReservation, newDuration, currentInterval, currentReservation.id);
            console.log('ğŸ” Course change overlap validation result:', overlapValidation);
            if (!overlapValidation.valid) {
                showMessage(overlapValidation.message, 'error');
                // å…ƒã®å€¤ã«æˆ»ã™
                courseSelect.value = currentReservation.course || currentReservation.duration.toString();
                return;
            }
            
            // ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’å³åº§ã«æ›´æ–°ï¼ˆè­¦å‘ŠãŒã‚ã£ã¦ã‚‚æ›´æ–°ã™ã‚‹ï¼‰
            currentReservation.duration = newDuration;
            currentReservation.course = newCourse;
            
            // ã‚°ãƒ­ãƒ¼ãƒãƒ«reservationsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚‚æ›´æ–° - use the correct date
            const reservationDateKey = reservationDate; // Use the date we already found
            if (reservations[reservationDateKey]) {
                const reservationIndex = reservations[reservationDateKey].findIndex(r => r.id === currentReservation.id);
                if (reservationIndex !== -1) {
                    reservations[reservationDateKey][reservationIndex].duration = newDuration;
                    reservations[reservationDateKey][reservationIndex].course = newCourse;
                }
            }
            
            // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚’å³åº§ã«å†æç”»
            generateTimeSlots();
            
            console.log('âœ… Calendar updated immediately for course change');
        }



        // ãƒ¦ãƒ¼ã‚¶ãƒ¼é¸æŠãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
        function openUserSelectionModal() {
            console.log('ğŸ” openUserSelectionModal called');
            
            // æ¤œç´¢å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ã‚¯ãƒªã‚¢
            const searchInput = document.getElementById('userSearchInput');
            if (searchInput) {
                searchInput.value = '';
                console.log('ğŸ” Search input found and cleared');
            } else {
                console.error('âŒ Search input not found');
            }
            
            // æ¤œç´¢çµæœã‚’ã‚¯ãƒªã‚¢
            const searchResults = document.getElementById('userSelectionSearchResults');
            if (searchResults) {
                searchResults.innerHTML = '';
                searchResults.style.display = 'none';
                console.log('ğŸ” Search results cleared and hidden');
            } else {
                console.error('âŒ Search results container not found');
            }
            
            // ä¿å­˜ãƒœã‚¿ãƒ³ã‚’ç„¡åŠ¹åŒ–
            const saveBtn = document.getElementById('saveUserBtn');
            if (saveBtn) {
                saveBtn.disabled = true;
            }
            
            // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¨­å®š
            if (searchInput) {
                // æ—¢å­˜ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤
                searchInput.removeEventListener('input', handleUserSearch);
                
                // å…¥åŠ›ã‚¤ãƒ™ãƒ³ãƒˆ
                searchInput.addEventListener('input', handleUserSearch);
                console.log('ğŸ” Input event listener added');
                
                // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã‚¢ã‚¦ãƒˆæ™‚ã«çµæœã‚’éš ã™
                searchInput.addEventListener('blur', function() {
                    setTimeout(() => {
                        hideUserSearchResults();
                    }, 200);
                });
                
                // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹æ™‚ã«çµæœã‚’è¡¨ç¤ºï¼ˆå…¥åŠ›ãŒã‚ã‚‹å ´åˆï¼‰
                searchInput.addEventListener('focus', function() {
                    const query = this.value.trim();
                    if (query.length >= 2) {
                        searchUsersForModal(query);
                    }
                });
                
                searchInput.focus();
            }
            
            document.getElementById('userSelectionModal').style.display = 'block';
            console.log('ğŸ” Modal displayed');
            
            // Debug modal dimensions
            const modal = document.getElementById('userSelectionModal');
            const modalContent = modal.querySelector('.modal-content');
            console.log('ğŸ” Modal dimensions:', modal.offsetWidth, 'x', modal.offsetHeight);
            console.log('ğŸ” Modal content dimensions:', modalContent.offsetWidth, 'x', modalContent.offsetHeight);
        }

        // ãƒ¦ãƒ¼ã‚¶ãƒ¼æ¤œç´¢ã‚’å‡¦ç†
        function handleUserSearch(event) {
            const query = event.target.value.trim();
            console.log('ğŸ” handleUserSearch called with query:', query);
            
            // ãƒ‡ãƒã‚¦ãƒ³ã‚¹å‡¦ç†
            if (searchTimeout) {
                clearTimeout(searchTimeout);
            }
            
            if (query.length < 2) {
                console.log('ğŸ” Query too short, hiding results');
                hideUserSearchResults();
                return;
            }
            
            console.log('ğŸ” Setting timeout for search');
            searchTimeout = setTimeout(() => {
                console.log('ğŸ” Calling searchUsersForModal with:', query);
                searchUsersForModal(query);
            }, 300);
        }

        // ãƒ¢ãƒ¼ãƒ€ãƒ«ç”¨ãƒ¦ãƒ¼ã‚¶ãƒ¼æ¤œç´¢
        function searchUsersForModal(query) {
            console.log('ğŸ” searchUsersForModal called with query:', query);
            fetch(`/admin/reservations/search_users?query=${encodeURIComponent(query)}`)
                .then(response => {
                    console.log('ğŸ” Search response status:', response.status);
                    return response.json();
                })
                .then(data => {
                    console.log('ğŸ” Search response data:', data);
                    if (data.success) {
                        displayUserSearchResultsForModal(data.users);
                    } else {
                        console.error('âŒ User search failed:', data.message);
                        hideUserSearchResults();
                    }
                })
                .catch(error => {
                    console.error('âŒ Error searching users:', error);
                    hideUserSearchResults();
                });
        }

        // ãƒ¢ãƒ¼ãƒ€ãƒ«ç”¨æ¤œç´¢çµæœè¡¨ç¤º
        function displayUserSearchResultsForModal(users) {
            console.log('ğŸ” displayUserSearchResultsForModal called with users:', users);
            const searchResults = document.getElementById('userSelectionSearchResults');
            if (!searchResults) {
                console.error('âŒ Search results container not found');
                return;
            }
            
            if (users.length === 0) {
                searchResults.innerHTML = '<div class="user-search-item">è©²å½“ã™ã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“</div>';
                searchResults.style.display = 'block';
                console.log('ğŸ” No users found, showing message');
                return;
            }
            
            const resultsHtml = users.map(user => `
                <div class="user-search-item" onclick="selectUserForModal(${user.id}, '${user.name}', '${user.phone_number}', '${user.email}')">
                    <div class="user-name">${user.name}</div>
                    <div class="user-details">
                        ğŸ“ ${user.phone_number || 'æœªè¨­å®š'} | ğŸ“§ ${user.email || 'æœªè¨­å®š'}
                        ${user.active_tickets > 0 ? `<span class="user-tickets"> | ğŸ« æ®‹${user.active_tickets}æš</span>` : ''}
                        ${user.last_visit !== 'ãªã—' ? ` | ğŸ“… æœ€çµ‚æ¥åº—: ${user.last_visit}` : ''}
                    </div>
                </div>
            `).join('');
            
            searchResults.innerHTML = resultsHtml;
            searchResults.style.display = 'block';
            
            // Let the container size naturally based on content
            searchResults.style.height = 'auto';
            
            // Force a reflow to ensure the browser recalculates dimensions
            searchResults.offsetHeight;
            
            console.log('ğŸ” Search results displayed:', users.length, 'users');
            

        }

        // ãƒ¢ãƒ¼ãƒ€ãƒ«ç”¨ãƒ¦ãƒ¼ã‚¶ãƒ¼é¸æŠ
        function selectUserForModal(userId, name, phone, email) {
            console.log('ğŸ” selectUserForModal called with:', { userId, name, phone, email });
            console.log('ğŸ” Current reservation user ID:', currentReservation?.userId);
            
            // é¸æŠã•ã‚ŒãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ä¿å­˜
            window.selectedUser = {
                id: userId,
                name: name,
                phone_number: phone,
                email: email
            };
            
            // æ¤œç´¢çµæœã‚’ã‚¯ãƒªã‚¢ã—ã¦é¸æŠã•ã‚ŒãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’è¡¨ç¤º
            const searchResults = document.getElementById('userSelectionSearchResults');
            if (searchResults) {
                searchResults.innerHTML = `
                    <div class="selected-user">
                        <div class="user-info">
                            <div class="user-name">âœ… ${name}</div>
                            <div class="user-details">
                                ğŸ“ ${phone || 'æœªè¨­å®š'} | ğŸ“§ ${email || 'æœªè¨­å®š'}
                            </div>
                        </div>
                    </div>
                `;
            }
            
            // ä¿å­˜ãƒœã‚¿ãƒ³ã‚’æœ‰åŠ¹åŒ–
            const saveBtn = document.getElementById('saveUserBtn');
            if (saveBtn) {
                saveBtn.disabled = false;
            }
            

            
            // æˆåŠŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
            showMessage(`æ—¢å­˜ãƒ¦ãƒ¼ã‚¶ãƒ¼ã€Œ${name}ã€ã‚’é¸æŠã—ã¾ã—ãŸ`, 'success');
        }

        // ãƒ¦ãƒ¼ã‚¶ãƒ¼é¸æŠãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
        function closeUserSelectionModal() {
            document.getElementById('userSelectionModal').style.display = 'none';
        }
        
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•°ã¨ã—ã¦å…¬é–‹
        window.closeUserSelectionModal = closeUserSelectionModal;

        // ãƒ¦ãƒ¼ã‚¶ãƒ¼é¸æŠã‚’ä¿å­˜
        function saveUserSelection() {
            if (!window.selectedUser) {
                showMessage('ãŠå®¢æ§˜ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚', 'error');
                return;
            }
            
            const newUserId = window.selectedUser.id;
            const newUserName = window.selectedUser.name;
            const newUserPhone = window.selectedUser.phone_number || '';
            const newUserEmail = window.selectedUser.email || '';
            
            console.log('ğŸ” saveUserSelection - Selected user:', { newUserId, newUserName, newUserPhone, newUserEmail });
            console.log('ğŸ” saveUserSelection - Current reservation user ID:', currentReservation?.userId);
            
            // é¡§å®¢æƒ…å ±ã‚’æ›´æ–°
            const customerNameElement = document.querySelector('.customer-name-large');
            if (customerNameElement) {
                customerNameElement.textContent = newUserName;
            }
            
            const phoneElement = document.querySelector('.customer-phone');
            if (phoneElement) {
                phoneElement.textContent = newUserPhone || 'é›»è©±ç•ªå·æœªè¨˜å…¥';
            }
            
            const emailElement = document.querySelector('.customer-email');
            if (emailElement) {
                emailElement.textContent = newUserEmail || 'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹æœªè¨˜å…¥';
            }
            
            // ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚‚æ›´æ–°
            if (currentReservation) {
                currentReservation.customer = newUserName;
                currentReservation.phone = newUserPhone;
                currentReservation.email = newUserEmail;
                currentReservation.userId = newUserId;
            }
            
            // ã‚°ãƒ­ãƒ¼ãƒãƒ«reservationsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚‚æ›´æ–°
            const reservationDateKey = formatDateKey(new Date(currentReservation.start_time || currentReservation.time));
            if (reservations[reservationDateKey]) {
                const reservationIndex = reservations[reservationDateKey].findIndex(r => r.id === currentReservation.id);
                if (reservationIndex !== -1) {
                    reservations[reservationDateKey][reservationIndex].customer = newUserName;
                    reservations[reservationDateKey][reservationIndex].phone = newUserPhone;
                    reservations[reservationDateKey][reservationIndex].email = newUserEmail;
                    reservations[reservationDateKey][reservationIndex].userId = newUserId;
                }
            }
            
            // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã«ãƒ¦ãƒ¼ã‚¶ãƒ¼å¤‰æ›´ã‚’ä¿å­˜
            const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');
            
            fetch(`/admin/reservations/${currentReservation.id}/update_booking`, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-Token': csrfToken
                },
                body: JSON.stringify({
                    reservation: {
                        user_id: newUserId
                    }
                })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    // ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‹ã‚‰æ›´æ–°ã•ã‚ŒãŸãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’å–å¾—
                    const updatedUser = data.reservation.user;
                    
                    // ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°
                    if (currentReservation) {
                        currentReservation.customer = updatedUser.name;
                        currentReservation.phone = updatedUser.phone_number;
                        currentReservation.email = updatedUser.email;
                        currentReservation.userId = updatedUser.id;
                    }
                    
                    // ã‚°ãƒ­ãƒ¼ãƒãƒ«reservationsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚‚æ›´æ–°
                    const reservationDateKey = formatDateKey(new Date(currentReservation.start_time || currentReservation.time));
                    if (reservations[reservationDateKey]) {
                        const reservationIndex = reservations[reservationDateKey].findIndex(r => r.id === currentReservation.id);
                        if (reservationIndex !== -1) {
                            reservations[reservationDateKey][reservationIndex].customer = updatedUser.name;
                            reservations[reservationDateKey][reservationIndex].phone = updatedUser.phone_number;
                            reservations[reservationDateKey][reservationIndex].email = updatedUser.email;
                            reservations[reservationDateKey][reservationIndex].userId = updatedUser.id;
                        }
                    }
                    
                    // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‚‚æ›´æ–°
                    window.currentUserId = updatedUser.id;
                    
                    // å³åº§ã«ãƒ¢ãƒ¼ãƒ€ãƒ«ã®é¡§å®¢åã‚’æ›´æ–°
                    const customerNameElement = document.querySelector('.customer-name-large');
                    if (customerNameElement) {
                        customerNameElement.textContent = updatedUser.name;
                        console.log('âœ… Customer name updated immediately to:', updatedUser.name);
                    }
                    
                    // å…ƒã®ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã‚’ä¿å­˜ã—ã¦ã‹ã‚‰æ›´æ–°
                    currentReservation.originalUserId = currentReservation.userId;
                    
                    // currentReservationã‚‚å³åº§ã«æ›´æ–°
                    currentReservation.customer = updatedUser.name;
                    currentReservation.userId = updatedUser.id;
                    currentReservation.phone = updatedUser.phone_number;
                    currentReservation.email = updatedUser.email;
                    
                    // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚’å³åº§ã«å†æç”»ã—ã¦å¤‰æ›´ã‚’åæ˜ 
                    generateTimeSlots();
                    
                    // ãƒã‚±ãƒƒãƒˆã¨å±¥æ­´ã‚’æ–°ã—ã„ãƒ¦ãƒ¼ã‚¶ãƒ¼ã§æ›´æ–°
                    loadTicketsAndHistoryForUser(updatedUser.id);
                    
                    // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
                    closeUserSelectionModal();
                    
                    showMessage('ãŠå®¢æ§˜ãŒå¤‰æ›´ã•ã‚Œã¾ã—ãŸã€‚', 'success');
                    
                    console.log('ğŸ”„ Customer changed to:', updatedUser.name);
                    
                    // ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦ç¢ºå®Ÿã«ãƒ‡ãƒ¼ã‚¿ã‚’åŒæœŸ
                    setTimeout(() => {
                        window.location.reload();
                    }, 500);
                } else {
                    showMessage(`ãŠå®¢æ§˜ã®å¤‰æ›´ã«å¤±æ•—ã—ã¾ã—ãŸ: ${data.message}`, 'error');
                }
            })
            .catch(error => {
                console.error('âŒ Error updating user:', error);
                showMessage('ãŠå®¢æ§˜ã®å¤‰æ›´ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚', 'error');
            });
        }



        // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‹ã‚‰ã‚·ãƒ•ãƒˆè¨­å®šã‚’èª­ã¿è¾¼ã¿
        function loadShiftSettingsFromBackend() {
            const weekStartStr = formatDateKey(currentWeekStart);
            
            return fetch(`/admin/reservations/load_shift_settings?week_start_date=${weekStartStr}`)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        defaultSchedule = data.default_schedule;
                        weeklySchedules[weekStartStr] = data.current_week_schedule;
                        

                        
                        // é€±å›ºæœ‰ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒãªã„å ´åˆã®ãƒ­ã‚°
                        if (!data.has_custom_schedule) {
    
                        }
  } else {
                        console.error('âŒ Failed to load shift settings:', data.message);
                        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’åˆæœŸåŒ–
                        initializeDefaultSchedule();
                    }
                })
                .catch(error => {
                    console.error('âŒ Error loading shift settings:', error);
                    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’åˆæœŸåŒ–
                    initializeDefaultSchedule();
                });
        }

        // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‹ã‚‰äºˆç´„ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿
        function loadReservationsFromBackend() {
            const weekStartStr = formatDateKey(currentWeekStart);

            
            return fetch(`/admin/reservations/load_reservations?week_start_date=${weekStartStr}`)
                .then(response => response.json())
                .then(data => {

                    if (data.success) {
                        // æ–°ã—ã„é€±ã®äºˆç´„ãƒ‡ãƒ¼ã‚¿ã§æ—¢å­˜ã®ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°ï¼ˆæ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒï¼‰
                        console.log('ğŸ”„ Loading reservations from backend');
                        console.log('ğŸ“… Existing reservations:', reservations);
                        console.log('ğŸ“… Backend reservations:', data.reservations);
                        
                        // æ—¢å­˜ã®ãƒ‡ãƒ¼ã‚¿ã¨æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ã‚’ãƒãƒ¼ã‚¸ï¼ˆæ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒï¼‰
                        for (const [dateKey, newReservations] of Object.entries(data.reservations)) {
                            reservations[dateKey] = newReservations;
                        }
                        
                        console.log('ğŸ“… Final merged reservations:', reservations);
                        console.log('ğŸ“… Checking specific reservation 97:', reservations['2025-08-13']?.find(r => r.id === 97));
                        
                        // Debug: Check if AJAX reservations have timestamp fields and interval data
                        if (data.reservations && Object.keys(data.reservations).length > 0) {
                            const firstDateKey = Object.keys(data.reservations)[0];
                            const firstReservation = data.reservations[firstDateKey][0];
                            console.log('ğŸ” First AJAX reservation structure:', firstReservation);
                            console.log('ğŸ” AJAX interval data:', {
                                effective_interval_minutes: firstReservation.effective_interval_minutes,
                                individual_interval_minutes: firstReservation.individual_interval_minutes,
                                id: firstReservation.id
                            });
                        }
                        
                        // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚’å³åº§ã«å†æç”»ã—ã¦å¤‰æ›´ã‚’åæ˜ 
                        console.log('ğŸ”„ Calling generateTimeSlots after data load');
                        generateTimeSlots();
    } else {
                        console.error('âŒ Failed to load reservations:', data.message);
                    }
                })
                .catch(error => {
                    console.error('âŒ Error loading reservations:', error);
                });
        }

        // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’åˆæœŸåŒ–
        function initializeDefaultSchedule() {
            defaultSchedule = {
                0: { enabled: false, times: [] }, // æ—¥æ›œæ—¥ã¯ä¼‘æ¥­
                1: { enabled: true, times: [{ start: '09:00', end: '20:00' }] }, // æœˆæ›œæ—¥
                2: { enabled: true, times: [{ start: '10:00', end: '20:00' }] }, // ç«æ›œæ—¥
                3: { enabled: true, times: [{ start: '10:00', end: '20:00' }] }, // æ°´æ›œæ—¥
                4: { enabled: true, times: [{ start: '10:00', end: '20:00' }] }, // æœ¨æ›œæ—¥
                5: { enabled: true, times: [{ start: '10:00', end: '20:00' }] }, // é‡‘æ›œæ—¥
                6: { enabled: true, times: [{ start: '09:00', end: '18:00' }] }, // åœŸæ›œæ—¥
            };
        }

        // é€±è¡¨ç¤ºã‚’æç”»
        function renderWeekView() {
            updateWeekHeader();
            generateTimeSlots();
        }

        // é€±ã®ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’æ›´æ–°
        function updateWeekHeader() {
            const endDate = new Date(currentWeekStart);
            endDate.setDate(endDate.getDate() + 6);
            
            const startStr = formatDateShort(currentWeekStart);
            const endStr = formatDateShort(endDate);
            
            document.getElementById('currentWeek').textContent = 
                `${currentWeekStart.getFullYear()}å¹´ ${startStr} - ${endStr}`;
            
            // æ—¥ä»˜ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’æ›´æ–°
            const headers = document.querySelectorAll('.day-header');
            for (let i = 0; i < headers.length; i++) {
                const date = new Date(currentWeekStart);
                date.setDate(date.getDate() + i);
                
                const dayName = dayNames[date.getDay()];
                const dateStr = `${date.getMonth() + 1}/${date.getDate()}`;
                
                // CSSã‚¯ãƒ©ã‚¹ã‚’ãƒªã‚»ãƒƒãƒˆ
                headers[i].classList.remove('sunday', 'saturday');
                
                // æ­£ã—ã„CSSã‚¯ãƒ©ã‚¹ã‚’è¿½åŠ 
                if (date.getDay() === 0) {
                    headers[i].classList.add('sunday');
                } else if (date.getDay() === 6) {
                    headers[i].classList.add('saturday');
                }
                
                headers[i].innerHTML = `${dayName}<br><span style="font-size: 12px;">${dateStr}</span>`;
            }
        }

        // ã‚¿ã‚¤ãƒ ã‚¹ãƒ­ãƒƒãƒˆã‚’ç”Ÿæˆ
        function generateTimeSlots() {
            console.log('ğŸ” generateTimeSlots called - defaultSchedule:', defaultSchedule);
            console.log('ğŸ” generateTimeSlots - current reservations data:', reservations);
            console.log('ğŸ” generateTimeSlots - reservation 97 data:', reservations['2025-08-13']?.find(r => r.id === 97));
            const scheduleBody = document.getElementById('scheduleBody');
            scheduleBody.innerHTML = '';
            
            // 8:00ã‹ã‚‰21:00ã¾ã§10åˆ†åˆ»ã¿ã§ç”Ÿæˆ
            for (let hour = 8; hour <= 21; hour++) {
                for (let minute = 0; minute < 60; minute += 10) {
                    if (hour === 21 && minute > 0) break; // 21:00ã§çµ‚äº†
                    
                    const timeStr = `${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}`;
                    
                    // è¡Œã‚³ãƒ³ãƒ†ãƒŠã‚’ä½œæˆ
                    const row = document.createElement('div');
                    row.className = 'schedule-row';
                    
                    // è¡Œå…¨ä½“ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è¿½åŠ 
                    if (minute === 0) {
                        row.classList.add('hour-row');
                    } else if (minute === 30) {
                        row.classList.add('half-hour-row');
                    }
                    
                    // æ™‚åˆ»ãƒ©ãƒ™ãƒ«
                    const timeSlot = document.createElement('div');
                    timeSlot.className = 'time-slot';
                    
                    // æ™‚é–“ãƒãƒ¼ã‚«ãƒ¼ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è¿½åŠ ï¼ˆ10åˆ†åˆ»ã¿ã«å¯¾å¿œï¼‰
                    if (minute === 0) {
                        timeSlot.classList.add('hour-marker');
                    } else if (minute === 30) {
                        timeSlot.classList.add('half-hour-marker');
                    }
                    
                    timeSlot.textContent = timeStr;
                    row.appendChild(timeSlot);
                    
                    // å„æ›œæ—¥ã®ã‚»ãƒ«
                    for (let day = 0; day < 7; day++) {
                        const cell = document.createElement('div');
                        cell.className = 'schedule-cell';
                        cell.dataset.day = day;
                        cell.dataset.time = timeStr;
                        
                        // ãƒ‰ãƒ­ãƒƒãƒ—ã‚¾ãƒ¼ãƒ³ã¨ã—ã¦è¨­å®š
                        cell.addEventListener('dragover', handleDragOver);
                        cell.addEventListener('drop', handleDrop);
                        cell.addEventListener('dragenter', handleDragEnter);
                        cell.addEventListener('dragleave', handleDragLeave);
                        
                        const scheduleDate = new Date(currentWeekStart);
                        scheduleDate.setDate(scheduleDate.getDate() + day);
                        const dateKey = formatDateKey(scheduleDate);
                        
                                                // å–¶æ¥­æ™‚é–“ãƒã‚§ãƒƒã‚¯
                        if (isBusinessHour(day, timeStr)) {
                            // äºˆç´„ãƒã‚§ãƒƒã‚¯
                            const reservation = findReservation(dateKey, timeStr);
                            
                            // ãƒ‡ãƒãƒƒã‚°ç”¨ãƒ­ã‚°ï¼ˆç‰¹å®šã®æ™‚é–“ã®ã¿ï¼‰
                            if (timeStr === '10:00' && day === 1) {
                                console.log(`ğŸ” Checking for reservation at ${dateKey} ${timeStr}:`, {
                                    dayReservations: reservations[dateKey] || [],
                                    foundReservation: reservation,
                                    isReservationStart: reservation ? isReservationStart(dateKey, timeStr) : false
                                });
                            }
                            
                            if (reservation) {
                                // äºˆç´„ã®é–‹å§‹ã‚¹ãƒ­ãƒƒãƒˆã®å ´åˆã®ã¿ãƒ–ãƒ­ãƒƒã‚¯ã‚’è¡¨ç¤º
                                if (isReservationStart(dateKey, timeStr)) {
                                    console.log('ğŸ¯ Creating reservation block for:', {
                                        id: reservation.id,
                                        customer: reservation.customer,
                                        userId: reservation.userId,
                                        date: dateKey,
                                        time: timeStr,
                                        effective_interval_minutes: reservation.effective_interval_minutes,
                                        individual_interval_minutes: reservation.individual_interval_minutes,
                                        duration: reservation.duration
                                    });
                                    const block = createSpanningReservationBlock(reservation, dateKey, timeStr);
                                    cell.appendChild(block);
                                    // äºˆç´„è©³ç´°ã‚’è¡¨ç¤ºã™ã‚‹ãŸã‚ã®ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆä¼‘æ†©ãƒ–ãƒ­ãƒƒã‚¯ä»¥å¤–ï¼‰
                                    if (true) { // å¸¸ã«å®Ÿè¡Œï¼ˆis_breakå±æ€§ã¯ç„¡åŠ¹åŒ–ï¼‰
                                    cell.addEventListener('click', (e) => {
                                        // ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã§ãªã„å ´åˆã®ã¿ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã‚’å®Ÿè¡Œ
                                        if (!isDragging) {
                                                console.log('ğŸ‘¤ Regular reservation block clicked:', reservation);
                                        openReservationDetailModal(reservation);
                                        }
                                    });
                                    }
                                    
                                    // ãƒ‰ãƒ©ãƒƒã‚°ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¿½åŠ ï¼ˆãƒ¡ã‚¤ãƒ³ãƒ–ãƒ­ãƒƒã‚¯ã«è¿½åŠ ï¼‰
                                    console.log('ğŸ¯ Setting up drag events for reservation:', reservation.id);
                                    block.addEventListener('dragstart', handleDragStart);
                                    block.addEventListener('dragend', handleDragEnd);
                                    
                                    // Also add drag over to the cell for visual feedback
                                    cell.addEventListener('dragover', handleDragOver);
                                    
                                    // ãƒ‡ãƒãƒƒã‚°ç”¨ãƒ­ã‚°ï¼ˆç‰¹å®šã®äºˆç´„ã®ã¿ï¼‰
                                    if (reservation.customer === 'ç”°ä¸­æ§˜') {
                                        console.log(`ğŸ” Created reservation block for ${dateKey} ${timeStr}:`, reservation);
                                    }
                                }
    } else {
                                cell.classList.add('available', 'bookable');
                                // æ–°è¦äºˆç´„ä½œæˆã®ãŸã‚ã®ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
                                cell.addEventListener('click', () => {
                                    const slotDate = new Date(currentWeekStart);
                                    slotDate.setDate(slotDate.getDate() + day);
                                    showSlotOptions(slotDate, timeStr, cell);
                                });
                            }
                        } else {
                            cell.classList.add('unavailable', 'outside-business-hours');
                        }
                        
                        row.appendChild(cell);
                    }
                    
                    scheduleBody.appendChild(row);
                }
            }
            
            // ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ç”Ÿæˆå¾Œã«ã‚­ãƒ£ãƒ³ã‚»ãƒ«è¡¨ç¤ºã‚’æ›´æ–°
            setTimeout(() => {
                updateCancellationDisplayImmediately();
            }, 10);
        }

        // ç¾åœ¨ã®é€±ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å–å¾—
        function getCurrentWeekSchedule(specificDate = null) {
            // å®‰å…¨ãƒã‚§ãƒƒã‚¯: ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
            if (!defaultSchedule) {
                console.warn('âš ï¸ Default schedule not loaded, initializing fallback');
                initializeDefaultSchedule();
            }
            
            let weekKey;
            if (specificDate) {
                // æŒ‡å®šã•ã‚ŒãŸæ—¥ä»˜ã®é€±ã®é–‹å§‹æ—¥ï¼ˆæ—¥æ›œæ—¥ï¼‰ã‚’è¨ˆç®—
                const weekStart = new Date(specificDate);
                weekStart.setDate(specificDate.getDate() - specificDate.getDay());
                weekKey = formatDateKey(weekStart);
                console.log(`ğŸ” Calculating week key for specific date ${specificDate.toISOString().split('T')[0]}: ${weekKey}`);
            } else {
                // ç¾åœ¨ã®é€±ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ç”¨
                weekKey = formatDateKey(currentWeekStart);
            }
            
            if (!weeklySchedules[weekKey]) {
                // é€±å›ºæœ‰ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒãªã„å ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚’ä½¿ç”¨ï¼ˆã‚³ãƒ”ãƒ¼ã¯ä½œæˆã—ãªã„ï¼‰
                console.log(`ğŸ” No custom schedule for ${weekKey}, using default schedule`);
                return defaultSchedule;
            }
            
            console.log(`ğŸ” Using custom schedule for ${weekKey}`);
            return weeklySchedules[weekKey];
        }

        // å–¶æ¥­æ™‚é–“ã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯
        function isBusinessHour(dayOfWeek, timeStr, specificDate = null) {
            // ç‰¹å®šã®æ—¥ä»˜ãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã€ãã®æ—¥ä»˜ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ç”¨
            let currentWeekSchedule;
            if (specificDate) {
                // æŒ‡å®šã•ã‚ŒãŸæ—¥ä»˜ã®é€±ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å–å¾—
                const dateKey = specificDate.toISOString().split('T')[0];
                console.log(`ğŸ” Using schedule for specific date: ${dateKey}`);
                currentWeekSchedule = getCurrentWeekSchedule(specificDate);
            } else {
                // ç¾åœ¨ã®é€±ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ç”¨
                currentWeekSchedule = getCurrentWeekSchedule();
            }
            
            const currentSchedule = currentWeekSchedule[dayOfWeek];
            
            // ãƒ‡ãƒãƒƒã‚°ç”¨ãƒ­ã‚°ï¼ˆ18:20ã®æ™‚é–“ã®ã¿ï¼‰
            if (timeStr === '18:20') {
                console.log('ğŸ” isBusinessHour debug for 18:20:', {
                    dayOfWeek,
                    currentSchedule,
                    currentWeekSchedule: Object.keys(currentWeekSchedule)
                });
            }
            
            // ãƒ‡ãƒãƒƒã‚°ç”¨ãƒ­ã‚°ï¼ˆ8:00ã®æ™‚é–“ã®ã¿ï¼‰
            if (timeStr === '08:00') {
                console.log('ğŸ” isBusinessHour debug for 08:00:', {
                    dayOfWeek,
                    currentSchedule,
                    currentWeekSchedule: Object.keys(currentWeekSchedule),
                    scheduleDetails: currentSchedule ? {
                        enabled: currentSchedule.enabled,
                        times: currentSchedule.times,
                        timesCount: currentSchedule.times ? currentSchedule.times.length : 0
                    } : 'No schedule'
                });
            }
            
            // ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒæœ‰åŠ¹ã§æ™‚é–“è¨­å®šãŒã‚ã‚‹å ´åˆã®ã¿ãƒã‚§ãƒƒã‚¯
            if (currentSchedule && currentSchedule.enabled && currentSchedule.times.length > 0) {
                const [hours, minutes] = timeStr.split(':').map(Number);
                const timeInMinutes = hours * 60 + minutes;
                
                const isAvailable = currentSchedule.times.some(slot => {
                    const [startHour, startMin] = slot.start.split(':').map(Number);
                    const [endHour, endMin] = slot.end.split(':').map(Number);
                    const startInMinutes = startHour * 60 + startMin;
                    const endInMinutes = endHour * 60 + endMin;
                    
                    const slotMatch = timeInMinutes >= startInMinutes && timeInMinutes < endInMinutes;
                    
                    // å•é¡Œã®ã‚ã‚‹æ™‚é–“ã®ã‚¹ãƒ­ãƒƒãƒˆãƒã‚§ãƒƒã‚¯è©³ç´°ãƒ­ã‚°
                    if ((timeStr === '10:00' && dayOfWeek === 1) || timeStr === '09:10' || timeStr === '09:50') {
                        console.log(`ğŸ” Slot check for ${timeStr}: ${slot.start}-${slot.end} (${startInMinutes}-${endInMinutes}) vs ${timeInMinutes} = ${slotMatch}`);
                    }
                    
                    // 8:00ã®è©³ç´°ãƒ‡ãƒãƒƒã‚°
                    if (timeStr === '08:00') {
                        console.log(`ğŸ” 8:00 slot check for day ${dayOfWeek}: ${slot.start}-${slot.end} (${startInMinutes}-${endInMinutes}) vs ${timeInMinutes} = ${slotMatch}`, {
                            slot,
                            timeStr,
                            timeInMinutes,
                            startInMinutes,
                            endInMinutes,
                            condition1: timeInMinutes >= startInMinutes,
                            condition2: timeInMinutes < endInMinutes
                        });
                    }
                    
                    return slotMatch;
                });
                
                // ãƒ‡ãƒãƒƒã‚°ç”¨ãƒ­ã‚°ï¼ˆå–¶æ¥­æ™‚é–“å¢ƒç•Œã¨å•é¡Œã®ã‚ã‚‹æ™‚é–“ï¼‰
                if ((timeStr === '10:00' && dayOfWeek === 1) || timeStr === '09:10' || timeStr === '09:50') {
                    const businessSlots = currentSchedule.times.map(slot => `${slot.start}-${slot.end}`);
                    console.log(`ğŸ” Business hour check for ${['Sun','Mon','Tue','Wed','Thu','Fri','Sat'][dayOfWeek]} ${timeStr}:`, {
                        schedule: currentSchedule,
                        timeInMinutes,
                        isAvailable,
                        scheduleType: currentWeekSchedule === defaultSchedule ? 'default' : 'custom',
                        businessSlots: businessSlots
                    });
                    // businessSlotsã®è©³ç´°ã‚’åˆ¥é€”ãƒ­ã‚°å‡ºåŠ›
                    console.log(`ğŸ“‹ Business slots details for ${['Sun','Mon','Tue','Wed','Thu','Fri','Sat'][dayOfWeek]}:`, currentSchedule.times);
                }
                
                // 8:00ã®æœ€çµ‚çµæœãƒ‡ãƒãƒƒã‚°
                if (timeStr === '08:00') {
                    const businessSlots = currentSchedule.times.map(slot => `${slot.start}-${slot.end}`);
                    console.log(`ğŸ” 8:00 final result for ${['Sun','Mon','Tue','Wed','Thu','Fri','Sat'][dayOfWeek]}:`, {
                        schedule: currentSchedule,
                        timeInMinutes,
                        isAvailable,
                        scheduleType: currentWeekSchedule === defaultSchedule ? 'default' : 'custom',
                        businessSlots: businessSlots,
                        timesArray: currentSchedule.times
                    });
                }
                
                return isAvailable;
            }
            
            return false;
        }
        
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«isBusinessHouré–¢æ•°ã‚’å…¬é–‹ï¼ˆä¸€æ‹¬äºˆç´„ã§ä½¿ç”¨ï¼‰
        window.isBusinessHour = isBusinessHour;
        
        // ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šåœŸæ›œæ—¥ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ç¢ºèª
        console.log('ğŸ” Saturday schedule debug:', {
            dayOfWeek: 6,
            currentWeekSchedule: getCurrentWeekSchedule(),
            saturdaySchedule: getCurrentWeekSchedule()[6]
        });
  
        // äºˆç´„ã‚’æ¤œç´¢
        function findReservation(dateKey, timeStr) {
            const dayReservations = reservations[dateKey] || [];
            
            // ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šç‰¹å®šã®äºˆç´„ã‚’ãƒã‚§ãƒƒã‚¯
            if (dateKey === '2025-08-13' && timeStr === '10:00') {
                console.log('ğŸ” findReservation called for 2025-08-13 10:00');
                console.log('ğŸ” dayReservations:', dayReservations);
                console.log('ğŸ” Looking for reservation 97:', dayReservations.find(r => r.id === 97));
            }
            return dayReservations.find(reservation => {
                const reservationTime = reservation.time;
                const [resHour, resMin] = reservationTime.split(':').map(Number);
                const [checkHour, checkMin] = timeStr.split(':').map(Number);
                
                const resTimeInMin = resHour * 60 + resMin;
                const checkTimeInMin = checkHour * 60 + checkMin;
                const preparationTime = reservation.effective_interval_minutes ?? 10; // å®Ÿéš›ã®æº–å‚™æ™‚é–“ã‚’ä½¿ç”¨
                const endTimeInMin = resTimeInMin + reservation.duration + preparationTime;
                
                // æ™‚é–“ã‚¹ãƒ­ãƒƒãƒˆã®å¢ƒç•Œã‚’è€ƒæ…®ã—ã¦ã€æ¬¡ã®æ™‚é–“ã‚¹ãƒ­ãƒƒãƒˆã¨ã®é‡è¤‡ã‚’é¿ã‘ã‚‹
                const nextHourInMin = Math.ceil(endTimeInMin / 60) * 60; // æ¬¡ã®æ™‚é–“ã®é–‹å§‹
                const adjustedEndTimeInMin = Math.min(endTimeInMin, nextHourInMin);
                
                // ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šæ™‚é–“è¨ˆç®—ã‚’ç¢ºèª
                if (timeStr === '15:00' && reservation.customer === 'å‰ç”°') {
                    console.log('ğŸ” Time calculation debug:', {
                        reservationTime,
                        timeStr,
                        resTimeInMin,
                        checkTimeInMin,
                        duration: reservation.duration,
                        preparationTime,
                        endTimeInMin,
                        isOverlapping: checkTimeInMin >= resTimeInMin && checkTimeInMin < endTimeInMin
                    });
                }
                
                return checkTimeInMin >= resTimeInMin && checkTimeInMin < adjustedEndTimeInMin;
            });
        }

        // äºˆç´„ã®é–‹å§‹ã‚¹ãƒ­ãƒƒãƒˆã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯
        function isReservationStart(dateKey, timeStr) {
            const dayReservations = reservations[dateKey] || [];
            return dayReservations.some(reservation => {
                return reservation.time === timeStr;
            });
        }

        // äºˆç´„ã®ç¶™ç¶šã‚¹ãƒ­ãƒƒãƒˆã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯
        function isReservationContinuation(dateKey, timeStr) {
            const dayReservations = reservations[dateKey] || [];
            return dayReservations.some(reservation => {
                const reservationTime = reservation.time;
                const [resHour, resMin] = reservationTime.split(':').map(Number);
                const [checkHour, checkMin] = timeStr.split(':').map(Number);
                
                const resTimeInMin = resHour * 60 + resMin;
                const checkTimeInMin = checkHour * 60 + checkMin;
                const endTimeInMin = resTimeInMin + reservation.duration;
                
                return checkTimeInMin > resTimeInMin && checkTimeInMin < endTimeInMin;
            });
        }

        // äºˆç´„ãƒ–ãƒ­ãƒƒã‚¯ã‚’ä½œæˆ
        function createReservationBlock(reservation) {
            const block = document.createElement('div');
            block.className = `reservation-block ${reservation.status}`;
            block.draggable = true;
            block.dataset.reservationId = reservation.id;
            block.dataset.reservationData = JSON.stringify(reservation);
            
            // ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¿½åŠ 
            block.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                console.log('ğŸ¯ äºˆç´„ãƒ–ãƒ­ãƒƒã‚¯ãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚Œã¾ã—ãŸ:', reservation);
                console.log('ğŸ” äºˆç´„ID:', reservation.id);
                openReservationDetailModal(reservation);
            });
            
            const statusIcon = {
                'tentative': 'â³',
                'confirmed': 'âœ“',
                'completed': 'âœ…'
            };
            
            block.innerHTML = `
                ${statusIcon[reservation.status] || ''} ${reservation.customer}
                <div style="font-size: 9px; opacity: 0.9;">${reservation.duration}åˆ†</div>
            `;
            
            return block;
        }

        // ã‚¹ãƒ‘ãƒ‹ãƒ³ã‚°äºˆç´„ãƒ–ãƒ­ãƒƒã‚¯ã‚’ä½œæˆ
        function createSpanningReservationBlock(reservation, dateKey, timeStr) {
            console.log('ğŸ¯ Creating spanning block for reservation:', reservation.id, {
                effective_interval_minutes: reservation.effective_interval_minutes,
                individual_interval_minutes: reservation.individual_interval_minutes,
                duration: reservation.duration,
                is_break: false
            });
            const block = document.createElement('div');
            
            // ä¼‘æ†©ã‹ã©ã†ã‹ã§ç•°ãªã‚‹ã‚¯ãƒ©ã‚¹ã‚’è¨­å®š
            if (reservation.customer === 'ä¼‘æ†©' || reservation.customer === 'æº–å‚™æ™‚é–“' || reservation.customer === 'æ¥­å‹™' || reservation.customer === 'ãƒŸãƒ¼ãƒ†ã‚£ãƒ³ã‚°' || reservation.customer === 'ãã®ä»–') {
                block.className = `reservation-block spanning break-block ${reservation.status}`;
            } else {
                block.className = `reservation-block spanning ${reservation.status}`;
            }
            
            block.draggable = true; // ãƒ¡ã‚¤ãƒ³ãƒ–ãƒ­ãƒƒã‚¯ã‚’ãƒ‰ãƒ©ãƒƒã‚°å¯èƒ½ã«å¤‰æ›´
            block.dataset.reservationId = reservation.id;
            block.dataset.reservationData = JSON.stringify(reservation);
            block.dataset.originalDateKey = dateKey;
            block.dataset.originalTimeStr = timeStr;
            
            // ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¿½åŠ ï¼ˆä¼‘æ†©ã®å ´åˆã¯å¾Œã§å€‹åˆ¥ã«è¨­å®šï¼‰
            if (!(reservation.customer === 'ä¼‘æ†©' || reservation.customer === 'æº–å‚™æ™‚é–“' || reservation.customer === 'æ¥­å‹™' || reservation.customer === 'ãƒŸãƒ¼ãƒ†ã‚£ãƒ³ã‚°' || reservation.customer === 'ãã®ä»–')) {
                block.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('ğŸ¯ ã‚¹ãƒ‘ãƒ‹ãƒ³ã‚°äºˆç´„ãƒ–ãƒ­ãƒƒã‚¯ãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚Œã¾ã—ãŸ:', reservation);
                    console.log('ğŸ” äºˆç´„ID:', reservation.id);
                    openReservationDetailModal(reservation);
                });
            }
            
            const statusIcon = {
                'tentative': 'â³',
                'confirmed': 'âœ“',
                'completed': 'âœ…',
                'break': 'â˜•'
            };
            
            // äºˆç´„ã®ç¶™ç¶šæ™‚é–“ã«åŸºã¥ã„ã¦é«˜ã•ã‚’è¨ˆç®—
            const durationInMinutes = reservation.duration;
            // ä¼‘æ†©ã®å ´åˆã¯æº–å‚™æ™‚é–“ãªã—
            const preparationTime = (reservation.effective_interval_minutes ?? 10); // ä¼‘æ†©æ©Ÿèƒ½ã¯ç„¡åŠ¹åŒ–
            const totalTime = durationInMinutes + preparationTime;
                         const rowHeight = 20; // å„æ™‚é–“ã‚¹ãƒ­ãƒƒãƒˆã®é«˜ã•ï¼ˆ10åˆ†é–“ï¼‰
            const exactHeight = (totalTime / 10) * rowHeight; // æ­£ç¢ºãªé«˜ã•ã‚’è¨ˆç®—
            
            block.style.height = `${exactHeight}px`;
            block.style.top = '0';
            
            // æº–å‚™æ™‚é–“éƒ¨åˆ†ã‚’è¦–è¦šçš„ã«åŒºåˆ¥
            const bookingHeight = (durationInMinutes / 10) * rowHeight;
            const preparationHeight = (preparationTime / 10) * rowHeight;
            
            // é–‹å§‹æ™‚é–“ã¨çµ‚äº†æ™‚é–“ã‚’è¨ˆç®—
            const [startHour, startMin] = timeStr.split(':').map(Number);
            const startTimeInMinutes = startHour * 60 + startMin;
            const endTimeInMinutes = startTimeInMinutes + reservation.duration;
            
            const startTime = `${String(Math.floor(startTimeInMinutes / 60)).padStart(2, '0')}:${String(startTimeInMinutes % 60).padStart(2, '0')}`;
            const endTime = `${String(Math.floor(endTimeInMinutes / 60)).padStart(2, '0')}:${String(endTimeInMinutes % 60).padStart(2, '0')}`;
            
            // ä¼‘æ†©ãƒ–ãƒ­ãƒƒã‚¯ã®å ´åˆã¯ç•°ãªã‚‹ã‚¹ã‚¿ã‚¤ãƒ«ã§è¡¨ç¤º            
            if (reservation.customer === 'ä¼‘æ†©' || reservation.customer === 'æº–å‚™æ™‚é–“' || reservation.customer === 'æ¥­å‹™' || reservation.customer === 'ãƒŸãƒ¼ãƒ†ã‚£ãƒ³ã‚°' || reservation.customer === 'ãã®ä»–') {
                // ä¼‘æ†©ã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸã‚¢ã‚¤ã‚³ãƒ³ã‚’é¸æŠ
                const breakIcons = {
                    'ä¼‘æ†©': 'â˜•',
                    'æº–å‚™æ™‚é–“': 'âš™ï¸',
                    'æ¥­å‹™': 'ğŸ’¼',
                    'ãƒŸãƒ¼ãƒ†ã‚£ãƒ³ã‚°': 'ğŸ¤'
                };
                const breakIcon = breakIcons[reservation.customer] || 'ğŸŠ';
                
                block.innerHTML = `
                    <div style="height: ${exactHeight}px; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 6px; position: relative; text-align: center;">
                        <div style="font-size: 16px; font-weight: 700; margin-bottom: 3px; text-shadow: 0 2px 4px rgba(0,0,0,0.4);">
                            ${breakIcon} ${reservation.customer}
                        </div>
                        <div style="font-size: 11px; opacity: 0.95; background: rgba(255,255,255,0.35); padding: 3px 8px; border-radius: 12px; display: inline-block; backdrop-filter: blur(2px); margin-bottom: 3px; font-weight: 600;">
                            ${reservation.duration}åˆ†é–“
                        </div>
                        <div style="font-size: 10px; opacity: 0.9; background: rgba(255,255,255,0.25); padding: 2px 8px; border-radius: 10px; display: inline-block; backdrop-filter: blur(1px); font-weight: 500;">
                            ${startTime} - ${endTime}
                        </div>
                    </div>
                `;
                
                // ä¼‘æ†©ãƒ–ãƒ­ãƒƒã‚¯ã«ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¿½åŠ 
                block.addEventListener('click', (e) => {
                    e.stopPropagation(); // ã‚¤ãƒ™ãƒ³ãƒˆã®ä¼æ’­ã‚’åœæ­¢
                    console.log('ğŸŠ Break block clicked:', reservation);
                    openBreakDetailModal(reservation);
                });
            } else {
            // æº–å‚™æ™‚é–“ãŒ0ã®å ´åˆã¯æº–å‚™æ™‚é–“ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¡¨ç¤ºã—ãªã„
            const preparationSection = preparationTime > 0 ? `
                <div style="height: ${preparationHeight}px; background: linear-gradient(135deg, rgba(255,255,255,0.2), rgba(255,255,255,0.1)); display: flex; align-items: center; justify-content: center; font-size: 9px; border-top: 1px solid rgba(255,255,255,0.3); backdrop-filter: blur(1px); position: absolute; left: 0; right: 0; bottom: 0; width: 100%;">
                    <div style="position: absolute; top: 0; left: 0; right: 0; height: 1px; background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);"></div>
                    <span style="background: rgba(255,255,255,0.25); padding: 3px 10px; border-radius: 15px; font-weight: 600; font-size: 8px; text-transform: uppercase; letter-spacing: 0.5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">${preparationTime}åˆ†</span>
                </div>
            ` : '';
            
            block.innerHTML = `
                <div style="height: ${preparationTime > 0 ? bookingHeight : exactHeight}px; display: flex; flex-direction: column; justify-content: center; padding: 8px; position: relative;">
                    <div style="font-size: 12px; font-weight: 600; margin-bottom: 4px; text-shadow: 0 1px 2px rgba(0,0,0,0.3);">
                        ${statusIcon[reservation.status] || ''} ${reservation.customer}
      </div>
                    <div style="font-size: 10px; opacity: 0.9; background: rgba(255,255,255,0.2); padding: 2px 6px; border-radius: 10px; display: inline-block; backdrop-filter: blur(2px); margin-bottom: 4px;">
                        ${reservation.duration}åˆ†
    </div>
                    <div style="font-size: 9px; opacity: 0.8; background: rgba(0,0,0,0.2); padding: 2px 6px; border-radius: 8px; display: inline-block; backdrop-filter: blur(1px);">
                        ${startTime} - ${endTime}
        </div>
        </div>
                ${preparationSection}
    `;
            }
            
            return block;
        }

        // è¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
        function openSettingsModal() {
            document.getElementById('settingsModal').style.display = 'block';
            renderDaySettings();
        }

        // è¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
        function closeSettingsModal() {
            document.getElementById('settingsModal').style.display = 'none';
        }

        // ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆ
        function switchTab(tabName) {
            // ã‚¿ãƒ–ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹æ›´æ–°
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`[onclick="switchTab('${tabName}')"]`).classList.add('active');
            
            // ã‚¿ãƒ–ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆ
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(`${tabName}-tab`).classList.add('active');
            
            if (tabName === 'recurring') {
                renderRecurringDaySettings();
            }
        }

        // æ›œæ—¥åˆ¥è¨­å®šã‚’æç”»
        function renderDaySettings() {
            // é€±æƒ…å ±ã‚’æ›´æ–°
            updateWeekInfo();
            
            const container = document.getElementById('daySettings');
            container.innerHTML = '';
            
            for (let day = 0; day < 7; day++) {
                const dayDiv = createDaySettingDiv(day, false);
                container.appendChild(dayDiv);
            }
        }

        // å®šæœŸçš„ãªè¨­å®šã‚’æç”»
        function renderRecurringDaySettings() {
            const container = document.getElementById('recurringDaySettings');
            container.innerHTML = '';
            
            for (let day = 0; day < 7; day++) {
                const dayDiv = createDaySettingDiv(day, true);
                container.appendChild(dayDiv);
            }
        }

        // é€±æƒ…å ±ã‚’æ›´æ–°
        function updateWeekInfo() {
            const weekStartStr = formatDateKey(currentWeekStart);
            const weekEnd = new Date(currentWeekStart);
            weekEnd.setDate(weekEnd.getDate() + 6);
            const weekEndStr = formatDateKey(weekEnd);
            
            const currentWeekDisplay = document.getElementById('current-week-display');
            const scheduleTypeInfo = document.getElementById('schedule-type-info');
            
            if (currentWeekDisplay) {
                currentWeekDisplay.textContent = `${weekStartStr} ã€œ ${weekEndStr}`;
            }
            
            if (scheduleTypeInfo) {
                const hasCustomSchedule = weeklySchedules[weekStartStr] && 
                    JSON.stringify(weeklySchedules[weekStartStr]) !== JSON.stringify(defaultSchedule);
                
                if (hasCustomSchedule) {
                    scheduleTypeInfo.textContent = 'âœ… ã“ã®é€±ã«ã¯ã‚«ã‚¹ã‚¿ãƒ ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã™';
                    scheduleTypeInfo.style.color = '#28a745';
                } else {
                    scheduleTypeInfo.textContent = 'â„¹ï¸ ã“ã®é€±ã«ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒé©ç”¨ã•ã‚Œã¦ã„ã¾ã™';
                    scheduleTypeInfo.style.color = '#6c757d';
                }
            }
        }

        // æ›œæ—¥è¨­å®šDIVã‚’ä½œæˆ
        function createDaySettingDiv(day, isRecurring) {
            // å®‰å…¨ãƒã‚§ãƒƒã‚¯: ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ‡ãƒ¼ã‚¿ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
            if (!defaultSchedule || !defaultSchedule[day]) {
                console.warn(`âš ï¸ Schedule data not loaded for day ${day}, using fallback`);
                return createFallbackDaySettingDiv(day, isRecurring);
            }
            
            const schedule = isRecurring ? defaultSchedule[day] : getCurrentWeekSchedule()[day];
            const dayDiv = document.createElement('div');
            dayDiv.className = 'day-setting';
            
            const headerClass = day === 0 ? 'sunday' : day === 6 ? 'saturday' : '';
            
            dayDiv.innerHTML = `
                <div class="day-setting-header ${headerClass}">
                    <span>${dayNamesLong[day]}</span>
                    <div class="day-toggle ${schedule.enabled ? 'active' : ''}" onclick="toggleDay(${day}, ${isRecurring})"></div>
        </div>
                <div class="time-slots-container" style="display: ${schedule.enabled ? 'block' : 'none'};">
                    <div id="timeSlots-${day}-${isRecurring}" class="time-slots">
                        ${renderTimeSlots(day, schedule.times, isRecurring)}
        </div>
                    <button class="add-time-btn" onclick="addTimeSlot(${day}, ${isRecurring})">
                        + æ™‚é–“å¸¯ã‚’è¿½åŠ 
          </button>
        </div>
  `;
            
            return dayDiv;
        }

        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”¨ã®æ›œæ—¥è¨­å®šDIVã‚’ä½œæˆ
        function createFallbackDaySettingDiv(day, isRecurring) {
            const dayDiv = document.createElement('div');
            dayDiv.className = 'day-setting';
            
            const headerClass = day === 0 ? 'sunday' : day === 6 ? 'saturday' : '';
            
            dayDiv.innerHTML = `
                <div class="day-setting-header ${headerClass}">
                    <span>${dayNamesLong[day]}</span>
                    <div class="day-toggle" onclick="toggleDay(${day}, ${isRecurring})"></div>
      </div>
                <div class="time-slots-container" style="display: none;">
                    <div id="timeSlots-${day}-${isRecurring}" class="time-slots">
                        <!-- ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ä¸­ -->
                    </div>
                    <button class="add-time-btn" onclick="addTimeSlot(${day}, ${isRecurring})">
                        + æ™‚é–“å¸¯ã‚’è¿½åŠ 
                    </button>
    </div>
  `;
            
            return dayDiv;
        }

        // æ™‚é–“ã‚¹ãƒ­ãƒƒãƒˆã‚’æç”»
        function renderTimeSlots(day, times, isRecurring = false) {
            return times.map((time, index) => `
                <div class="time-slot-input">
                    <input type="time" class="time-input" value="${time.start}" 
                           onchange="(async () => { await updateTimeSlot(${day}, ${index}, 'start', this.value, ${isRecurring}); })()">
                    <span>ã€œ</span>
                    <input type="time" class="time-input" value="${time.end}"
                           onchange="(async () => { await updateTimeSlot(${day}, ${index}, 'end', this.value, ${isRecurring}); })()">
                    <button class="btn btn-danger btn-sm" onclick="removeTimeSlot(${day}, ${index}, ${isRecurring})">å‰Šé™¤</button>
                </div>
            `).join('');
        }

        // æ›œæ—¥ã®æœ‰åŠ¹/ç„¡åŠ¹ã‚’åˆ‡ã‚Šæ›¿ãˆ
        async function toggleDay(day, isRecurring) {
            console.log(`Toggling day ${day} (${dayNamesLong[day]}) for recurring: ${isRecurring}`);
            
            const currentSchedule = isRecurring ? defaultSchedule[day] : getCurrentWeekSchedule()[day];
            const wouldBeDisabled = currentSchedule.enabled; // If currently enabled, it would become disabled
            
            // Check for existing reservations if trying to disable the day
            if (wouldBeDisabled) {
                console.log(`ğŸ” Checking if day ${day} can be disabled`);
                
                if (isRecurring) {
                    // For recurring schedules, check all future reservations for this day of week
                    try {
                        const affectedReservations = await checkRecurringScheduleImpact(day, '00:00', '00:00');
                        if (affectedReservations.length > 0) {
                            const dayName = ['æ—¥æ›œæ—¥', 'æœˆæ›œæ—¥', 'ç«æ›œæ—¥', 'æ°´æ›œæ—¥', 'æœ¨æ›œæ—¥', 'é‡‘æ›œæ—¥', 'åœŸæ›œæ—¥'][day];
                            const reservationList = affectedReservations.map(r => `${r.customer}æ§˜ (${r.date} ${r.time})`).join(', ');
                            
                            showMessage(`${dayName}ã‚’ä¼‘æ¥­æ—¥ã«ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚ä»¥ä¸‹ã®äºˆç´„ãŒã‚ã‚Šã¾ã™: ${reservationList}`, 'error');
                            return; // Don't proceed with the toggle
                        }
                    } catch (error) {
                        console.error('âŒ Error checking reservations for day toggle:', error);
                        showMessage('äºˆç´„çŠ¶æ³ã®ç¢ºèªä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚', 'error');
                        return;
                    }
                } else {
                    // For current week, check reservations for specific dates
                    const affectedReservations = checkCurrentWeekReservationsForDay(day);
                    if (affectedReservations.length > 0) {
                        const dayName = ['æ—¥æ›œæ—¥', 'æœˆæ›œæ—¥', 'ç«æ›œæ—¥', 'æ°´æ›œæ—¥', 'æœ¨æ›œæ—¥', 'é‡‘æ›œæ—¥', 'åœŸæ›œæ—¥'][day];
                        const reservationList = affectedReservations.map(r => `${r.customer}æ§˜ (${r.time})`).join(', ');
                        
                        showMessage(`${dayName}ã‚’ä¼‘æ¥­æ—¥ã«ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚ä»¥ä¸‹ã®äºˆç´„ãŒã‚ã‚Šã¾ã™: ${reservationList}`, 'error');
                        return; // Don't proceed with the toggle
                    }
                }
            }
            
            if (isRecurring) {
                // å®šæœŸçš„ãªã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å ´åˆ
                defaultSchedule[day].enabled = !defaultSchedule[day].enabled;
            } else {
                // ç¾åœ¨ã®é€±ã®å ´åˆã€ã‚«ã‚¹ã‚¿ãƒ ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½œæˆ
                const weekKey = formatDateKey(currentWeekStart);
                if (!weeklySchedules[weekKey]) {
                    weeklySchedules[weekKey] = JSON.parse(JSON.stringify(defaultSchedule));
                    console.log(`ğŸ” Created custom schedule for week ${weekKey}`);
                }
                weeklySchedules[weekKey][day].enabled = !weeklySchedules[weekKey][day].enabled;
            }
            
            const toggle = document.querySelector(`[onclick="toggleDay(${day}, ${isRecurring})"]`);
            const timeSlotsContainer = toggle.parentElement.nextElementSibling;
            
            const schedule = isRecurring ? defaultSchedule[day] : getCurrentWeekSchedule()[day];
            
            if (schedule.enabled) {
                toggle.classList.add('active');
                timeSlotsContainer.style.display = 'block';
                
                // æ™‚é–“ã‚¹ãƒ­ãƒƒãƒˆãŒãªã„å ´åˆã¯è¿½åŠ 
                if (schedule.times.length === 0) {
                    schedule.times.push({ start: '09:00', end: '18:00' });
                }
                
                // ç¾åœ¨ã®ã‚¿ãƒ–ã®ã‚³ãƒ³ãƒ†ãƒŠã®ã¿æ›´æ–°
                const slotsContainer = document.getElementById(`timeSlots-${day}-${isRecurring}`);
                if (slotsContainer) {
                    slotsContainer.innerHTML = renderTimeSlots(day, schedule.times, isRecurring);
                }
            } else {
                toggle.classList.remove('active');
                timeSlotsContainer.style.display = 'none';
            }
            
            console.log(`Day ${day} (${dayNamesLong[day]}) is now ${schedule.enabled ? 'enabled' : 'disabled'} for ${isRecurring ? 'recurring' : 'current week'}`);
        }

        // æ™‚é–“ã‚¹ãƒ­ãƒƒãƒˆã‚’è¿½åŠ 
        function addTimeSlot(day, isRecurring) {
            if (isRecurring) {
                defaultSchedule[day].times.push({ start: '09:00', end: '18:00' });
            } else {
                // ç¾åœ¨ã®é€±ã®å ´åˆã€ã‚«ã‚¹ã‚¿ãƒ ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½œæˆ
                const weekKey = formatDateKey(currentWeekStart);
                if (!weeklySchedules[weekKey]) {
                    weeklySchedules[weekKey] = JSON.parse(JSON.stringify(defaultSchedule));
                    console.log(`ğŸ” Created custom schedule for week ${weekKey}`);
                }
                weeklySchedules[weekKey][day].times.push({ start: '09:00', end: '18:00' });
            }
            
            // ç¾åœ¨ã®ã‚¿ãƒ–ã®ã‚³ãƒ³ãƒ†ãƒŠã®ã¿æ›´æ–°
            const slotsContainer = document.getElementById(`timeSlots-${day}-${isRecurring}`);
            if (slotsContainer) {
                const schedule = isRecurring ? defaultSchedule[day] : getCurrentWeekSchedule()[day];
                slotsContainer.innerHTML = renderTimeSlots(day, schedule.times, isRecurring);
            }
        }

        // æ™‚é–“ã‚¹ãƒ­ãƒƒãƒˆã‚’å‰Šé™¤
        function removeTimeSlot(day, index, isRecurring = false) {
            if (isRecurring) {
                defaultSchedule[day].times.splice(index, 1);
            } else {
                // ç¾åœ¨ã®é€±ã®å ´åˆã€ã‚«ã‚¹ã‚¿ãƒ ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½œæˆ
                const weekKey = formatDateKey(currentWeekStart);
                if (!weeklySchedules[weekKey]) {
                    weeklySchedules[weekKey] = JSON.parse(JSON.stringify(defaultSchedule));
                    console.log(`ğŸ” Created custom schedule for week ${weekKey}`);
                }
                weeklySchedules[weekKey][day].times.splice(index, 1);
            }
            
            // ç¾åœ¨ã®ã‚¿ãƒ–ã®ã‚³ãƒ³ãƒ†ãƒŠã®ã¿æ›´æ–°
            const slotsContainer = document.getElementById(`timeSlots-${day}-${isRecurring}`);
            if (slotsContainer) {
                const schedule = isRecurring ? defaultSchedule[day] : getCurrentWeekSchedule()[day];
                slotsContainer.innerHTML = renderTimeSlots(day, schedule.times, isRecurring);
            }
        }

        // æ™‚é–“ã‚¹ãƒ­ãƒƒãƒˆã‚’æ›´æ–°
        async function updateTimeSlot(day, index, field, value, isRecurring = false) {
            // å¤‰æ›´å‰ã®å€¤ã‚’ä¿å­˜
            let oldValue;
            if (isRecurring) {
                oldValue = defaultSchedule[day].times[index][field];
            } else {
                const weekKey = formatDateKey(currentWeekStart);
                if (!weeklySchedules[weekKey]) {
                    weeklySchedules[weekKey] = JSON.parse(JSON.stringify(defaultSchedule));
                }
                oldValue = weeklySchedules[weekKey][day].times[index][field];
            }
            
            // æ–°ã—ã„å€¤ã‚’è¨­å®š
            if (isRecurring) {
                defaultSchedule[day].times[index][field] = value;
            } else {
                const weekKey = formatDateKey(currentWeekStart);
                if (!weeklySchedules[weekKey]) {
                    weeklySchedules[weekKey] = JSON.parse(JSON.stringify(defaultSchedule));
                    console.log(`ğŸ” Created custom schedule for week ${weekKey}`);
                }
                weeklySchedules[weekKey][day].times[index][field] = value;
            }
            
            // æ™‚é–“å¤‰æ›´ã®å¦¥å½“æ€§ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆå®šæœŸçš„ãªã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚‚å«ã‚€ï¼‰
            if (isRecurring) {
                console.log('ğŸ” Validating recurring schedule time change:', {
                    day,
                    field,
                    oldValue,
                    newValue: value,
                    dayName: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][day]
                });
                
                // å®šæœŸçš„ãªã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å ´åˆã€åŸºæœ¬çš„ãªæ™‚é–“å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯
                if (field === 'start' || field === 'end') {
                    // æ™‚é–“å½¢å¼ã®åŸºæœ¬ãƒã‚§ãƒƒã‚¯
                    const timeRegex = /^([01]?[0-9]|2[0-3]):[0-5][0-9]$/;
                    if (!timeRegex.test(value)) {
                        showMessage('æ™‚é–“ã¯ HH:MM å½¢å¼ã§å…¥åŠ›ã—ã¦ãã ã•ã„', 'error');
                        // å…ƒã®å€¤ã«æˆ»ã™
                        defaultSchedule[day].times[index][field] = oldValue;
                        return;
                    }
                    
                    // é–‹å§‹æ™‚é–“ < çµ‚äº†æ™‚é–“ã®ãƒã‚§ãƒƒã‚¯
                    const currentSlot = defaultSchedule[day].times[index];
                    const startTime = field === 'start' ? value : currentSlot.start;
                    const endTime = field === 'end' ? value : currentSlot.end;
                    
                    if (startTime >= endTime) {
                        showMessage('é–‹å§‹æ™‚é–“ã¯çµ‚äº†æ™‚é–“ã‚ˆã‚Šå‰ã«è¨­å®šã—ã¦ãã ã•ã„', 'error');
                        // å…ƒã®å€¤ã«æˆ»ã™
                        defaultSchedule[day].times[index][field] = oldValue;
                        return;
                    }
                    
                    // æ—¢å­˜ã®äºˆç´„ã¸ã®å½±éŸ¿ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆéåŒæœŸï¼‰
                    try {
                        const affectedReservations = await checkRecurringScheduleImpact(day, startTime, endTime);
                        if (affectedReservations.length > 0) {
                            const dayName = ['æ—¥æ›œæ—¥', 'æœˆæ›œæ—¥', 'ç«æ›œæ—¥', 'æ°´æ›œæ—¥', 'æœ¨æ›œæ—¥', 'é‡‘æ›œæ—¥', 'åœŸæ›œæ—¥'][day];
                            const reservationList = affectedReservations.map(r => `${r.customer}æ§˜ (${r.date} ${r.time})`).join(', ');
                            
                            showMessage(`${dayName}ã®å–¶æ¥­æ™‚é–“å¤‰æ›´ã«ã‚ˆã‚Šã€ä»¥ä¸‹ã®äºˆç´„ãŒå–¶æ¥­æ™‚é–“å¤–ã«ãªã‚Šã¾ã™: ${reservationList}`, 'error');
                            
                            // å…ƒã®å€¤ã«æˆ»ã™
                            defaultSchedule[day].times[index][field] = oldValue;
                            return;
                        }
                    } catch (error) {
                        console.error('âŒ Error checking recurring schedule impact:', error);
                        showMessage('äºˆç´„ãƒ‡ãƒ¼ã‚¿ã®ç¢ºèªä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚', 'error');
                        // å…ƒã®å€¤ã«æˆ»ã™
                        defaultSchedule[day].times[index][field] = oldValue;
                        return;
                    }
                    
                    console.log('âœ… Recurring schedule time validation passed');
                }
            }
            
            // å–¶æ¥­æ™‚é–“ã®å¤‰æ›´ï¼ˆçŸ­ç¸®ãƒ»æ‹¡å¼µï¼‰ã®å ´åˆã€å½±éŸ¿ã‚’ãƒã‚§ãƒƒã‚¯
            if ((field === 'end' && parseInt(value) < parseInt(oldValue)) || 
                (field === 'start' && parseInt(value) > parseInt(oldValue)) ||
                (field === 'end' && parseInt(value) > parseInt(oldValue)) || 
                (field === 'start' && parseInt(value) < parseInt(oldValue))) {
                console.log(`ğŸ” Checking impact of changing business hours for day ${day} from ${oldValue} to ${value} (${field})`);
                
                // å½±éŸ¿ã‚’å—ã‘ã‚‹äºˆç´„ã‚’ãƒã‚§ãƒƒã‚¯
                const affectedReservations = checkShiftChangeImpact(day, oldValue, value, field);
                
                if (affectedReservations.length > 0) {
                    // å½±éŸ¿ãŒã‚ã‚‹å ´åˆã¯ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’è¡¨ç¤º
                    const confirmed = await showShiftChangeConfirmation(affectedReservations, day, oldValue, value, field);
                    if (!confirmed) {
                        // ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚ŒãŸå ´åˆã¯å…ƒã®å€¤ã«æˆ»ã™
                        if (isRecurring) {
                            defaultSchedule[day].times[index][field] = oldValue;
                        } else {
                            const weekKey = formatDateKey(currentWeekStart);
                            weeklySchedules[weekKey][day].times[index][field] = oldValue;
                        }
                        return;
                    }
                }
            }
        }

        // è¨­å®šã‚’ä¿å­˜
        function saveSettings() {
            // ç¾åœ¨ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚¿ãƒ–ã‚’ç¢ºèª
            const activeTab = document.querySelector('.tab-button.active');
            const isRecurring = activeTab && activeTab.textContent.includes('å®šæœŸçš„ãªã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«');
            
            console.log('ğŸ” Active tab:', activeTab ? activeTab.textContent : 'none');
            console.log('ğŸ” isRecurring:', isRecurring);
            
            const scheduleData = isRecurring ? defaultSchedule : getCurrentWeekSchedule();
            const weekStartStr = formatDateKey(currentWeekStart);
            
            console.log('ğŸ”„ Saving shift settings:', {
                isRecurring,
                weekStartStr,
                scheduleData
            });
            
            // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã«ä¿å­˜
            fetch('/admin/reservations/save_shift_settings', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
                    'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]')?.getAttribute('content')
                },
                body: JSON.stringify({
                    schedule_data: scheduleData,
                    is_recurring: isRecurring,
                    week_start_date: weekStartStr
                })
            })
            .then(response => response.json())
  .then(data => {
    if (data.success) {
                    console.log('âœ… Shift settings saved successfully');
                    
                    // è¡¨ç¤ºã‚’æ›´æ–°
                    renderWeekView();
                    closeSettingsModal();
                    
                    // ä¿å­˜å®Œäº†ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                    const message = isRecurring 
                        ? 'å®šæœŸçš„ãªã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒä¿å­˜ã•ã‚Œã¾ã—ãŸã€‚ã“ã®è¨­å®šã¯å…¨ã¦ã®é€±ã«é©ç”¨ã•ã‚Œã¾ã™ã€‚'
                        : 'è¨­å®šãŒä¿å­˜ã•ã‚Œã¾ã—ãŸã€‚ã“ã®è¨­å®šã¯ç¾åœ¨ã®é€±ã®ã¿ã«é©ç”¨ã•ã‚Œã¾ã™ã€‚';
                    showMessage(message, 'success');
    } else {
                    console.error('âŒ Failed to save shift settings:', data.message);
                    showMessage(`ã‚·ãƒ•ãƒˆè¨­å®šã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: ${data.message}`, 'error');
    }
  })
  .catch(error => {
                console.error('âŒ Error saving shift settings:', error);
                showMessage('ã‚·ãƒ•ãƒˆè¨­å®šã®ä¿å­˜ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ', 'error');
            });
        }

        // å‰é€±ã¸
        function previousWeek() {
            console.log('ğŸ”„ Previous week clicked - current week start before:', currentWeekStart);
            currentWeekStart.setDate(currentWeekStart.getDate() - 7);
            console.log('ğŸ”„ Previous week clicked - current week start after:', currentWeekStart);
            
            Promise.all([
                loadShiftSettingsFromBackend(),
                loadReservationsFromBackend()
            ]).then(() => {
                console.log('ğŸ”„ Previous week - data loaded, rendering week view');
                renderWeekView();
                updateCancellationDisplay(); // ã‚­ãƒ£ãƒ³ã‚»ãƒ«å±¥æ­´ã‚’æ›´æ–°
            }).catch(error => {
                console.error('âŒ Error loading data for previous week:', error);
            });
        }

        // æ¬¡é€±ã¸
        function nextWeek() {
            console.log('ğŸ”„ Next week clicked - current week start before:', currentWeekStart);
            currentWeekStart.setDate(currentWeekStart.getDate() + 7);
            console.log('ğŸ”„ Next week clicked - current week start after:', currentWeekStart);
            
            Promise.all([
                loadShiftSettingsFromBackend(),
                loadReservationsFromBackend()
            ]).then(() => {
                console.log('ğŸ”„ Next week - data loaded, rendering week view');
                renderWeekView();
                updateCancellationDisplay(); // ã‚­ãƒ£ãƒ³ã‚»ãƒ«å±¥æ­´ã‚’æ›´æ–°
            }).catch(error => {
                console.error('âŒ Error loading data for next week:', error);
            });
        }

        // æ—¥ä»˜ã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆï¼ˆçŸ­ç¸®ç‰ˆï¼‰
        function formatDateShort(date) {
            return `${date.getMonth() + 1}æœˆ${date.getDate()}æ—¥`;
        }
        
        // ã‚·ãƒ•ãƒˆå¤‰æ›´ã®å½±éŸ¿ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆãƒ©ãƒƒãƒ‘ãƒ¼é–¢æ•°ï¼‰
        function checkShiftChangeImpactAuto(day, oldTime, newTime, field) {
            // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚¿ãƒ–ã«åŸºã¥ã„ã¦isRecurringã‚’åˆ¤å®š
            const activeTab = document.querySelector('.tab-button.active');
            const isRecurring = activeTab && activeTab.textContent.includes('å®šæœŸçš„ãªã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«');
            
            console.log(`ğŸ” Checking impact of changing business hours for day ${day} from ${oldTime} to ${newTime} (${field})`);
            console.log(`ğŸ” Active tab text: "${activeTab ? activeTab.textContent : 'no active tab found'}"`);
            console.log(`ğŸ” isRecurring determined from active tab: ${isRecurring}`);
            
            return checkShiftChangeImpact(day, oldTime, newTime, field, isRecurring);
        }
        
        // ã‚·ãƒ•ãƒˆå¤‰æ›´ã®å½±éŸ¿ã‚’ãƒã‚§ãƒƒã‚¯
        function checkShiftChangeImpact(day, oldTime, newTime, field, isRecurring = null) {
            const affectedReservations = [];
            const dayNames = ['æ—¥', 'æœˆ', 'ç«', 'æ°´', 'æœ¨', 'é‡‘', 'åœŸ'];
            
            // If isRecurring is not specified, auto-detect from active tab
            if (isRecurring === null) {
                const activeTab = document.querySelector('.tab-button.active');
                isRecurring = activeTab && activeTab.textContent.includes('å®šæœŸçš„ãªã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«');
                console.log(`ğŸ” Auto-detected isRecurring from active tab: "${activeTab ? activeTab.textContent : 'no active tab'}" -> ${isRecurring}`);
            }
            
            console.log(`ğŸ” checkShiftChangeImpact called with: day=${day} (${dayNames[day]}), oldTime=${oldTime}, newTime=${newTime}, field=${field}, isRecurring=${isRecurring}`);
            console.log(`ğŸ” All reservations:`, reservations);
            
            // Get current week dates if this is not a recurring change
            let currentWeekDates = [];
            if (!isRecurring && currentWeekStart) {
                const weekStart = new Date(currentWeekStart);
                for (let i = 0; i < 7; i++) {
                    const date = new Date(weekStart);
                    date.setDate(weekStart.getDate() + i);
                    const year = date.getFullYear();
                    const month = String(date.getMonth() + 1).padStart(2, '0');
                    const dayStr = String(date.getDate()).padStart(2, '0');
                    currentWeekDates.push(`${year}-${month}-${dayStr}`);
                }
                console.log(`ğŸ” Current week dates:`, currentWeekDates);
            }
            
            // Check reservations (all weeks for recurring, current week only for non-recurring)
            Object.keys(reservations).forEach(weekKey => {
                // If not recurring, only check current week dates
                if (!isRecurring && !currentWeekDates.includes(weekKey)) {
                    console.log(`ğŸ” Skipping ${weekKey} - not in current week`);
                    return;
                }
                const weekReservations = reservations[weekKey] || [];
                
                weekReservations.forEach(reservation => {
                    // é€±ã®ã‚­ãƒ¼ã‹ã‚‰æ—¥ä»˜ã‚’å–å¾—
                    const reservationDate = new Date(weekKey);
                    const reservationDayOfWeek = reservationDate.getDay();
                    
                    console.log(`ğŸ” Checking reservation: ${reservation.id} on ${weekKey} (day ${reservationDayOfWeek}) vs target day ${day}`);
                    
                    // åŒã˜æ›œæ—¥ã®äºˆç´„ã‚’ãƒã‚§ãƒƒã‚¯
                    if (reservationDayOfWeek === day) {
                        const [startHour, startMin] = reservation.time.split(':').map(Number);
                        const reservationStartInMin = startHour * 60 + startMin;
                        const reservationEndInMin = reservationStartInMin + reservation.duration;
                        console.log(`ğŸ” Reservation time: ${reservation.time} (start: ${reservationStartInMin} min, duration: ${reservation.duration} min, end: ${reservationEndInMin} min)`);
                        let isAffected = false;
                        if (field === 'end') {
                            if (parseInt(newTime) < parseInt(oldTime)) {
                                // æ–°ã—ã„çµ‚äº†æ™‚é–“ï¼ˆåˆ†å˜ä½ï¼‰
                                let newEndInMin;
                                if (String(newTime).includes(':')) {
                                    const [h, m] = String(newTime).split(':').map(Number);
                                    newEndInMin = h * 60 + (isNaN(m) ? 0 : m);
                                } else {
                                    newEndInMin = parseInt(newTime) * 60;
                                }
                                // çµ‚äº†æ™‚é–“ãŒçŸ­ç¸®ã•ã‚Œã‚‹å ´åˆ - äºˆç´„ãŒæ–°ã—ã„çµ‚äº†æ™‚é–“ã‚’è¶…ãˆã‚‹å ´åˆ
                                isAffected = reservationEndInMin > newEndInMin;
                                console.log(`ğŸ” End time shrinking check: reservation ends at ${reservationEndInMin} min, new end time is ${newEndInMin} min = ${isAffected}`);
                            } else {
                                // çµ‚äº†æ™‚é–“ãŒæ‹¡å¼µã•ã‚Œã‚‹å ´åˆ
                                let oldEndInMin, newEndInMin;
                                if (String(oldTime).includes(':')) {
                                    const [h, m] = String(oldTime).split(':').map(Number);
                                    oldEndInMin = h * 60 + (isNaN(m) ? 0 : m);
                                } else {
                                    oldEndInMin = parseInt(oldTime) * 60;
                                }
                                if (String(newTime).includes(':')) {
                                    const [h, m] = String(newTime).split(':').map(Number);
                                    newEndInMin = h * 60 + (isNaN(m) ? 0 : m);
                                } else {
                                    newEndInMin = parseInt(newTime) * 60;
                                }
                                isAffected = reservationStartInMin >= oldEndInMin && reservationStartInMin < newEndInMin;
                                console.log(`ğŸ” End time expanding check: ${reservationStartInMin} >= ${oldEndInMin} AND ${reservationStartInMin} < ${newEndInMin} = ${isAffected}`);
                            }
                        } else if (field === 'start') {
                            if (parseInt(newTime) > parseInt(oldTime)) {
                                // é–‹å§‹æ™‚é–“ãŒé…ããªã‚‹å ´åˆ
                                let newStartInMin;
                                if (String(newTime).includes(':')) {
                                    const [h, m] = String(newTime).split(':').map(Number);
                                    newStartInMin = h * 60 + (isNaN(m) ? 0 : m);
                                } else {
                                    newStartInMin = parseInt(newTime) * 60;
                                }
                                isAffected = reservationStartInMin < newStartInMin;
                                console.log(`ğŸ” Start time delaying check: ${reservationStartInMin} < ${newStartInMin} = ${isAffected}`);
                            } else {
                                // é–‹å§‹æ™‚é–“ãŒæ—©ããªã‚‹å ´åˆ
                                let oldStartInMin, newStartInMin;
                                if (String(oldTime).includes(':')) {
                                    const [h, m] = String(oldTime).split(':').map(Number);
                                    oldStartInMin = h * 60 + (isNaN(m) ? 0 : m);
                                } else {
                                    oldStartInMin = parseInt(oldTime) * 60;
                                }
                                if (String(newTime).includes(':')) {
                                    const [h, m] = String(newTime).split(':').map(Number);
                                    newStartInMin = h * 60 + (isNaN(m) ? 0 : m);
                                } else {
                                    newStartInMin = parseInt(newTime) * 60;
                                }
                                isAffected = reservationStartInMin >= newStartInMin && reservationStartInMin < oldStartInMin;
                                console.log(`ğŸ” Start time advancing check: ${reservationStartInMin} >= ${newStartInMin} AND ${reservationStartInMin} < ${oldStartInMin} = ${isAffected}`);
                            }
                        }
                        if (isAffected) {
                            affectedReservations.push({
                                id: reservation.id,
                                customer: reservation.customer,
                                start_time: reservation.time,
                                end_time: `${Math.floor(reservationEndInMin/60)}:${(reservationEndInMin%60).toString().padStart(2,'0')}`,
                                date: weekKey,
                                dayName: dayNames[day]
                            });
                            console.log(`ğŸ” Added affected reservation: ${reservation.id}`);
                        }
                    }
                });
            });
            
            console.log(`ğŸ” Found ${affectedReservations.length} affected reservations for day ${day} (${dayNames[day]}) - ${field} time change`);
            return affectedReservations;
        }
        
        // ã‚·ãƒ•ãƒˆå¤‰æ›´ã®ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’è¡¨ç¤º
        function showShiftChangeConfirmation(affectedReservations, day, oldTime, newTime, field) {
            return new Promise((resolve) => {
                const dayNames = ['æ—¥', 'æœˆ', 'ç«', 'æ°´', 'æœ¨', 'é‡‘', 'åœŸ'];
                const fieldName = field === 'start' ? 'é–‹å§‹æ™‚é–“' : 'çµ‚äº†æ™‚é–“';
                
                // æ—¢å­˜ã®ãƒ¢ãƒ¼ãƒ€ãƒ«ãŒã‚ã‚Œã°å‰Šé™¤
                const existingModal = document.getElementById('shiftChangeModal');
                if (existingModal) {
                    existingModal.remove();
                }
                
                const modal = document.createElement('div');
                modal.id = 'shiftChangeModal';
                modal.className = 'modal fade';
                modal.setAttribute('tabindex', '-1');
                modal.setAttribute('aria-labelledby', 'shiftChangeModalLabel');
                modal.setAttribute('aria-hidden', 'true');
                modal.innerHTML = `
                    <div class="modal-dialog modal-lg">
                        <div class="modal-content">
                            <div class="modal-header bg-warning text-dark">
                                <h5 class="modal-title" id="shiftChangeModalLabel">âš ï¸ å–¶æ¥­æ™‚é–“å¤‰æ›´ã®ç¢ºèª</h5>
                                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                            </div>
                            <div class="modal-body">
                                <div class="alert alert-warning mb-1">
                                    <strong>å–¶æ¥­æ™‚é–“ã®å¤‰æ›´ã«ã‚ˆã‚Šå½±éŸ¿ã‚’å—ã‘ã‚‹äºˆç´„ãŒã‚ã‚Šã¾ã™:</strong><br>
                                    ${dayNames[day]}æ›œæ—¥ ${fieldName}: ${oldTime}:00 â†’ ${newTime}:00
                                </div>
                                
                                <div class="table-responsive mb-1" style="max-height: 300px; overflow-y: hidden;">
                                    <table class="table table-sm mb-0">
                                        <thead>
                                            <tr>
                                                <th style="font-size: 1rem; padding: 0.3rem;">æ—¥æ™‚</th>
                                                <th style="font-size: 1rem; padding: 0.3rem;">ãŠå®¢æ§˜</th>
                                                <th style="font-size: 1rem; padding: 0.3rem;">æ™‚é–“</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            ${affectedReservations.map(reservation => `
                                                <tr>
                                                    <td style="font-size: 1rem; padding: 0.3rem;">${reservation.date}</td>
                                                    <td style="font-size: 1rem; padding: 0.3rem;">${reservation.customer}</td>
                                                    <td style="font-size: 1rem; padding: 0.3rem;">${reservation.start_time}-${reservation.end_time}</td>
                                                </tr>
                                            `).join('')}
                                        </tbody>
                                    </table>
                                </div>
                                
                                <div class="alert alert-danger mb-0">
                                    <strong>ã‚¨ãƒ©ãƒ¼:</strong> å–¶æ¥­æ™‚é–“ã‚’å¤‰æ›´ã™ã‚‹ã¨ã€ã“ã‚Œã‚‰ã®äºˆç´„ãŒå–¶æ¥­æ™‚é–“å¤–ã«ãªã£ã¦ã—ã¾ã„ã¾ã™ã€‚å¤‰æ›´ã¯ã§ãã¾ã›ã‚“ã€‚
                                </div>
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-primary" id="cancelShiftChange">OK</button>
                            </div>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¨­å®š
                const cancelBtn = modal.querySelector('#cancelShiftChange');
                const closeBtn = modal.querySelector('.btn-close');
                
                cancelBtn.addEventListener('click', () => {
                    modal.remove();
                    resolve(false);
                });
                
                closeBtn.addEventListener('click', () => {
                    modal.remove();
                    resolve(false);
                });
                
                // ãƒ¢ãƒ¼ãƒ€ãƒ«ã®å¤–å´ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹
                modal.addEventListener('click', (event) => {
                    if (event.target === modal) {
                        modal.remove();
                        resolve(false);
                    }
                });
                
                // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’è¡¨ç¤º
                modal.style.display = 'block';
                modal.classList.add('show');
                modal.setAttribute('aria-modal', 'true');
                modal.setAttribute('role', 'dialog');
                
                // èƒŒæ™¯ã‚’æš—ãã™ã‚‹
                const backdrop = document.createElement('div');
                backdrop.className = 'modal-backdrop fade show';
                backdrop.id = 'shiftChangeBackdrop';
                document.body.appendChild(backdrop);
                
                        // ESCã‚­ãƒ¼ã§é–‰ã˜ã‚‹
        const handleEscKey = (event) => {
            if (event.key === 'Escape') {
                modal.remove();
                backdrop.remove();
                document.removeEventListener('keydown', handleEscKey);
                resolve(false);
            }
        };
        document.addEventListener('keydown', handleEscKey);
        
        // ãƒ¢ãƒ¼ãƒ€ãƒ«ã¨ãƒãƒƒã‚¯ãƒ‰ãƒ­ãƒƒãƒ—ã‚’å‰Šé™¤ã™ã‚‹é–¢æ•°
        const cleanup = () => {
            if (modal) modal.remove();
            if (backdrop) backdrop.remove();
            document.removeEventListener('keydown', handleEscKey);
        };
        
        // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚’è¨­å®š
        cancelBtn.addEventListener('click', cleanup);
        closeBtn.addEventListener('click', cleanup);
        modal.addEventListener('click', (event) => {
            if (event.target === modal) {
                cleanup();
                resolve(false);
            }
        });
    });
        }

        // æ—¥ä»˜ã‚­ãƒ¼ã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
        function formatDateKey(date) {
            return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
        }

        // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤º
function showMessage(message, type = 'info') {
            const messageDiv = document.createElement('div');
            messageDiv.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                z-index: 2000;
                padding: 12px 20px;
                border-radius: 6px;
                color: white;
                font-weight: 500;
                animation: slideInRight 0.3s ease;
                background: ${type === 'success' ? '#28a745' : type === 'error' ? '#dc3545' : type === 'warning' ? '#ffc107' : '#007bff'};
                color: ${type === 'warning' ? '#212529' : 'white'};
            `;
            messageDiv.textContent = message;
            
            document.body.appendChild(messageDiv);
            
  setTimeout(() => {
                messageDiv.style.animation = 'slideOutRight 0.3s ease';
                setTimeout(() => document.body.removeChild(messageDiv), 300);
  }, 3000);
}

        // ãƒ¢ãƒ¼ãƒ€ãƒ«ã®å¤–å´ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹
        window.onclick = function(event) {
            const modal = document.getElementById('settingsModal');
            if (event.target === modal) {
                closeSettingsModal();
            }
            
            // ãƒŸãƒ‹ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã®å¤–å´ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹
            const miniCalendar = document.getElementById('miniCalendar');
            const miniCalendarContainer = document.querySelector('.mini-calendar-container');
            if (miniCalendar && !miniCalendarContainer.contains(event.target)) {
                miniCalendar.classList.remove('show');
            }
        }

        // ãƒŸãƒ‹ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼é–¢é€£ã®é–¢æ•°
        function toggleMiniCalendar() {
            const miniCalendar = document.getElementById('miniCalendar');
            miniCalendar.classList.toggle('show');
        }

        function renderMiniCalendar() {
            const year = miniCalendarMonth.getFullYear();
            const month = miniCalendarMonth.getMonth();
            
            console.log('ğŸ“… Rendering mini calendar for:', year, 'å¹´', monthNames[month]);
            
            // ã‚¿ã‚¤ãƒˆãƒ«ã‚’æ›´æ–°
            document.getElementById('miniCalendarTitle').textContent = 
                `${year}å¹´ ${monthNames[month]}`;
            
            // æœˆã®æœ€åˆã®æ—¥ã¨æœ€å¾Œã®æ—¥ã‚’å–å¾—
            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            
            // æœ€åˆã®é€±ã®é–‹å§‹æ—¥ã‚’å–å¾—ï¼ˆæ—¥æ›œæ—¥ã‹ã‚‰ï¼‰
            const startDate = new Date(firstDay);
            startDate.setDate(startDate.getDate() - firstDay.getDay());
            
            // æœ€å¾Œã®é€±ã®çµ‚äº†æ—¥ã‚’å–å¾—ï¼ˆåœŸæ›œæ—¥ã¾ã§ï¼‰
            const endDate = new Date(lastDay);
            endDate.setDate(endDate.getDate() + (6 - lastDay.getDay()));
            
            const daysContainer = document.getElementById('miniCalendarDays');
            daysContainer.innerHTML = '';
            
            // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã®æ—¥ä»˜ã‚»ãƒ«ã‚’ç”Ÿæˆ
            const current = new Date(startDate);
            while (current <= endDate) {
                const dayDiv = document.createElement('div');
                dayDiv.className = 'mini-calendar-day';
                dayDiv.textContent = current.getDate();
                
                // ä»Šæœˆä»¥å¤–ã®æ—¥ä»˜
                if (current.getMonth() !== month) {
                    dayDiv.classList.add('other-month');
                }
                
                // ä»Šæ—¥ã®æ—¥ä»˜
                const todayDate = new Date();
                if (current.toDateString() === todayDate.toDateString()) {
                    dayDiv.classList.add('today');
                }
                
                // ã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸæ—¥ä»˜ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
                if (clickedDate && 
                    current.getFullYear() === clickedDate.getFullYear() && 
                    current.getMonth() === clickedDate.getMonth() && 
                    current.getDate() === clickedDate.getDate()) {
                    dayDiv.classList.add('clicked-day');
                }
                
                // ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ - å®‰å…¨ãªæ—¥ä»˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆ
                const clickDate = new Date(current.getFullYear(), current.getMonth(), current.getDate(), 12, 0, 0, 0);
                dayDiv.addEventListener('click', () => {
                    selectWeekFromDate(clickDate);
                });
                
                daysContainer.appendChild(dayDiv);
                current.setDate(current.getDate() + 1);
            }
        }

        function selectWeekFromDate(date) {
            console.log('ğŸ” Original clicked date:', date);
            console.log('ğŸ” Date details:', {
                year: date.getFullYear(),
                month: date.getMonth() + 1,
                date: date.getDate(),
                dayOfWeek: date.getDay(),
                toString: date.toString()
            });
            
            // æ—¥ä»˜ã‚’å®‰å…¨ã«å‡¦ç† - ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³ã®å½±éŸ¿ã‚’é¿ã‘ã‚‹
            const safeDate = new Date(
                date.getFullYear(),
                date.getMonth(),
                date.getDate(),
                12, 0, 0, 0  // æ­£åˆã«è¨­å®šã—ã¦ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³ã®å•é¡Œã‚’å›é¿
            );
            
            console.log('ğŸ“… Safe date for calculation:', safeDate);
            
            // æŒ‡å®šã•ã‚ŒãŸæ—¥ä»˜ãŒå«ã¾ã‚Œã‚‹é€±ã®é–‹å§‹æ—¥ï¼ˆæ—¥æ›œæ—¥ï¼‰ã‚’è¨ˆç®—
            const dayOfWeek = safeDate.getDay();
            const targetDate = safeDate.getDate() - dayOfWeek;
            
            console.log('Target date calculation:', safeDate.getDate(), '-', dayOfWeek, '=', targetDate);
            
            // é€±ã®é–‹å§‹æ—¥ã‚’å®‰å…¨ã«ä½œæˆ
            const weekStart = new Date(
                safeDate.getFullYear(),
                safeDate.getMonth(),
                targetDate,
                12, 0, 0, 0
            );
            
            console.log('ğŸ“… Calculated week start:', weekStart);
            console.log('ğŸ” Week start details:', {
                year: weekStart.getFullYear(),
                month: weekStart.getMonth() + 1,
                date: weekStart.getDate()
            });
            
            // ã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸæ—¥ä»˜ã‚’ä¿å­˜
            clickedDate = safeDate;
            
            // é€±ã‚’æ›´æ–°
            currentWeekStart = weekStart;
            
            // ã‚·ãƒ•ãƒˆè¨­å®šã¨äºˆç´„ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ã€è¡¨ç¤ºã‚’æ›´æ–°
            Promise.all([
                loadShiftSettingsFromBackend(),
                loadReservationsFromBackend()
            ]).then(() => {
                renderWeekView();
            });
            
            // ãƒŸãƒ‹ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚’é–‰ã˜ã‚‹
            document.getElementById('miniCalendar').classList.remove('show');
            
            // ãƒŸãƒ‹ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚’å†æç”»ï¼ˆé¸æŠçŠ¶æ…‹ã‚’æ›´æ–°ï¼‰
            renderMiniCalendar();
        }

        function previousMiniCalendarMonth() {
            const prevMonthDate = miniCalendarMonth;
            const prevMonth = new Date(
                prevMonthDate.getFullYear(),
                prevMonthDate.getMonth() - 1,
                15, // æœˆã®ä¸­æ—¬ã«è¨­å®š
                12, 0, 0, 0
            );
            
            console.log('â¬…ï¸ Moving to previous month:', prevMonth);
            miniCalendarMonth = prevMonth;
            renderMiniCalendar();
        }

        function nextMiniCalendarMonth() {
            const nextMonthDate = miniCalendarMonth;
            const nextMonth = new Date(
                nextMonthDate.getFullYear(),
                nextMonthDate.getMonth() + 1,
                15, // æœˆã®ä¸­æ—¬ã«è¨­å®š
                12, 0, 0, 0
            );
            
            console.log('â¡ï¸ Moving to next month:', nextMonth);
            miniCalendarMonth = nextMonth;
            renderMiniCalendar();
        }

        function previousMiniCalendarYear() {
            const prevYearDate = miniCalendarMonth;
            const prevYear = new Date(
                prevYearDate.getFullYear() - 1,
                prevYearDate.getMonth(),
                15, // æœˆã®ä¸­æ—¬ã«è¨­å®š
                12, 0, 0, 0
            );
            
            console.log('â¬…ï¸â¬…ï¸ Moving to previous year:', prevYear);
            miniCalendarMonth = prevYear;
            renderMiniCalendar();
        }

        function nextMiniCalendarYear() {
            const nextYearDate = miniCalendarMonth;
            const nextYear = new Date(
                nextYearDate.getFullYear() + 1,
                nextYearDate.getMonth(),
                15, // æœˆã®ä¸­æ—¬ã«è¨­å®š
                12, 0, 0, 0
            );
            
            console.log('â¡ï¸â¡ï¸ Moving to next year:', nextYear);
            miniCalendarMonth = nextYear;
            renderMiniCalendar();
        }

        // ä¼‘æ†©ä½œæˆãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ãï¼ˆç¾åœ¨æ™‚åˆ»ã§ï¼‰
        function openBreakModalWithCurrentTime() {
            const now = new Date();
            const currentTime = `${String(now.getHours()).padStart(2, '0')}:${String(Math.floor(now.getMinutes() / 10) * 10).padStart(2, '0')}`;
            openBreakModal(now, currentTime);
        }

        // ä¼‘æ†©ä½œæˆãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
        function openBreakModal(date, time) {
            // æ—¥ä»˜ã¨æ™‚é–“ã®è¡¨ç¤ºç”¨ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
            const displayDate = `${date.getFullYear()}å¹´${String(date.getMonth() + 1)}æœˆ${String(date.getDate())}æ—¥`;
            const dayNames = ['æ—¥', 'æœˆ', 'ç«', 'æ°´', 'æœ¨', 'é‡‘', 'åœŸ'];
            const dayName = dayNames[date.getDay()];
            
            document.getElementById('breakDisplayDate').textContent = `${displayDate}(${dayName})`;
            document.getElementById('breakDisplayTime').textContent = time;
            
            // å†…éƒ¨çš„ã«æ—¥ä»˜ã¨æ™‚é–“ã‚’ä¿å­˜
            window.selectedBreakDate = date;
            window.selectedBreakTime = time;
            
            // ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ãƒªã‚»ãƒƒãƒˆ
            document.getElementById('breakDuration').value = '';
            document.getElementById('breakTitle').value = '';
            document.getElementById('customBreakTitleInput').value = '';
            document.getElementById('customBreakTitle').style.display = 'none';
            document.getElementById('breakNote').value = '';
            
            document.getElementById('breakModal').style.display = 'block';
        }



        // ä¼‘æ†©ä½œæˆãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
        function closeBreakModal() {
            document.getElementById('breakModal').style.display = 'none';
        }

        // ä¼‘æ†©è©³ç´°ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
        function openBreakDetailModal(reservation) {
            
            window.currentBreakReservation = reservation;
            
            // æ—¥ä»˜ã¨æ™‚é–“ã®è¡¨ç¤ºç”¨ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ - ã‚ˆã‚Šå®‰å…¨ãªæ–¹æ³•
            let reservationDate;
            if (reservation.start_time) {
                reservationDate = new Date(reservation.start_time);
            } else if (reservation.date && reservation.time) {
                reservationDate = new Date(`${reservation.date} ${reservation.time}`);
            } else if (reservation.date) {
                // æ™‚é–“ãŒãªã„å ´åˆã¯æ—¥ä»˜ã®ã¿ã‹ã‚‰ä½œæˆ
                reservationDate = new Date(reservation.date);
            } else {
                console.error('âŒ No valid date/time found in reservation:', reservation);
                // ã‚ˆã‚Šè©³ç´°ãªãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’å‡ºåŠ›
                console.log('ğŸ” Reservation object structure:', {
                    hasStartTime: !!reservation.start_time,
                    hasDate: !!reservation.date,
                    hasTime: !!reservation.time,
                    startTimeType: reservation.start_time ? typeof reservation.start_time : 'undefined',
                    dateType: reservation.date ? typeof reservation.date : 'undefined',
                    timeType: reservation.time ? typeof reservation.time : 'undefined',
                    fullObject: reservation
                });
                reservationDate = new Date(); // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            }
            
            // ä¸æ­£ãªæ—¥ä»˜ã®å ´åˆã®ãƒã‚§ãƒƒã‚¯
            if (isNaN(reservationDate.getTime())) {
                console.error('âŒ Invalid date created from reservation:', reservation);
                reservationDate = new Date(); // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            }
            
            console.log('ğŸ“… Parsed date:', reservationDate);
            
            const displayDate = `${reservationDate.getFullYear()}å¹´${String(reservationDate.getMonth() + 1).padStart(2, '0')}æœˆ${String(reservationDate.getDate()).padStart(2, '0')}æ—¥`;
            const dayNames = ['æ—¥', 'æœˆ', 'ç«', 'æ°´', 'æœ¨', 'é‡‘', 'åœŸ'];
            const dayName = dayNames[reservationDate.getDay()];
            const displayTime = reservationDate.toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' });
            
            document.getElementById('breakDetailDate').textContent = `${displayDate}(${dayName})`;
            document.getElementById('breakDetailTime').textContent = displayTime;
            document.getElementById('breakDetailDuration').textContent = `${reservation.duration || 30}åˆ†é–“`;
            
            // ãƒ•ã‚©ãƒ¼ãƒ ã«ç¾åœ¨ã®å€¤ã‚’è¨­å®š
            document.getElementById('editBreakTitle').value = reservation.customer || reservation.name || 'ä¼‘æ†©';
            document.getElementById('editBreakDuration').value = (reservation.duration || 30).toString();
            document.getElementById('editBreakNote').value = reservation.note || '';
            
            // ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚¤ãƒˆãƒ«ã®å‡¦ç†
            handleEditBreakTitleChange();
            
            document.getElementById('breakDetailModal').style.display = 'block';
        }

        // ä¼‘æ†©è©³ç´°ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
        function closeBreakDetailModal() {
            document.getElementById('breakDetailModal').style.display = 'none';
            window.currentBreakReservation = null;
        }

        // ä¼‘æ†©è©³ç´°ãƒ¢ãƒ¼ãƒ€ãƒ«ã®å¤–å´ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹æ©Ÿèƒ½ã‚’è¨­å®š
        document.addEventListener('DOMContentLoaded', function() {
            const breakDetailModal = document.getElementById('breakDetailModal');
            if (breakDetailModal) {
                breakDetailModal.addEventListener('click', function(event) {
                    if (event.target === breakDetailModal) {
                        closeBreakDetailModal();
                    }
                });
            }
        });

        // ç·¨é›†æ™‚ã®ä¼‘æ†©ã‚¿ã‚¤ãƒˆãƒ«é¸æŠå‡¦ç†
        function handleEditBreakTitleChange() {
            const breakTitle = document.getElementById('editBreakTitle');
            const customBreakTitle = document.getElementById('editCustomBreakTitle');
            const customInput = document.getElementById('editCustomBreakTitleInput');
            
            if (breakTitle.value === 'ãã®ä»–') {
                customBreakTitle.style.display = 'block';
                customInput.value = window.currentBreakReservation?.customer || '';
            } else {
                customBreakTitle.style.display = 'none';
                customInput.value = '';
            }
        }

        // ä¸€æ‹¬äºˆç´„ä½œæˆãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
        function openBulkReservationModal() {
            console.log('ğŸ” Opening bulk reservation modal...');
            
            // ãƒ•ã‚©ãƒ¼ãƒ ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆæœ€åˆã«å®Ÿè¡Œï¼‰
            document.getElementById('bulkReservationForm').reset();
            
            // ç¾åœ¨ã®æ—¥ä»˜ã‚’è¨­å®š
            const bulkCurrentDate = new Date();
            const startDateValue = bulkCurrentDate.toISOString().split('T')[0];
            document.getElementById('bulkStartDate').value = startDateValue;
            
            // 1é€±é–“å¾Œã‚’çµ‚äº†æ—¥ã¨ã—ã¦è¨­å®š
            const nextWeek = new Date(bulkCurrentDate);
            nextWeek.setDate(bulkCurrentDate.getDate() + 7);
            const endDateValue = nextWeek.toISOString().split('T')[0];
            document.getElementById('bulkEndDate').value = endDateValue;
            
            // ç¾åœ¨æ™‚åˆ»ã‚’è¨­å®š
            const currentTime = `${String(bulkCurrentDate.getHours()).padStart(2, '0')}:${String(Math.floor(bulkCurrentDate.getMinutes() / 10) * 10).padStart(2, '0')}`;
            document.getElementById('bulkStartTime').value = currentTime;
            
            // æ›œæ—¥ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚’å…¨ã¦ãƒã‚§ãƒƒã‚¯
            document.querySelectorAll('#bulkDaysOfWeek input[type="checkbox"]').forEach(checkbox => {
                checkbox.checked = true;
            });
            
            // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒªã‚¹ãƒˆã‚’ã‚¯ãƒªã‚¢
            document.getElementById('bulkPreviewList').innerHTML = '';
            document.getElementById('submitBulkBtn').disabled = true;
            
            // ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šè¨­å®šã•ã‚ŒãŸå€¤ã‚’ç¢ºèª
            console.log('ğŸ” Modal initialized with:', {
                startDate: startDateValue,
                endDate: endDateValue,
                startTime: currentTime,
                selectedDays: Array.from(document.querySelectorAll('#bulkDaysOfWeek input[type="checkbox"]:checked')).map(cb => cb.value)
            });
            
            // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã®è¨­å®š
            setupBulkReservationValidation();
            
            // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼æ§‹é€ ã‚’èª¿æŸ»ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
            inspectCalendarStructure();
            
            document.getElementById('bulkReservationModal').style.display = 'block';
        }
        
        // ä¸€æ‹¬äºˆç´„ã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š
        function setupBulkReservationValidation() {
            // æ™‚é–“ã€æ—¥ä»˜ã€ã‚³ãƒ¼ã‚¹ãŒå¤‰æ›´ã•ã‚ŒãŸã¨ãã«ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§ãƒã‚§ãƒƒã‚¯
            const timeInput = document.getElementById('bulkStartTime');
            const durationSelect = document.getElementById('bulkDuration');
            const startDateInput = document.getElementById('bulkStartDate');
            const endDateInput = document.getElementById('bulkEndDate');
            
            const validateInputs = () => {
                const startTime = timeInput.value;
                const duration = parseInt(durationSelect.value);
                const startDate = new Date(startDateInput.value);
                const endDate = new Date(endDateInput.value);
                const selectedDays = Array.from(document.querySelectorAll('#bulkDaysOfWeek input[type="checkbox"]:checked'))
                    .map(cb => parseInt(cb.value));
                
                if (startTime && duration && !isNaN(startDate.getTime()) && !isNaN(endDate.getTime()) && selectedDays.length > 0) {
                    // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§é‡è¤‡ãƒã‚§ãƒƒã‚¯
                    const conflictCheck = performFinalConflictCheck(startDate, endDate, startTime, duration, selectedDays);
                    if (conflictCheck.hasConflicts) {
                        showMessage(`âš ï¸ é‡è¤‡ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸ: ${conflictCheck.conflictDates.join(', ')}`, 'warning');
                    }
                }
            };
            
            timeInput.addEventListener('change', validateInputs);
            durationSelect.addEventListener('change', validateInputs);
            startDateInput.addEventListener('change', validateInputs);
            endDateInput.addEventListener('change', validateInputs);
            
            // æ›œæ—¥ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®å¤‰æ›´ã‚‚ç›£è¦–
            document.querySelectorAll('#bulkDaysOfWeek input[type="checkbox"]').forEach(checkbox => {
                checkbox.addEventListener('change', validateInputs);
            });
        }
        
        // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼æ§‹é€ ã‚’èª¿æŸ»ã™ã‚‹é–¢æ•°ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
        function inspectCalendarStructure() {
            console.log('ğŸ” Inspecting calendar structure...');
            
            // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã®æ—¥ä»˜ã‚»ãƒ«ã‚’æ¢ã™
            const dateCells = document.querySelectorAll('[data-date]');
            console.log('ğŸ” Date cells found:', dateCells.length);
            if (dateCells.length > 0) {
                console.log('ğŸ” Sample date cell:', dateCells[0]);
                console.log('ğŸ” Sample data-date attribute:', dateCells[0].getAttribute('data-date'));
            }
            
            // äºˆç´„è¦ç´ ã‚’æ¢ã™
            const reservationElements = document.querySelectorAll('.reservation-block, .reservation-item, [class*="reservation"]');
            console.log('ğŸ” Reservation elements found:', reservationElements.length);
            if (reservationElements.length > 0) {
                console.log('ğŸ” Sample reservation element:', reservationElements[0]);
                console.log('ğŸ” Sample reservation classes:', reservationElements[0].className);
                console.log('ğŸ” Sample reservation data attributes:', {
                    'data-reservation-id': reservationElements[0].getAttribute('data-reservation-id'),
                    'data-original-date-key': reservationElements[0].getAttribute('data-original-date-key'),
                    'data-date': reservationElements[0].getAttribute('data-date')
                });
            }
            
            // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã®å…¨ä½“çš„ãªæ§‹é€ 
            const calendarContainer = document.querySelector('.calendar-container, .calendar, [class*="calendar"]');
            if (calendarContainer) {
                console.log('ğŸ” Calendar container found:', calendarContainer);
                console.log('ğŸ” Calendar container classes:', calendarContainer.className);
            }
        }

        // ä¸€æ‹¬äºˆç´„ä½œæˆãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
        function closeBulkReservationModal() {
            document.getElementById('bulkReservationModal').style.display = 'none';
        }

        // ä¸€æ‹¬äºˆç´„ã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’è¡¨ç¤º
        async function previewBulkReservations() {
            const startDateValue = document.getElementById('bulkStartDate').value;
            const endDateValue = document.getElementById('bulkEndDate').value;
            const startTime = document.getElementById('bulkStartTime').value;
            const duration = parseInt(document.getElementById('bulkDuration').value);
            const selectedDays = Array.from(document.querySelectorAll('#bulkDaysOfWeek input[type="checkbox"]:checked'))
                .map(cb => parseInt(cb.value));
            
            // ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šæ›œæ—¥é¸æŠã®è©³ç´°ã‚’ãƒ­ã‚°
            console.log('ğŸ” Day selection debug:', {
                allCheckboxes: document.querySelectorAll('#bulkDaysOfWeek input[type="checkbox"]').length,
                checkedCheckboxes: document.querySelectorAll('#bulkDaysOfWeek input[type="checkbox"]:checked').length,
                selectedDays: selectedDays,
                checkboxValues: Array.from(document.querySelectorAll('#bulkDaysOfWeek input[type="checkbox"]')).map(cb => ({ id: cb.id, value: cb.value, checked: cb.checked }))
            });
            
            // ã‚ˆã‚Šå³å¯†ãªãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
            if (!startDateValue || !endDateValue || !startTime || !duration || selectedDays.length === 0) {
                // ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šã©ã®é …ç›®ãŒç©ºã‹ã‚’ç‰¹å®š
                const missingFields = [];
                if (!startDateValue) missingFields.push('é–‹å§‹æ—¥');
                if (!endDateValue) missingFields.push('çµ‚äº†æ—¥');
                if (!startTime) missingFields.push('é–‹å§‹æ™‚é–“');
                if (!duration) missingFields.push('ã‚³ãƒ¼ã‚¹é¸æŠ');
                if (selectedDays.length === 0) missingFields.push('å¯¾è±¡æ›œæ—¥');
                
                console.log('Missing fields:', missingFields);
                showMessage(`ä»¥ä¸‹ã®é …ç›®ãŒå…¥åŠ›ã•ã‚Œã¦ã„ã¾ã›ã‚“: ${missingFields.join(', ')}`, 'error');
                return;
            }
            
            // æ—¥ä»˜ã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯
            const startDate = new Date(startDateValue);
            const endDate = new Date(endDateValue);
            
            if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                showMessage('æ—¥ä»˜ãŒæ­£ã—ãå…¥åŠ›ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚', 'error');
                return;
            }
            
            if (startDate > endDate) {
                showMessage('é–‹å§‹æ—¥ã¯çµ‚äº†æ—¥ã‚ˆã‚Šå‰ã®æ—¥ä»˜ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚', 'error');
                return;
            }
            
            // ãƒ“ã‚¸ãƒã‚¹ã‚¢ãƒ¯ãƒ¼ã®æ¤œè¨¼ï¼ˆå„æ—¥ä»˜ã®ã‚·ãƒ•ãƒˆè¨­å®šã‚’ãƒã‚§ãƒƒã‚¯ï¼‰
            let businessHoursValid = true;
            let invalidDates = [];
            let businessHoursCheckDate = new Date(startDate);
            
            // éåŒæœŸã§å–¶æ¥­æ™‚é–“ã‚’ãƒã‚§ãƒƒã‚¯
            const checkBusinessHours = async () => {
                while (businessHoursCheckDate <= endDate) {
                    if (selectedDays.includes(businessHoursCheckDate.getDay())) {
                        const isValid = await isWithinBusinessHours(startTime, duration, businessHoursCheckDate);
                        if (!isValid) {
                            businessHoursValid = false;
                            invalidDates.push(businessHoursCheckDate.toLocaleDateString('ja-JP'));
                        }
                    }
                    businessHoursCheckDate.setDate(businessHoursCheckDate.getDate() + 1);
                }
                
                if (!businessHoursValid) {
                    showMessage(`é¸æŠã•ã‚ŒãŸæ™‚é–“ãŒå–¶æ¥­æ™‚é–“å¤–ã®æ—¥ä»˜ãŒã‚ã‚Šã¾ã™: ${invalidDates.join(', ')}ã€‚ã‚·ãƒ•ãƒˆè¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚`, 'error');
                    return false;
                }
                
                return true;
            };
            
            // å–¶æ¥­æ™‚é–“ãƒã‚§ãƒƒã‚¯ã‚’å®Ÿè¡Œ
            const businessHoursOk = await checkBusinessHours();
            if (!businessHoursOk) {
                return;
            }
            
            const previewList = document.getElementById('bulkPreviewList');
            previewList.innerHTML = '';
            
            let previewDate = new Date(startDate);
            let reservationCount = 0;
            let conflictCount = 0;
            
            while (previewDate <= endDate) {
                if (selectedDays.includes(previewDate.getDay())) {
                    const dateStr = `${previewDate.getFullYear()}å¹´${String(previewDate.getMonth() + 1).padStart(2, '0')}æœˆ${String(previewDate.getDate()).padStart(2, '0')}æ—¥`;
                    const dayNames = ['æ—¥', 'æœˆ', 'ç«', 'æ°´', 'æœ¨', 'é‡‘', 'åœŸ'];
                    const dayName = dayNames[previewDate.getDay()];
                    
                    // æ—¢å­˜ã®äºˆç´„ã¨ã®é‡è¤‡ãƒã‚§ãƒƒã‚¯
                    const hasConflict = checkReservationConflict(previewDate, startTime, duration);
                    
                    const previewItem = document.createElement('div');
                    previewItem.className = 'bulk-preview-item';
                    if (hasConflict) {
                        previewItem.classList.add('conflict');
                        previewItem.innerHTML = `
                            <span class="date">${dateStr}(${dayName})</span>
                            <span class="time">${startTime} - ${calculateEndTime(startTime, duration)}</span>
                            <span class="conflict-warning">âš ï¸ æ—¢å­˜äºˆç´„ã¨é‡è¤‡</span>
                        `;
                        conflictCount++;
                    } else {
                        previewItem.innerHTML = `
                            <span class="date">${dateStr}(${dayName})</span>
                            <span class="time">${startTime} - ${calculateEndTime(startTime, duration)}</span>
                        `;
                        reservationCount++;
                    }
                    previewList.appendChild(previewItem);
                }
                previewDate.setDate(previewDate.getDate() + 1);
            }
            
            if (conflictCount > 0) {
                showMessage(`${conflictCount}ä»¶ã®é‡è¤‡ãŒã‚ã‚Šã¾ã™ã€‚é‡è¤‡ã™ã‚‹æ—¥ä»˜ã¯äºˆç´„ã‚’ä½œæˆã§ãã¾ã›ã‚“ã€‚`, 'warning');
                document.getElementById('submitBulkBtn').disabled = true;
            } else if (reservationCount > 0) {
                // æœ€çµ‚çš„ãªé‡è¤‡ãƒã‚§ãƒƒã‚¯ï¼ˆã‚ˆã‚Šå³å¯†ï¼‰
                const finalConflictCheck = performFinalConflictCheck(startDate, endDate, startTime, duration, selectedDays);
                if (finalConflictCheck.hasConflicts) {
                    showMessage(`æœ€çµ‚ãƒã‚§ãƒƒã‚¯ã§é‡è¤‡ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸ: ${finalConflictCheck.conflictDates.join(', ')}ã€‚äºˆç´„ã‚’ä½œæˆã§ãã¾ã›ã‚“ã€‚`, 'error');
                    document.getElementById('submitBulkBtn').disabled = true;
                } else {
                    document.getElementById('submitBulkBtn').disabled = false;
                    showMessage(`${reservationCount}ä»¶ã®äºˆç´„ã‚’ä½œæˆã—ã¾ã™ã€‚`, 'info');
                }
            } else {
                showMessage('é¸æŠã•ã‚ŒãŸæœŸé–“ã¨æ›œæ—¥ã«è©²å½“ã™ã‚‹æ—¥ä»˜ãŒã‚ã‚Šã¾ã›ã‚“ã€‚', 'error');
                document.getElementById('submitBulkBtn').disabled = true;
            }
        }

        // çµ‚äº†æ™‚é–“ã‚’è¨ˆç®—
        function calculateEndTime(startTime, durationMinutes) {
            const [hours, minutes] = startTime.split(':').map(Number);
            const startDate = new Date();
            startDate.setHours(hours, minutes, 0, 0);
            
            const endDate = new Date(startDate.getTime() + durationMinutes * 60000);
            return `${String(endDate.getHours()).padStart(2, '0')}:${String(endDate.getMinutes()).padStart(2, '0')}`;
        }

        // å–¶æ¥­æ™‚é–“å†…ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆã‚·ãƒ•ãƒˆè¨­å®šã‚’è€ƒæ…®ï¼‰
        async function isWithinBusinessHours(startTime, durationMinutes, date = null) {
            // æ—¥ä»˜ãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã€ã‚·ãƒ•ãƒˆè¨­å®šã‚’ãƒã‚§ãƒƒã‚¯
            if (date) {
                const dateKey = date.toISOString().split('T')[0];
                const dayOfWeek = date.getDay();
                
                console.log(`ğŸ” Checking business hours for ${dateKey} (day ${dayOfWeek}) at ${startTime}`);
                
                // æ–¹æ³•1: ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã®æ—¢å­˜ã®ãƒ“ã‚¸ãƒã‚¹ã‚¢ãƒ¯ãƒ¼é–¢æ•°ã‚’ä½¿ç”¨ï¼ˆé€šå¸¸ã®äºˆç´„ã¨åŒã˜ï¼‰
                if (typeof window.isBusinessHour === 'function') {
                    console.log(`ğŸ” Using window.isBusinessHour for ${dateKey} at ${startTime}`);
                    
                    // æ™‚é–“ã‚’åˆ†ã«å¤‰æ›
                    const [startHour, startMinute] = startTime.split(':').map(Number);
                    const startMinutes = startHour * 60 + startMinute;
                    
                    // çµ‚äº†æ™‚é–“ã‚’è¨ˆç®—
                    const endMinutes = startMinutes + durationMinutes;
                    
                    // å„æ™‚é–“ã‚¹ãƒ­ãƒƒãƒˆã‚’ãƒã‚§ãƒƒã‚¯
                    for (let timeInMinutes = startMinutes; timeInMinutes < endMinutes; timeInMinutes += 10) {
                        const timeStr = `${Math.floor(timeInMinutes / 60).toString().padStart(2, '0')}:${(timeInMinutes % 60).toString().padStart(2, '0')}`;
                        
                        // ç¾åœ¨ã®æ—¥ä»˜ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ç”¨ã™ã‚‹ãŸã‚ã€æ—¥ä»˜ã‚’æŒ‡å®šã—ã¦isBusinessHourã‚’å‘¼ã³å‡ºã—
                        const isAvailable = window.isBusinessHour(dayOfWeek, timeStr, date);
                        
                        console.log(`ğŸ” Checking time ${timeStr} (${timeInMinutes}min) for day ${dayOfWeek} on ${dateKey}: ${isAvailable}`);
                        
                        if (!isAvailable) {
                            console.log(`âŒ Time ${timeStr} is not available on day ${dayOfWeek} for ${dateKey}`);
                            return false;
                        }
                    }
                    
                    console.log(`âœ… All time slots are available for ${dateKey} at ${startTime}`);
                    return true;
                }
                
                // æ–¹æ³•2: ã‚·ãƒ•ãƒˆAPIã‚’ä½¿ç”¨ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
                try {
                    const shiftSettings = await getShiftSettingsForDate(date);
                    if (shiftSettings && shiftSettings.schedule) {
                        const schedule = shiftSettings.schedule;
                        console.log(`ğŸ” Found shift schedule:`, schedule);
                        
                        // ã‚·ãƒ•ãƒˆè¨­å®šã‹ã‚‰å–¶æ¥­æ™‚é–“ã‚’å–å¾—
                        const businessSlots = schedule.business_slots || [];
                        if (businessSlots.length > 0) {
                            const [startHour, startMinute] = startTime.split(':').map(Number);
                            const [endHour, endMinute] = calculateEndTime(startTime, durationMinutes).split(':').map(Number);
                            
                            const startMinutes = startHour * 60 + startMinute;
                            const endMinutes = endHour * 60 + endMinute;
                            
                            // å„å–¶æ¥­æ™‚é–“ã‚¹ãƒ­ãƒƒãƒˆã‚’ãƒã‚§ãƒƒã‚¯
                            for (const slot of businessSlots) {
                                const slotStart = slot.start_time;
                                const slotEnd = slot.end_time;
                                
                                if (slotStart && slotEnd) {
                                    const [slotStartHour, slotStartMin] = slotStart.split(':').map(Number);
                                    const [slotEndHour, slotEndMin] = slotEnd.split(':').map(Number);
                                    
                                    const slotStartMinutes = slotStartHour * 60 + slotStartMin;
                                    const slotEndMinutes = slotEndHour * 60 + slotEndMin;
                                    
                                    console.log(`ğŸ” Checking slot: ${slotStart} - ${slotEnd} (${slotStartMinutes}-${slotEndMinutes}) vs ${startMinutes}-${endMinutes}`);
                                    
                                    // äºˆç´„æ™‚é–“ãŒå–¶æ¥­æ™‚é–“ã‚¹ãƒ­ãƒƒãƒˆå†…ã«åã¾ã£ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                                    if (startMinutes >= slotStartMinutes && endMinutes <= slotEndMinutes) {
                                        console.log(`âœ… Time slot ${startTime}-${endMinutes} is within business hours ${slotStart}-${slotEnd}`);
                                        return true;
                                    }
                                }
                            }
                            
                            console.log(`âŒ Time slot ${startTime} (${startMinutes}-${endMinutes}) is outside all business hours`);
                            return false;
                        }
                    }
                    
                    // ã‚·ãƒ•ãƒˆãŒé–‰åº—ã®å ´åˆ
                    if (shiftSettings && shiftSettings.isClosed) {
                        console.log(`ğŸš« Shift is closed for ${dateKey}`);
                        return false;
                    }
                    
                    console.log(`ğŸ” No shift schedule found, using calendar's business hour logic`);
                    
                } catch (error) {
                    console.error(`ğŸ” Error checking shift settings:`, error);
                    console.log(`ğŸ” Falling back to calendar's business hour logic`);
                }
            }
            
            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã®æ—¢å­˜ã®ãƒ“ã‚¸ãƒã‚¹ã‚¢ãƒ¯ãƒ¼ãƒ­ã‚¸ãƒƒã‚¯ã‚’ä½¿ç”¨
            console.log(`ğŸ” Using calendar's business hour logic for ${startTime}`);
            
            // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã®æ—¢å­˜ã®å–¶æ¥­æ™‚é–“ãƒã‚§ãƒƒã‚¯ã‚’ä½¿ç”¨
            if (typeof window.isBusinessHour === 'function') {
                const [startHour, startMinute] = startTime.split(':').map(Number);
                const startMinutes = startHour * 60 + startMinute;
                const endMinutes = startMinutes + durationMinutes;
                
                // ç¾åœ¨ã®æ—¥ä»˜ã®æ›œæ—¥ã‚’å–å¾—ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯æœˆæ›œæ—¥ï¼‰
                const dayOfWeek = date ? date.getDay() : 1;
                
                // å„æ™‚é–“ã‚¹ãƒ­ãƒƒãƒˆã‚’ãƒã‚§ãƒƒã‚¯
                for (let timeInMinutes = startMinutes; timeInMinutes < endMinutes; timeInMinutes += 10) {
                    const timeStr = `${Math.floor(timeInMinutes / 60).toString().padStart(2, '0')}:${(timeInMinutes % 60).toString().padStart(2, '0')}`;
                    const isAvailable = window.isBusinessHour(dayOfWeek, timeStr, date);
                    
                    if (!isAvailable) {
                        console.log(`âŒ Time ${timeStr} is not available on day ${dayOfWeek} for ${date ? date.toISOString().split('T')[0] : 'unknown date'}`);
                        return false;
                    }
                }
                
                console.log(`âœ… All time slots are available using calendar's business hour logic`);
                return true;
            }
            
            // æœ€çµ‚ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: åŸºæœ¬çš„ãªå–¶æ¥­æ™‚é–“ãƒã‚§ãƒƒã‚¯
            const businessHours = getBusinessHours();
            const businessStart = businessHours.start;
            const businessEnd = businessHours.end;
            
            const [startHour, startMinute] = startTime.split(':').map(Number);
            const [endHour, endMinute] = calculateEndTime(startTime, durationMinutes).split(':').map(Number);
            const [businessStartHour, businessStartMinute] = businessStart.split(':').map(Number);
            const [businessEndHour, businessEndMinute] = businessEnd.split(':').map(Number);
            
            const startMinutes = startHour * 60 + startMinute;
            const endMinutes = endHour * 60 + endMinute;
            const businessStartMinutes = businessStartHour * 60 + businessStartMinute;
            const businessEndMinutes = businessEndHour * 60 + businessEndMinute;
            
            const isWithin = startMinutes >= businessStartMinutes && endMinutes <= businessEndMinutes;
            console.log(`ğŸ” Final fallback business hours check: ${startTime} (${startMinutes}-${endMinutes}) vs ${businessStart}-${businessEnd}: ${isWithin}`);
            
            return isWithin;
        }
        
        // æŒ‡å®šã•ã‚ŒãŸæ—¥ä»˜ã®ã‚·ãƒ•ãƒˆè¨­å®šã‚’å–å¾—
        async function getShiftSettingsForDate(date) {
            try {
                // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã®ã‚·ãƒ•ãƒˆè¨­å®šã‚’å–å¾—ã™ã‚‹é–¢æ•°ã‚’å‘¼ã³å‡ºã—
                if (typeof window.getBusinessHoursForDate === 'function') {
                    console.log(`ğŸ” Using window.getBusinessHoursForDate for ${date.toISOString().split('T')[0]}`);
                    return await window.getBusinessHoursForDate(date);
                }
                
                // ä»£æ›¿æ–¹æ³•: ã‚·ãƒ•ãƒˆAPIã‚’ç›´æ¥å‘¼ã³å‡ºã—
                const dateStr = date.toISOString().split('T')[0];
                console.log(`ğŸ” Fetching shift data from API for ${dateStr}`);
                
                const response = await fetch(`/admin/shifts/for_date?date=${dateStr}`);
                const data = await response.json();
                
                if (data.success && data.shift) {
                    console.log(`ğŸ” Found shift data:`, data.shift);
                    return {
                        schedule: {
                            business_slots: [{
                                start_time: data.shift.start_time,
                                end_time: data.shift.end_time
                            }]
                        },
                        shift: data.shift,
                        isClosed: data.shift.shift_type === 'closed'
                    };
                }
                
                console.log(`ğŸ” No shift data found for ${dateStr}, using default`);
                return null;
                
            } catch (error) {
                console.error(`ğŸ” Error getting shift settings:`, error);
                return null;
            }
        }
        
        // å–¶æ¥­æ™‚é–“ã‚’å–å¾—ï¼ˆè¨­å®šã‹ã‚‰å‹•çš„ã«å–å¾—å¯èƒ½ï¼‰
        function getBusinessHours() {
            // ç¾åœ¨ã®é€±ã®å–¶æ¥­æ™‚é–“è¨­å®šã‚’å–å¾—
            if (window.currentWeekSchedule && window.currentWeekSchedule.business_hours) {
                return window.currentWeekSchedule.business_hours;
            }
            
            // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å–¶æ¥­æ™‚é–“
            return {
                start: '10:00',
                end: '21:00'
            };
        }

        // æ—¢å­˜ã®äºˆç´„ã¨ã®é‡è¤‡ãƒã‚§ãƒƒã‚¯
        function checkReservationConflict(date, startTime, duration) {
            const dateKey = date.toISOString().split('T')[0];
            const dayReservations = reservations[dateKey] || [];
            
            const [startHour, startMinute] = startTime.split(':').map(Number);
            const startMinutes = startHour * 60 + startMinute;
            const endMinutes = startMinutes + duration;
            
            console.log(`ğŸ” Checking conflict for ${dateKey} at ${startTime} (${duration}min):`, {
                startMinutes,
                endMinutes,
                existingReservations: dayReservations.length
            });
            
            // æ–¹æ³•1: reservationsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ãƒã‚§ãƒƒã‚¯
            const conflictFromObject = dayReservations.some(reservation => {
                // ä¼‘æ†©æ©Ÿèƒ½ã¯ç„¡åŠ¹åŒ–
                
                // start_timeã¨end_timeãŒå­˜åœ¨ã™ã‚‹å ´åˆ
                if (reservation.start_time && reservation.end_time) {
                    const reservationStart = new Date(reservation.start_time);
                    const reservationEnd = new Date(reservation.end_time);
                    
                    const reservationStartMinutes = reservationStart.getHours() * 60 + reservationStart.getMinutes();
                    const reservationEndMinutes = reservationEnd.getHours() * 60 + reservationEnd.getMinutes();
                    
                    console.log(`ğŸ” Comparing with reservation:`, {
                        reservationStart: reservationStart.toLocaleTimeString(),
                        reservationEnd: reservationEnd.toLocaleTimeString(),
                        reservationStartMinutes,
                        reservationEndMinutes,
                        overlap: (startMinutes < reservationEndMinutes && endMinutes > reservationStartMinutes)
                    });
                    
                    // æ™‚é–“ã®é‡è¤‡ãƒã‚§ãƒƒã‚¯
                    return (startMinutes < reservationEndMinutes && endMinutes > reservationStartMinutes);
                }
                
                // dateã¨timeãŒå­˜åœ¨ã™ã‚‹å ´åˆï¼ˆå¤ã„å½¢å¼ï¼‰
                if (reservation.date && reservation.time) {
                    const [reservationHour, reservationMinute] = reservation.time.split(':').map(Number);
                    const reservationStartMinutes = reservationHour * 60 + reservationMinute;
                    const reservationEndMinutes = reservationStartMinutes + (reservation.duration || 60);
                    
                    console.log(`ğŸ” Comparing with old format reservation:`, {
                        reservationTime: reservation.time,
                        reservationDuration: reservation.duration,
                        reservationStartMinutes,
                        reservationEndMinutes,
                        overlap: (startMinutes < reservationEndMinutes && endMinutes > reservationStartMinutes)
                    });
                    
                    return (startMinutes < reservationEndMinutes && endMinutes > reservationStartMinutes);
                }
                
                return false;
            });
            
            // æ–¹æ³•2: DOMã‹ã‚‰ç›´æ¥ãƒã‚§ãƒƒã‚¯ï¼ˆã‚ˆã‚Šç¢ºå®Ÿï¼‰
            const conflictFromDOM = checkConflictFromDOM(date, startTime, duration);
            
            console.log(`ğŸ” Conflict check results:`, {
                fromObject: conflictFromObject,
                fromDOM: conflictFromDOM,
                finalResult: conflictFromObject || conflictFromDOM
            });
            
            return conflictFromObject || conflictFromDOM;
        }
        
        // DOMã‹ã‚‰ç›´æ¥é‡è¤‡ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆã‚ˆã‚Šç¢ºå®Ÿãªæ–¹æ³•ï¼‰
        function checkConflictFromDOM(date, startTime, duration) {
            const dateKey = date.toISOString().split('T')[0];
            const [year, month, day] = dateKey.split('-').map(Number);
            
            console.log(`ğŸ” Looking for day cell with date: ${dateKey}`);
            
            // è¤‡æ•°ã®ã‚»ãƒ¬ã‚¯ã‚¿ãƒ¼ã‚’è©¦ã™
            let dayCell = document.querySelector(`[data-date="${dateKey}"]`);
            if (!dayCell) {
                // åˆ¥ã®å½¢å¼ã‚’è©¦ã™
                dayCell = document.querySelector(`[data-date*="${dateKey}"]`);
            }
            if (!dayCell) {
                // æ—¥ä»˜æ–‡å­—åˆ—ã‚’å«ã‚€è¦ç´ ã‚’æ¢ã™
                dayCell = document.querySelector(`[data-date*="${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}"]`);
            }
            if (!dayCell) {
                // ã‚ˆã‚ŠæŸ”è»Ÿãªæ¤œç´¢
                const allCells = document.querySelectorAll('[data-date]');
                console.log(`ğŸ” All cells with data-date:`, Array.from(allCells).map(cell => cell.getAttribute('data-date')));
                
                dayCell = Array.from(allCells).find(cell => {
                    const cellDate = cell.getAttribute('data-date');
                    return cellDate && cellDate.includes(dateKey);
                });
            }
            
            if (!dayCell) {
                console.log(`ğŸ” Day cell not found for ${dateKey}, trying alternative approach...`);
                
                // ä»£æ›¿ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ: ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã®æ—¥ä»˜ã‚»ãƒ«ã‚’ç›´æ¥æ¢ã™
                const calendarCells = document.querySelectorAll('.calendar-day, .day-cell, [class*="day"], [class*="date"]');
                console.log(`ğŸ” Calendar cells found:`, calendarCells.length);
                
                // æ—¥ä»˜ãƒ†ã‚­ã‚¹ãƒˆã§æ¤œç´¢
                dayCell = Array.from(calendarCells).find(cell => {
                    const cellText = cell.textContent || '';
                    const datePattern = new RegExp(`${year}å¹´?${month}æœˆ?${day}æ—¥?|${month}/${day}|${month}-${day}`);
                    return datePattern.test(cellText);
                });
            }
            
            if (!dayCell) {
                console.log(`ğŸ” Day cell still not found for ${dateKey}, using fallback method`);
                // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: äºˆç´„è¦ç´ ã‚’ç›´æ¥æ¤œç´¢
                return checkConflictFromReservationElements(startTime, duration);
            }
            
            console.log(`ğŸ” Found day cell:`, dayCell);
            
            // ãã®æ—¥ã®äºˆç´„è¦ç´ ã‚’å–å¾—
            const reservationElements = dayCell.querySelectorAll('.reservation-item, .break-item, .reservation-block, [class*="reservation"]');
            if (reservationElements.length === 0) {
                console.log(`ğŸ” No reservation elements found in day cell for ${dateKey}, trying global search`);
                return checkConflictFromReservationElements(startTime, duration);
            }
            
            const [startHour, startMinute] = startTime.split(':').map(Number);
            const startMinutes = startHour * 60 + startMinute;
            const endMinutes = startMinutes + duration;
            
            console.log(`ğŸ” DOM check for ${dateKey}:`, {
                startTime: startTime,
                duration: duration,
                startMinutes: startMinutes,
                endMinutes: endMinutes,
                reservationElements: reservationElements.length
            });
            
            return Array.from(reservationElements).some(element => {
                // ä¼‘æ†©ã¯é™¤å¤–
                if (element.classList.contains('break-item') || element.classList.contains('break')) {
                    return false;
                }
                
                // äºˆç´„ã®æ™‚é–“ã‚’å–å¾—ï¼ˆè¤‡æ•°ã®æ–¹æ³•ã‚’è©¦ã™ï¼‰
                let timeText = element.querySelector('.reservation-time')?.textContent;
                if (!timeText) {
                    timeText = element.querySelector('[class*="time"]')?.textContent;
                }
                if (!timeText) {
                    timeText = element.textContent;
                }
                
                if (!timeText) return false;
                
                console.log(`ğŸ” Checking element:`, element, `with time text:`, timeText);
                
                // æ™‚é–“ãƒ†ã‚­ã‚¹ãƒˆã‚’ãƒ‘ãƒ¼ã‚¹ï¼ˆè¤‡æ•°ã®å½¢å¼ã«å¯¾å¿œï¼‰
                let timeMatch = timeText.match(/(\d{1,2}):(\d{2})\s*-\s*(\d{1,2}):(\d{2})/);
                if (!timeMatch) {
                    timeMatch = timeText.match(/(\d{1,2}):(\d{2})/);
                }
                if (!timeMatch) {
                    timeMatch = timeText.match(/(\d{1,2}):(\d{2})\s*~(\d{1,2}):(\d{2})/);
                }
                
                if (!timeMatch) {
                    console.log(`ğŸ” Could not parse time from:`, timeText);
                    return false;
                }
                
                let startH, startM, endH, endM;
                if (timeMatch.length === 3) {
                    // é–‹å§‹æ™‚åˆ»ã®ã¿ã®å ´åˆã€durationã‹ã‚‰çµ‚äº†æ™‚åˆ»ã‚’è¨ˆç®—
                    [_, startH, startM] = timeMatch;
                    const startMinutes = parseInt(startH) * 60 + parseInt(startM);
                    const endMinutes = startMinutes + duration;
                    endH = Math.floor(endMinutes / 60);
                    endM = endMinutes % 60;
                } else {
                    [_, startH, startM, endH, endM] = timeMatch;
                }
                
                const reservationStartMinutes = parseInt(startH) * 60 + parseInt(startM);
                const reservationEndMinutes = parseInt(endH) * 60 + parseInt(endM);
                
                const hasOverlap = (startMinutes < reservationEndMinutes && endMinutes > reservationStartMinutes);
                
                console.log(`ğŸ” DOM element check:`, {
                    timeText: timeText,
                    reservationStart: `${startH}:${startM}`,
                    reservationEnd: `${endH}:${endM}`,
                    reservationStartMinutes: reservationStartMinutes,
                    reservationEndMinutes: reservationEndMinutes,
                    hasOverlap: hasOverlap
                });
                
                return hasOverlap;
            });
        }
        
        // äºˆç´„è¦ç´ ã‚’ç›´æ¥æ¤œç´¢ã—ã¦é‡è¤‡ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ–¹æ³•ï¼‰
        function checkConflictFromReservationElements(startTime, duration) {
            console.log(`ğŸ” Using fallback method: checking all reservation elements`);
            
            const [startHour, startMinute] = startTime.split(':').map(Number);
            const startMinutes = startHour * 60 + startMinute;
            const endMinutes = startMinutes + duration;
            
            // ã™ã¹ã¦ã®äºˆç´„è¦ç´ ã‚’æ¤œç´¢
            const allReservations = document.querySelectorAll('.reservation-block, .reservation-item, [class*="reservation"]');
            console.log(`ğŸ” Found ${allReservations.length} total reservation elements`);
            
            return Array.from(allReservations).some(element => {
                // ä¼‘æ†©ã¯é™¤å¤–
                if (element.classList.contains('break') || element.classList.contains('break-item')) {
                    return false;
                }
                
                // è¦ç´ ã®æ—¥ä»˜ã‚’å–å¾—
                const elementDate = element.getAttribute('data-original-date-key') || 
                                  element.getAttribute('data-date') || 
                                  element.closest('[data-date]')?.getAttribute('data-date');
                
                if (!elementDate) {
                    console.log(`ğŸ” Element has no date attribute:`, element);
                    return false;
                }
                
                // æ™‚é–“ã‚’å–å¾—
                const timeText = element.textContent || '';
                const timeMatch = timeText.match(/(\d{1,2}):(\d{2})/);
                if (!timeMatch) return false;
                
                const [_, hour, minute] = timeMatch;
                const reservationStartMinutes = parseInt(hour) * 60 + parseInt(minute);
                const reservationEndMinutes = reservationStartMinutes + 60; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ60åˆ†
                
                const hasOverlap = (startMinutes < reservationEndMinutes && endMinutes > reservationStartMinutes);
                
                if (hasOverlap) {
                    console.log(`ğŸ” Found overlap in fallback check:`, {
                        elementDate: elementDate,
                        elementTime: `${hour}:${minute}`,
                        hasOverlap: hasOverlap
                    });
                }
                
                return hasOverlap;
            });
        }
        
        // æ™‚é–“ã‚’ã‚³ãƒ¼ã‚¹å½¢å¼ã«å¤‰æ›
        function getCourseFromDuration(duration) {
            switch (duration) {
                case 40:
                    return '40åˆ†';
                case 60:
                    return '60åˆ†';
                case 80:
                    return '80åˆ†';
                default:
                    return '60åˆ†';
            }
        }
        
        // æœ€çµ‚çš„ãªé‡è¤‡ãƒã‚§ãƒƒã‚¯ï¼ˆã‚ˆã‚Šå³å¯†ï¼‰
        function performFinalConflictCheck(startDate, endDate, startTime, duration, selectedDays) {
            console.log('ğŸ” Performing final conflict check...');
            
            const conflicts = [];
            let conflictDate = new Date(startDate);
            
            while (conflictDate <= endDate) {
                if (selectedDays.includes(conflictDate.getDay())) {
                    const hasConflict = checkReservationConflict(conflictDate, startTime, duration);
                    if (hasConflict) {
                        conflicts.push(conflictDate.toLocaleDateString('ja-JP'));
                    }
                }
                conflictDate.setDate(conflictDate.getDate() + 1);
            }
            
            // è¿½åŠ : ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼è¡¨ç¤ºã‹ã‚‰ç›´æ¥é‡è¤‡ã‚’ãƒã‚§ãƒƒã‚¯
            const visualConflicts = checkVisualConflicts(startDate, endDate, startTime, duration, selectedDays);
            if (visualConflicts.length > 0) {
                conflicts.push(...visualConflicts);
            }
            
            const result = {
                hasConflicts: conflicts.length > 0,
                conflictDates: conflicts
            };
            
            console.log('ğŸ” Final conflict check result:', result);
            return result;
        }
        
        // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼è¡¨ç¤ºã‹ã‚‰ç›´æ¥é‡è¤‡ã‚’ãƒã‚§ãƒƒã‚¯
        function checkVisualConflicts(startDate, endDate, startTime, duration, selectedDays) {
            console.log('ğŸ” Checking visual conflicts in calendar display...');
            
            const conflicts = [];
            const [startHour, startMinute] = startTime.split(':').map(Number);
            const startMinutes = startHour * 60 + startMinute;
            const endMinutes = startMinutes + duration;
            
            // ã™ã¹ã¦ã®äºˆç´„ãƒ–ãƒ­ãƒƒã‚¯ã‚’å–å¾—
            const allReservationBlocks = document.querySelectorAll('.reservation-block');
            console.log(`ğŸ” Found ${allReservationBlocks.length} reservation blocks in calendar`);
            
            allReservationBlocks.forEach(block => {
                // ä¼‘æ†©ã¯é™¤å¤–
                if (block.classList.contains('break') || block.classList.contains('break-item')) {
                    return;
                }
                
                // äºˆç´„ã®æ—¥ä»˜ã‚’å–å¾—
                const blockDate = block.getAttribute('data-original-date-key') || 
                                block.getAttribute('data-date') || 
                                block.closest('[data-date]')?.getAttribute('data-date');
                
                if (!blockDate) {
                    console.log(`ğŸ” Block has no date:`, block);
                    return;
                }
                
                // é¸æŠã•ã‚ŒãŸæ—¥ä»˜ç¯„å›²å†…ã‹ãƒã‚§ãƒƒã‚¯
                const blockDateObj = new Date(blockDate);
                if (blockDateObj < startDate || blockDateObj > endDate) {
                    return;
                }
                
                // é¸æŠã•ã‚ŒãŸæ›œæ—¥ã‹ãƒã‚§ãƒƒã‚¯
                if (!selectedDays.includes(blockDateObj.getDay())) {
                    return;
                }
                
                // äºˆç´„ã®æ™‚é–“ã‚’å–å¾—
                const blockText = block.textContent || '';
                const timeMatch = blockText.match(/(\d{1,2}):(\d{2})/);
                if (!timeMatch) {
                    console.log(`ğŸ” Could not parse time from block:`, blockText);
                    return;
                }
                
                const [_, blockHour, blockMinute] = timeMatch;
                const blockStartMinutes = parseInt(blockHour) * 60 + parseInt(blockMinute);
                const blockEndMinutes = blockStartMinutes + 60; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ60åˆ†
                
                // é‡è¤‡ãƒã‚§ãƒƒã‚¯
                const hasOverlap = (startMinutes < blockEndMinutes && endMinutes > blockStartMinutes);
                
                if (hasOverlap) {
                    const conflictDate = blockDateObj.toLocaleDateString('ja-JP');
                    if (!conflicts.includes(conflictDate)) {
                        conflicts.push(conflictDate);
                        console.log(`ğŸ” Visual conflict detected:`, {
                            date: blockDate,
                            blockTime: `${blockHour}:${blockMinute}`,
                            newTime: startTime,
                            duration: duration,
                            hasOverlap: hasOverlap
                        });
                    }
                }
            });
            
            console.log(`ğŸ” Visual conflicts found:`, conflicts);
            return conflicts;
        }

        // ä¸€æ‹¬äºˆç´„ã‚’ä½œæˆ
        async function createBulkReservations() {
            const startDateValue = document.getElementById('bulkStartDate').value;
            const endDateValue = document.getElementById('bulkEndDate').value;
            const startTime = document.getElementById('bulkStartTime').value;
            const duration = parseInt(document.getElementById('bulkDuration').value);
            const selectedDays = Array.from(document.querySelectorAll('#bulkDaysOfWeek input[type="checkbox"]:checked'))
                .map(cb => parseInt(cb.value));
            const customerName = document.getElementById('bulkCustomerName').value;
            const customerPhone = document.getElementById('bulkCustomerPhone').value;
            const customerEmail = document.getElementById('bulkCustomerEmail').value;
            const note = document.getElementById('bulkNote').value;
            const status = document.getElementById('bulkStatus').value;
            
            // ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šæ›œæ—¥é¸æŠã®è©³ç´°ã‚’ãƒ­ã‚°
            console.log('ğŸ” Day selection debug (create):', {
                allCheckboxes: document.querySelectorAll('#bulkDaysOfWeek input[type="checkbox"]').length,
                checkedCheckboxes: document.querySelectorAll('#bulkDaysOfWeek input[type="checkbox"]:checked').length,
                selectedDays: selectedDays,
                checkboxValues: Array.from(document.querySelectorAll('#bulkDaysOfWeek input[type="checkbox"]')).map(cb => ({ id: cb.id, value: cb.value, checked: cb.checked }))
            });
            
            // ã‚ˆã‚Šå³å¯†ãªãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
            if (!startDateValue || !endDateValue || !startTime || !duration || selectedDays.length === 0 || !customerName || !customerPhone) {
                // ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šã©ã®é …ç›®ãŒç©ºã‹ã‚’ç‰¹å®š
                const missingFields = [];
                if (!startDateValue) missingFields.push('é–‹å§‹æ—¥');
                if (!endDateValue) missingFields.push('çµ‚äº†æ—¥');
                if (!startTime) missingFields.push('é–‹å§‹æ™‚é–“');
                if (!duration) missingFields.push('ã‚³ãƒ¼ã‚¹é¸æŠ');
                if (selectedDays.length === 0) missingFields.push('å¯¾è±¡æ›œæ—¥');
                if (!customerName) missingFields.push('ãŠå®¢æ§˜å');
                if (!customerPhone) missingFields.push('é›»è©±ç•ªå·');
                
                console.log('Missing fields:', missingFields);
                showMessage(`ä»¥ä¸‹ã®é …ç›®ãŒå…¥åŠ›ã•ã‚Œã¦ã„ã¾ã›ã‚“: ${missingFields.join(', ')}`, 'error');
                return;
            }
            
            // æ—¥ä»˜ã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯
            const startDate = new Date(startDateValue);
            const endDate = new Date(endDateValue);
            
            if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                showMessage('æ—¥ä»˜ãŒæ­£ã—ãå…¥åŠ›ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚', 'error');
                return;
            }
            
            if (startDate > endDate) {
                showMessage('é–‹å§‹æ—¥ã¯çµ‚äº†æ—¥ã‚ˆã‚Šå‰ã®æ—¥ä»˜ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚', 'error');
                return;
            }
            
            // ãƒ“ã‚¸ãƒã‚¹ã‚¢ãƒ¯ãƒ¼ã®æ¤œè¨¼ï¼ˆå„æ—¥ä»˜ã®ã‚·ãƒ•ãƒˆè¨­å®šã‚’ãƒã‚§ãƒƒã‚¯ï¼‰
            let businessHoursValid = true;
            let invalidDates = [];
            let businessHoursCheckDate = new Date(startDate);
            
            // éåŒæœŸã§å–¶æ¥­æ™‚é–“ã‚’ãƒã‚§ãƒƒã‚¯
            const checkBusinessHours = async () => {
                while (businessHoursCheckDate <= endDate) {
                    if (selectedDays.includes(businessHoursCheckDate.getDay())) {
                        const isValid = await isWithinBusinessHours(startTime, duration, businessHoursCheckDate);
                        if (!isValid) {
                            businessHoursValid = false;
                            invalidDates.push(businessHoursCheckDate.toLocaleDateString('ja-JP'));
                        }
                    }
                    businessHoursCheckDate.setDate(businessHoursCheckDate.getDate() + 1);
                }
                
                if (!businessHoursValid) {
                    showMessage(`é¸æŠã•ã‚ŒãŸæ™‚é–“ãŒå–¶æ¥­æ™‚é–“å¤–ã®æ—¥ä»˜ãŒã‚ã‚Šã¾ã™: ${invalidDates.join(', ')}ã€‚ã‚·ãƒ•ãƒˆè¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚`, 'error');
                    return false;
                }
                
                return true;
            };
            
            // å–¶æ¥­æ™‚é–“ãƒã‚§ãƒƒã‚¯ã‚’å®Ÿè¡Œ
            const businessHoursOk = await checkBusinessHours();
            if (!businessHoursOk) {
                return;
            }
            
            // é‡è¤‡ãƒã‚§ãƒƒã‚¯ï¼ˆæ—¢å­˜ã®äºˆç´„ã¨ã®é‡è¤‡ï¼‰
            let hasConflicts = false;
            let conflictDetails = [];
            let conflictCheckDate = new Date(startDate);
            while (conflictCheckDate <= endDate) {
                if (selectedDays.includes(conflictCheckDate.getDay())) {
                    if (checkReservationConflict(conflictCheckDate, startTime, duration)) {
                        hasConflicts = true;
                        conflictDetails.push(conflictCheckDate.toLocaleDateString('ja-JP'));
                    }
                }
                conflictCheckDate.setDate(conflictCheckDate.getDate() + 1);
            }
            
            if (hasConflicts) {
                showMessage(`æ—¢å­˜ã®äºˆç´„ã¨é‡è¤‡ã™ã‚‹æ—¥ä»˜ãŒã‚ã‚Šã¾ã™: ${conflictDetails.join(', ')}ã€‚ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚`, 'error');
                return;
            }
            
            // æ–°è¦ä½œæˆäºˆå®šã®äºˆç´„åŒå£«ã®é‡è¤‡ãƒã‚§ãƒƒã‚¯ï¼ˆåŒã˜æ—¥ä»˜ã«è¤‡æ•°ã®äºˆç´„ã‚’ä½œæˆã™ã‚‹å ´åˆï¼‰
            const plannedDates = [];
            let plannedDatesCheckDate = new Date(startDate);
            while (plannedDatesCheckDate <= endDate) {
                if (selectedDays.includes(plannedDatesCheckDate.getDay())) {
                    plannedDates.push(new Date(plannedDatesCheckDate));
                }
                plannedDatesCheckDate.setDate(plannedDatesCheckDate.getDate() + 1);
            }
            
            // åŒã˜æ—¥ä»˜ã«è¤‡æ•°ã®äºˆç´„ã‚’ä½œæˆã—ã‚ˆã†ã¨ã—ã¦ã„ã‚‹å ´åˆã¯ã‚¨ãƒ©ãƒ¼
            const dateCounts = {};
            plannedDates.forEach(date => {
                const dateKey = date.toISOString().split('T')[0];
                dateCounts[dateKey] = (dateCounts[dateKey] || 0) + 1;
            });
            
            const duplicateDates = Object.entries(dateCounts).filter(([date, count]) => count > 1);
            if (duplicateDates.length > 0) {
                const duplicateDateList = duplicateDates.map(([date]) => new Date(date).toLocaleDateString('ja-JP')).join(', ');
                showMessage(`åŒã˜æ—¥ä»˜ï¼ˆ${duplicateDateList}ï¼‰ã«è¤‡æ•°ã®äºˆç´„ã‚’ä½œæˆã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚æ—¥ä»˜ã‚’èª¿æ•´ã—ã¦ãã ã•ã„ã€‚`, 'error');
                return;
            }
            
            const submitBtn = document.getElementById('submitBulkBtn');
            submitBtn.disabled = true;
            submitBtn.textContent = 'ä½œæˆä¸­...';
            
            let createReservationsDate = new Date(startDate);
            let createdCount = 0;
            let failedCount = 0;
            
            const createReservations = async () => {
                while (createReservationsDate <= endDate) {
                    if (selectedDays.includes(createReservationsDate.getDay())) {
                        try {
                            const reservationData = {
                                reservation: {
                                    start_time: `${createReservationsDate.toISOString().split('T')[0]} ${startTime}`,
                                    course: getCourseFromDuration(duration),
                                    name: customerName,
                                    note: note,
                                    status: status,
                                    user_attributes: {
                                        name: customerName,
                                        phone_number: customerPhone,
                                        email: customerEmail
                                    }
                                }
                            };
                            
                            // ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šé€ä¿¡ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ­ã‚°
                            console.log(`ğŸ” Sending reservation data for ${createReservationsDate.toLocaleDateString('ja-JP')}:`, reservationData);
                            
                            const response = await fetch('/admin/reservations/create_booking', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').getAttribute('content')
                                },
                                body: JSON.stringify(reservationData)
                            });
                            
                            if (response.ok) {
                                createdCount++;
                                showMessage(`${createReservationsDate.toLocaleDateString('ja-JP')}ã®äºˆç´„ã‚’ä½œæˆã—ã¾ã—ãŸã€‚`, 'success');
                            } else {
                                failedCount++;
                                // ã‚¨ãƒ©ãƒ¼ã®è©³ç´°ã‚’å–å¾—
                                const errorData = await response.json().catch(() => ({}));
                                const errorMessage = errorData.error || response.statusText;
                                console.error(`Failed to create reservation for ${createReservationsDate.toLocaleDateString('ja-JP')}:`, response.status, errorMessage);
                                showMessage(`${createReservationsDate.toLocaleDateString('ja-JP')}ã®äºˆç´„ä½œæˆã«å¤±æ•—: ${errorMessage}`, 'error');
                            }
                        } catch (error) {
                            failedCount++;
                            console.error(`Error creating reservation for ${createReservationsDate.toLocaleDateString('ja-JP')}:`, error);
                        }
                    }
                    createReservationsDate.setDate(createReservationsDate.getDate() + 1);
                }
                
                // å®Œäº†å¾Œã®å‡¦ç†
                submitBtn.disabled = false;
                submitBtn.textContent = 'ä¸€æ‹¬ä½œæˆ';
                
                if (failedCount === 0) {
                    showMessage(`${createdCount}ä»¶ã®äºˆç´„ã‚’æ­£å¸¸ã«ä½œæˆã—ã¾ã—ãŸã€‚`, 'success');
                    closeBulkReservationModal();
                    // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚’æ›´æ–°
                    loadReservationsFromBackend();
                } else {
                    showMessage(`${createdCount}ä»¶ä½œæˆã€${failedCount}ä»¶å¤±æ•—ã—ã¾ã—ãŸã€‚`, 'warning');
                }
            };
            
            createReservations();
                }

        // ä¼‘æ†©ã®å¤‰æ›´ã‚’ä¿å­˜
        function saveBreakChanges() {
            console.log('ğŸ”„ Saving break changes...');
            const reservation = window.currentBreakReservation;
            if (!reservation) {
                console.error('âŒ No current break reservation found');
                return;
            }
            
            // ãƒ‡ãƒãƒƒã‚°: ä¼‘æ†©äºˆç´„ã®æ§‹é€ ã‚’ç¢ºèª
            console.log('ğŸ” Break reservation structure:', {
                id: reservation.id,
                hasStartTime: !!reservation.start_time,
                hasDate: !!reservation.date,
                hasTime: !!reservation.time,
                startTime: reservation.start_time,
                date: reservation.date,
                time: reservation.time,
                duration: reservation.duration,
                customer: reservation.customer,
                name: reservation.name,
                fullObject: reservation
            });
            
            const selectedTitle = document.getElementById('editBreakTitle').value;
            const customTitle = document.getElementById('editCustomBreakTitleInput').value;
            const duration = document.getElementById('editBreakDuration').value;
            const note = document.getElementById('editBreakNote').value;
            
            let finalTitle = selectedTitle;
            if (selectedTitle === 'ãã®ä»–' && customTitle.trim()) {
                finalTitle = customTitle.trim();
            }
            
            console.log('ğŸ’¾ Saving break with data:', { finalTitle, duration, note });
            
            // æ™‚é–“å¤‰æ›´ã®å ´åˆã¯ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
            const newDuration = parseInt(duration);
            const currentDuration = reservation.duration || 30;
            
            if (newDuration !== currentDuration) {
                console.log('â° Duration changed, validating...');
                
                // å–¶æ¥­æ™‚é–“å†…ãƒã‚§ãƒƒã‚¯ - ä¼‘æ†©äºˆç´„ç”¨ã®ç‰¹åˆ¥å‡¦ç†
                let reservationDate, timeStr;
                if (reservation.start_time) {
                    reservationDate = new Date(reservation.start_time);
                    timeStr = reservationDate.toTimeString().substring(0, 5);
                } else if (reservation.date && reservation.time) {
                    reservationDate = new Date(`${reservation.date} ${reservation.time}`);
                    timeStr = reservation.time;
                } else if (reservation.date) {
                    // ä¼‘æ†©äºˆç´„ã®å ´åˆã€æ—¥ä»˜ã®ã¿ã‹ã‚‰æ™‚é–“ã‚’æ¨å®š
                    reservationDate = new Date(reservation.date);
                    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæ™‚é–“ã‚’è¨­å®šï¼ˆ9:00ï¼‰
                    timeStr = '09:00';
                    console.log('âš ï¸ Break reservation: using default time 09:00 for validation');
                } else {
                    console.error('âŒ Cannot determine reservation time for validation');
                    showMessage('æ™‚é–“ã®æ¤œè¨¼ã«å¤±æ•—ã—ã¾ã—ãŸã€‚', 'error');
                    return;
                }
                
                const validation = validateReservationTimeWithinBusinessHours({
                    time: timeStr,
                    start_time: reservation.start_time || `${reservation.date} ${timeStr}`,
                    date: reservation.date,
                    duration: newDuration
                }, newDuration, 0); // ä¼‘æ†©ã¯ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«0
                
                if (!validation.valid) {
                    console.log('âš ï¸ Validation failed:', validation);
                    showMessage(validation.message, 'error');
                    return;
                }
                
                // é‡è¤‡ãƒã‚§ãƒƒã‚¯ï¼ˆè‡ªåˆ†ä»¥å¤–ã®äºˆç´„ã¨ã®é‡è¤‡ï¼‰
                const overlapValidation = validateReservationOverlap({
                    time: timeStr,
                    start_time: reservation.start_time || `${reservation.date} ${timeStr}`,
                    date: reservation.date,
                    duration: newDuration
                }, newDuration, 0, reservation.id); // ä¼‘æ†©ã¯ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«0ã€è‡ªåˆ†è‡ªèº«ã‚’é™¤å¤–
                
                if (!overlapValidation.valid) {
                    showMessage(overlapValidation.message, 'error');
                    return;
                }
            }
            
            // ã‚µãƒ¼ãƒãƒ¼ã«ä¿å­˜ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡
            const updateData = {
                reservation: {
                    name: finalTitle,
                    course: `${duration}åˆ†`,
                    note: note,
                    individual_interval_minutes: 0  // ä¼‘æ†©ã«ã¯ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«ãªã—
                }
            };
            
            fetch(`/admin/reservations/${reservation.id}/update_booking`, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]')?.getAttribute('content')
                },
                body: JSON.stringify(updateData)
            })
            .then(response => {
                if (response.status === 422) {
                    // ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼ã®å ´åˆ
                    return response.json().then(errorData => {
                        throw new Error(errorData.message || 'ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
                    });
                }
                return response.json();
            })
            .then(data => {
                console.log('âœ… Break update response:', data);
                if (data.success) {
                    // ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°
                    reservation.customer = finalTitle;
                    reservation.name = finalTitle;
                    reservation.duration = parseInt(duration);
                    reservation.note = note;
                    
                    // ã‚°ãƒ­ãƒ¼ãƒãƒ« reservations ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ›´æ–° - ã‚ˆã‚Šå®‰å…¨ãªæ—¥ä»˜ã‚­ãƒ¼å–å¾—
                    let dateKey;
                    if (reservation.start_time) {
                        dateKey = reservation.start_time.split('T')[0];
                    } else if (reservation.date) {
                        dateKey = reservation.date;
                    } else {
                        // å…¨ã¦ã®æ—¥ä»˜ã‹ã‚‰è©²å½“ã™ã‚‹äºˆç´„ã‚’æ¢ã—ã¦æ›´æ–°
                        for (const key of Object.keys(reservations)) {
                            if (reservations[key]) {
                                const index = reservations[key].findIndex(r => r.id === reservation.id);
                                if (index !== -1) {
                                    reservations[key][index] = { ...reservations[key][index], ...reservation };
                                    dateKey = key; // è¦‹ã¤ã‹ã£ãŸæ—¥ä»˜ã‚­ãƒ¼ã‚’è¨˜éŒ²
                                    break;
                                }
                            }
                        }
                    }
                    
                    // ç‰¹å®šã®æ—¥ä»˜ã‚­ãƒ¼ãŒã‚ã‚‹å ´åˆã¯ãã®æ—¥ã®ã¿å‡¦ç†
                    if (dateKey && reservations[dateKey]) {
                        const index = reservations[dateKey].findIndex(r => r.id === reservation.id);
                        if (index !== -1) {
                            reservations[dateKey][index] = { ...reservations[dateKey][index], ...reservation };
                        }
                    }
                    
                    // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚’å†æç”»ï¼ˆäºˆç´„ãƒ¢ãƒ¼ãƒ€ãƒ«ã¯é–‹ã‹ãªã„ï¼‰
                    generateTimeSlots();
                    closeBreakDetailModal();
                    showMessage('ä¼‘æ†©ãŒæ›´æ–°ã•ã‚Œã¾ã—ãŸã€‚', 'success');
                } else {
                    showMessage('ä¼‘æ†©ã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸã€‚', 'error');
                }
            })
            .catch(error => {
                console.error('âŒ Error updating break:', error);
                // ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
                showMessage(error.message || 'ä¼‘æ†©ã®æ›´æ–°ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚', 'error');
            });
        }

        // ä¼‘æ†©äºˆç´„ã‚’å‰Šé™¤
        function deleteBreakReservation() {
            console.log('ğŸ—‘ï¸ deleteBreakReservationé–¢æ•°ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã—ãŸ');
            const reservation = window.currentBreakReservation;
            console.log('ğŸ” currentBreakReservation:', reservation);
            
            if (!reservation) {
                console.error('âŒ No current break reservation to delete');
                showMessage('å‰Šé™¤ã™ã‚‹ä¼‘æ†©ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚', 'error');
                return;
            }
            
            if (!reservation.id) {
                console.error('âŒ reservation.idãŒæœªå®šç¾©ã§ã™:', reservation);
                showMessage('ä¼‘æ†©IDãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚', 'error');
                return;
            }
            
            console.log('âœ… ä¼‘æ†©IDç¢ºèª:', reservation.id);
            
            if (!confirm('ã“ã®ä¼‘æ†©ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) return;
            
            console.log('ğŸ—‘ï¸ Deleting break reservation:', reservation.id);
            
            // æ­£ã—ã„APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’ä½¿ç”¨
            const deleteUrl = `/admin/reservations/${reservation.id}`;
            console.log('ğŸŒ å‰Šé™¤URL:', deleteUrl);
            
            fetch(deleteUrl, {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]')?.getAttribute('content')
                }
            })
            .then(response => {
                if (response.status === 404) {
                    // æ—¢ã«å‰Šé™¤æ¸ˆã¿ã®å ´åˆã¯æˆåŠŸã¨ã—ã¦æ‰±ã†
                    return { success: true, message: 'äºˆç´„ã¯æ—¢ã«å‰Šé™¤ã•ã‚Œã¦ã„ã¾ã™' };
                }
                return response.json();
            })
            .then(data => {
                console.log('ğŸ—‘ï¸ Delete response:', data);
                if (data.success) {
                    // ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å‰Šé™¤ - ã‚ˆã‚Šå®‰å…¨ãªæ—¥ä»˜ã‚­ãƒ¼å–å¾—
                    let dateKey;
                    if (reservation.start_time) {
                        dateKey = reservation.start_time.split('T')[0];
                    } else if (reservation.date) {
                        dateKey = reservation.date;
                    } else {
                        // å…¨ã¦ã®æ—¥ä»˜ã‹ã‚‰å‰Šé™¤ã‚’è©¦è¡Œ
                        for (const key of Object.keys(reservations)) {
                            if (reservations[key]) {
                                reservations[key] = reservations[key].filter(r => r.id !== reservation.id);
                            }
                        }
                    }
                    
                    // ç‰¹å®šã®æ—¥ä»˜ã‚­ãƒ¼ãŒã‚ã‚‹å ´åˆã¯ãã®æ—¥ã®ã¿å‡¦ç†
                    if (dateKey && reservations[dateKey]) {
                        reservations[dateKey] = reservations[dateKey].filter(r => r.id !== reservation.id);
                    }
                    
                    // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚’å†æç”»
                    generateTimeSlots();
                    closeBreakDetailModal();
                    showMessage('ä¼‘æ†©ãŒå‰Šé™¤ã•ã‚Œã¾ã—ãŸã€‚', 'success');
                } else {
                    showMessage('ä¼‘æ†©ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸã€‚', 'error');
                }
            })
            .catch(error => {
                console.error('Error deleting break:', error);
                showMessage('ä¼‘æ†©ã®å‰Šé™¤ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚', 'error');
            });
        }
        
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•°ã¨ã—ã¦å…¬é–‹
        window.deleteBreakReservation = deleteBreakReservation;

        // æ™‚é–“æ ã‚¯ãƒªãƒƒã‚¯æ™‚ã®é¸æŠè‚¢ã‚’è¡¨ç¤º
        function showSlotOptions(date, time, cellElement) {
            // æ—¢å­˜ã®é¸æŠè‚¢ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãŒã‚ã‚Œã°å‰Šé™¤
            const existingMenu = document.querySelector('.slot-options-menu');
            if (existingMenu) {
                existingMenu.remove();
            }

            // é¸æŠè‚¢ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’ä½œæˆ
            const menu = document.createElement('div');
            menu.className = 'slot-options-menu';
            menu.innerHTML = `
                <div class="slot-option" onclick="openBookingModal(new Date('${date.toISOString()}'), '${time}'); closeSlotOptionsMenu()">
                    ğŸ‘¤ äºˆç´„ä½œæˆ
                </div>
                <div class="slot-option" onclick="openBreakModal(new Date('${date.toISOString()}'), '${time}'); closeSlotOptionsMenu()">
                    â˜• ä¼‘æ†©ä½œæˆ
                </div>
                <div class="slot-option-cancel" onclick="closeSlotOptionsMenu()">
                    âœ• ã‚­ãƒ£ãƒ³ã‚»ãƒ«
                </div>
            `;

            // ã‚»ãƒ«ã®ä½ç½®ã‚’å–å¾—ã—ã¦ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’é…ç½®
            const rect = cellElement.getBoundingClientRect();
            menu.style.position = 'fixed';
            menu.style.left = `${rect.left + 10}px`;
            menu.style.top = `${rect.top + 10}px`;
            menu.style.zIndex = '10000';

            // ãƒšãƒ¼ã‚¸ã«è¿½åŠ 
            document.body.appendChild(menu);

            // å¤–å´ã‚¯ãƒªãƒƒã‚¯ã§ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’é–‰ã˜ã‚‹
            setTimeout(() => {
                document.addEventListener('click', function closeOnOutsideClick(e) {
                    if (!menu.contains(e.target)) {
                        closeSlotOptionsMenu();
                        document.removeEventListener('click', closeOnOutsideClick);
                    }
                });
            }, 100);
        }

        // é¸æŠè‚¢ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’é–‰ã˜ã‚‹
        function closeSlotOptionsMenu() {
            const menu = document.querySelector('.slot-options-menu');
            if (menu) {
                menu.remove();
            }
        }

        // ä¼‘æ†©ã‚¿ã‚¤ãƒˆãƒ«é¸æŠæ™‚ã®å‡¦ç†
        function handleBreakTitleChange() {
            const breakTitle = document.getElementById('breakTitle');
            const customBreakTitle = document.getElementById('customBreakTitle');
            
            if (breakTitle.value === 'ãã®ä»–') {
                customBreakTitle.style.display = 'block';
            } else {
                customBreakTitle.style.display = 'none';
                document.getElementById('customBreakTitleInput').value = '';
            }
        }

        function openBookingModal(date, time) {
            // æ—¥ä»˜ã¨æ™‚é–“ã®è¡¨ç¤ºç”¨ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
            const displayDate = `${date.getFullYear()}å¹´${String(date.getMonth() + 1).padStart(2, '0')}æœˆ${String(date.getDate()).padStart(2, '0')}æ—¥`;
            const dayNames = ['æ—¥', 'æœˆ', 'ç«', 'æ°´', 'æœ¨', 'é‡‘', 'åœŸ'];
            const dayName = dayNames[date.getDay()];
            
            document.getElementById('bookingDisplayDate').textContent = `${displayDate}(${dayName})`;
            document.getElementById('bookingDisplayTime').textContent = time;
            
            // å†…éƒ¨çš„ã«æ—¥ä»˜ã¨æ™‚é–“ã‚’ä¿å­˜
            window.selectedBookingDate = date;
            window.selectedBookingTime = time;
            
            // ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ãƒªã‚»ãƒƒãƒˆ
            document.getElementById('bookingDuration').value = '';
            document.getElementById('customerName').value = '';
            document.getElementById('customerPhone').value = '';
            document.getElementById('customerEmail').value = '';
            document.getElementById('bookingNote').value = '';
            document.getElementById('bookingStatus').value = 'tentative';
            
            document.getElementById('bookingModal').style.display = 'block';
        }

        // äºˆç´„ä½œæˆãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
        function closeBookingModal() {
            document.getElementById('bookingModal').style.display = 'none';
            // ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
            isEditingReservation = false;
            currentReservation = null;
            reservationToEdit = null;
        }

        // äºˆç´„ã‚’ä½œæˆãƒ»æ›´æ–°
        function createBooking() {
            const duration = document.getElementById('bookingDuration').value;
            const customerName = document.getElementById('customerName').value;
            const customerPhone = document.getElementById('customerPhone').value;
            const customerEmail = document.getElementById('customerEmail').value;
            const bookingNote = document.getElementById('bookingNote').value;
            const bookingStatus = document.getElementById('bookingStatus').value;

            console.log('ğŸ”„ Creating/Updating booking, isEditing:', isEditingReservation);

            if (!duration || !customerName || !customerPhone) {
                showMessage('ã‚³ãƒ¼ã‚¹ã€ãŠå®¢æ§˜åã€é›»è©±ç•ªå·ã¯å¿…é ˆã§ã™ã€‚', 'error');
                return;
            }

            // é¸æŠã•ã‚ŒãŸæ—¥æ™‚ã‹ã‚‰dateTimeã‚’ä½œæˆ
            const selectedDate = window.selectedBookingDate;
            const selectedTime = window.selectedBookingTime;
            const dateTime = `${selectedDate.getFullYear()}-${String(selectedDate.getMonth() + 1).padStart(2, '0')}-${String(selectedDate.getDate()).padStart(2, '0')} ${selectedTime}`;

            // å–¶æ¥­æ™‚é–“å†…ã«åã¾ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            const [dateStr, timeStr] = dateTime.split(' ');
            const reservationDate = new Date(dateStr);
            const dayOfWeek = reservationDate.getDay();
            const newDuration = parseInt(duration);
            const defaultInterval = 10; // æ–°è¦äºˆç´„ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆé–“éš”
            
            const validation = validateReservationTimeWithinBusinessHours({
                time: timeStr,
                start_time: dateTime,
                duration: newDuration
            }, newDuration, defaultInterval);
            
            if (!validation.valid) {
                showMessage(validation.message, 'error');
                return;
            }
            
            // é‡è¤‡ãƒã‚§ãƒƒã‚¯
            const overlapValidation = validateReservationOverlap({
                time: timeStr,
                start_time: dateTime,
                duration: newDuration
            }, newDuration, defaultInterval);
            
            if (!overlapValidation.valid) {
                showMessage(overlapValidation.message, 'error');
                return;
            }

            // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã«é€ä¿¡ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚’æº–å‚™
            const bookingData = {
                reservation: {
                    start_time: dateTime,
                    course: `${duration}åˆ†`,
                    name: customerName,
                    note: bookingNote,
                    status: bookingStatus,
                    user_attributes: {
                        name: customerName,
                        phone_number: customerPhone,
                        email: customerEmail
                    }
                }
            };

            // CSRFãƒˆãƒ¼ã‚¯ãƒ³ã‚’å–å¾—
  const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');
            console.log('CSRF Token:', csrfToken);
            console.log('Sending booking data:', bookingData);

            // ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ã§é‡è¤‡ãƒã‚§ãƒƒã‚¯
            if (!isEditingReservation && checkForOverlap(dateTime, duration)) {
                showMessage('ã“ã®æ™‚é–“å¸¯ã«ã¯æ—¢ã«äºˆç´„ãŒã‚ã‚Šã¾ã™ã€‚åˆ¥ã®æ™‚é–“ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚', 'error');
                return;
            }

            // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã«é€ä¿¡ï¼ˆç·¨é›†ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã¯æ›´æ–°ã€æ–°è¦ã®å ´åˆã¯ä½œæˆï¼‰
            const url = isEditingReservation ? 
                `/admin/reservations/${reservationToEdit.id}/update_booking` : 
                '/admin/reservations/create_booking';
            const method = isEditingReservation ? 'PATCH' : 'POST';
            
            fetch(url, {
                method: method,
    headers: {
      'Content-Type': 'application/json',
      'X-CSRF-Token': csrfToken
    },
                body: JSON.stringify(bookingData)
  })
  .then(response => {
                console.log('Response status:', response.status);
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return response.json();
  })
  .then(data => {
    if (data.success) {
                    // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‹ã‚‰è¿”ã•ã‚ŒãŸäºˆç´„ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨
                    const reservationData = data.reservation;
                    
                    if (isEditingReservation) {
                        // ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ï¼šæ—¢å­˜ã®äºˆç´„ã‚’æ›´æ–°
                        const updatedReservation = {
                            id: reservationData.id,
                            userId: reservationData.user_id || reservationData.user?.id,
                            time: reservationData.start_time.split('T')[1].substring(0, 5), // HH:MMå½¢å¼ã«å¤‰æ›
                            duration: extractDurationFromCourse(reservationData.course),
                            customer: reservationData.name || reservationData.user?.name || 'æœªè¨­å®š',
                            phone: reservationData.user?.phone_number || '',
                            email: reservationData.user?.email || '',
                            note: reservationData.note || '',
                            status: reservationData.status,
                            createdAt: reservationData.created_at,
                            updatedAt: reservationData.updated_at,
                            effective_interval_minutes: reservationData.effective_interval_minutes ?? 10
                        };
                        
                        // æ—¢å­˜ã®äºˆç´„ã‚’æ›´æ–°
                        // å¤ã„æ—¥ä»˜ã‚­ãƒ¼ã‚’ç‰¹å®šï¼ˆreservationsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰è©²å½“ã™ã‚‹æ—¥ä»˜ã‚­ãƒ¼ã‚’æ¢ã™ï¼‰
                        let oldDateKey = null;
                        for (const dateKey of Object.keys(reservations)) {
                            const dayReservations = reservations[dateKey];
                            const foundReservation = dayReservations.find(r => r.id === reservationToEdit.id);
                            if (foundReservation) {
                                oldDateKey = dateKey;
                                break;
                            }
                        }
                        
                        const newDateKey = formatDateKey(new Date(reservationData.start_time));
                        
                        // å¤ã„æ—¥ä»˜ã‹ã‚‰å‰Šé™¤
                        if (oldDateKey && reservations[oldDateKey]) {
                            reservations[oldDateKey] = reservations[oldDateKey].filter(r => r.id !== reservationToEdit.id);
                            if (reservations[oldDateKey].length === 0) {
                                delete reservations[oldDateKey];
                            }
                        }
                        
                        // æ–°ã—ã„æ—¥ä»˜ã«è¿½åŠ 
                        if (!reservations[newDateKey]) {
                            reservations[newDateKey] = [];
                        }
                        reservations[newDateKey].push(updatedReservation);
                        
                        
                        
                        // ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
                        isEditingReservation = false;
                        currentReservation = null;
                        reservationToEdit = null;
                        
                        showMessage('äºˆç´„ãŒæ›´æ–°ã•ã‚Œã¾ã—ãŸã€‚', 'success');
                    } else {
                        // æ–°è¦ä½œæˆãƒ¢ãƒ¼ãƒ‰ï¼šæ–°ã—ã„äºˆç´„ã‚’è¿½åŠ 
                        const reservation = {
                            id: reservationData.id,
                            userId: reservationData.user_id || reservationData.user?.id,
                            time: reservationData.start_time.split('T')[1].substring(0, 5), // HH:MMå½¢å¼ã«å¤‰æ›
                            duration: extractDurationFromCourse(reservationData.course),
                            customer: reservationData.name || reservationData.user?.name || 'æœªè¨­å®š',
                            phone: reservationData.user?.phone_number || '',
                            email: reservationData.user?.email || '',
                            note: reservationData.note || '',
                            status: reservationData.status,
                            createdAt: reservationData.created_at,
                            updatedAt: reservationData.updated_at,
                            effective_interval_minutes: reservationData.effective_interval_minutes ?? 10
                        };

                        const dateKey = formatDateKey(new Date(reservationData.start_time));
                        if (!reservations[dateKey]) {
                            reservations[dateKey] = [];
                        }
                        reservations[dateKey].push(reservation);

                        
                        
                        showMessage('äºˆç´„ãŒä½œæˆã•ã‚Œã¾ã—ãŸã€‚', 'success');
                    }

                    // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚’å†æç”»
                    generateTimeSlots();

                    closeBookingModal();
    } else {
                    showMessage(`äºˆç´„ã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ: ${data.message}`, 'error');
    }
  })
  .catch(error => {
                console.error('Error creating booking:', error);
                showMessage('äºˆç´„ã®ä½œæˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚', 'error');
            });
        }

        // ä¼‘æ†©ã‚¿ãƒ–ã‚’ä½œæˆ
        function createBreak() {
            // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‹ã‚‰æ—¥ä»˜ã¨æ™‚é–“ã‚’å–å¾—
            const date = window.selectedBreakDate;
            const time = window.selectedBreakTime;
            const formattedDate = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
            const dateTime = `${formattedDate} ${time}`;
            
            const duration = document.getElementById('breakDuration').value;
            const selectedBreakTitle = document.getElementById('breakTitle').value;
            const customBreakTitleInput = document.getElementById('customBreakTitleInput').value;
            const bookingNote = document.getElementById('breakNote').value;

            // ã‚¿ã‚¤ãƒˆãƒ«ã‚’æ±ºå®šï¼ˆã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚¤ãƒˆãƒ«ãŒã‚ã‚‹å ´åˆã¯ãã‚Œã‚’ä½¿ç”¨ï¼‰
            let breakTitle = selectedBreakTitle;
            if (selectedBreakTitle === 'ãã®ä»–' && customBreakTitleInput.trim()) {
                breakTitle = customBreakTitleInput.trim();
            } else if (selectedBreakTitle === 'ãã®ä»–') {
                showMessage('ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚¤ãƒˆãƒ«ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚', 'error');
                return;
            }

            console.log('ğŸ”„ Creating break with title:', breakTitle);

            if (!dateTime || !duration || !breakTitle) {
                showMessage('æ—¥æ™‚ã€ä¼‘æ†©æ™‚é–“ã€ã‚¿ã‚¤ãƒˆãƒ«ã¯å¿…é ˆã§ã™ã€‚', 'error');
                return;
            }

            // å–¶æ¥­æ™‚é–“å†…ã«åã¾ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            const [dateStr, timeStr] = dateTime.split(' ');
            const reservationDate = new Date(dateStr);
            const newDuration = parseInt(duration);
            const defaultInterval = 0; // ä¼‘æ†©ã«é–“éš”ã¯ä¸è¦
            
            const validation = validateReservationTimeWithinBusinessHours({
                time: timeStr,
                start_time: dateTime,
                duration: newDuration
            }, newDuration, defaultInterval);
            
            if (!validation.valid) {
                showMessage(validation.message, 'error');
                return;
            }
            
            // é‡è¤‡ãƒã‚§ãƒƒã‚¯
            const overlapValidation = validateReservationOverlap({
                time: timeStr,
                start_time: dateTime,
                duration: newDuration
            }, newDuration, defaultInterval);
            
            if (!overlapValidation.valid) {
                showMessage(overlapValidation.message, 'error');
                return;
            }

            // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã«é€ä¿¡ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚’æº–å‚™ï¼ˆä¼‘æ†©ç”¨ï¼‰
            const breakData = {
                reservation: {
                    start_time: dateTime,
                    course: `${duration}åˆ†`,
                    name: breakTitle,
                    note: bookingNote || '',
                    status: 'confirmed', // ä¼‘æ†©ã¯ç¢ºå®šçŠ¶æ…‹ã«ã™ã‚‹
                    is_break: false,     // ä¼‘æ†©æ©Ÿèƒ½ã¯ç„¡åŠ¹åŒ–
                    individual_interval_minutes: 0, // ä¼‘æ†©ã«ã¯ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«ãªã—
                    user_attributes: {
                        name: 'ã‚¹ã‚¿ãƒƒãƒ•',
                        phone_number: '',
                        email: ''
                    }
                }
            };

            // CSRFãƒˆãƒ¼ã‚¯ãƒ³ã‚’å–å¾—
            const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');
            console.log('Creating break with data:', breakData);

            // ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ã§é‡è¤‡ãƒã‚§ãƒƒã‚¯
            if (checkForOverlap(dateTime, duration)) {
                showMessage('ã“ã®æ™‚é–“å¸¯ã«ã¯æ—¢ã«äºˆç´„ãŒã‚ã‚Šã¾ã™ã€‚åˆ¥ã®æ™‚é–“ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚', 'error');
                return;
            }

            // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã«é€ä¿¡
            fetch('/admin/reservations/create_booking', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-Token': csrfToken
                },
                body: JSON.stringify(breakData)
            })
            .then(response => {
                console.log('Response status:', response.status);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‹ã‚‰è¿”ã•ã‚ŒãŸä¼‘æ†©ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨
                    const breakReservation = data.reservation;
                    
                    // æ–°ã—ã„ä¼‘æ†©ã‚’è¿½åŠ 
                    const break_entry = {
                        id: breakReservation.id,
                        userId: breakReservation.user_id || breakReservation.user?.id,
                        time: breakReservation.start_time.split('T')[1].substring(0, 5),
                        start_time: breakReservation.start_time, // Add start_time for validation
                        date: breakReservation.start_time.split('T')[0], // Add date for validation
                        duration: extractDurationFromCourse(breakReservation.course),
                        customer: breakReservation.name,
                        phone: '',
                        email: '',
                        note: breakReservation.note || '',
                        status: breakReservation.status || 'confirmed',
                        is_break: false, // ä¼‘æ†©æ©Ÿèƒ½ã¯ç„¡åŠ¹åŒ–
                        createdAt: breakReservation.created_at,
                        updatedAt: breakReservation.updated_at,
                        effective_interval_minutes: 0
                    };

                    const dateKey = formatDateKey(new Date(breakReservation.start_time));
                    if (!reservations[dateKey]) {
                        reservations[dateKey] = [];
                    }
                    reservations[dateKey].push(break_entry);

                    showMessage('ä¼‘æ†©ã‚¿ãƒ–ãŒä½œæˆã•ã‚Œã¾ã—ãŸã€‚', 'success');

                    // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚’å†æç”»
                    generateTimeSlots();
                    closeBreakModal();
                } else {
                    showMessage(`ä¼‘æ†©ã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ: ${data.message}`, 'error');
                }
            })
            .catch(error => {
                console.error('Error creating break:', error);
                showMessage('ä¼‘æ†©ã®ä½œæˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚', 'error');
            });
        }

        // äºˆç´„è©³ç´°ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
        function openReservationDetailModal(reservation) {

            // æœ€æ–°ã®äºˆç´„ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            let latestReservation = null;
            for (const dateKey of Object.keys(reservations)) {
                const dayReservations = reservations[dateKey];
                const foundReservation = dayReservations.find(r => r.id === reservation.id);
                if (foundReservation) {
                    latestReservation = foundReservation;
                    break;
                }
            }
            
            // æœ€æ–°ã®ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯å…ƒã®ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨
            if (!latestReservation) {
                latestReservation = reservation;
            }
            
            console.log('ğŸ” Opening modal with reservation data:', {
                original: {
                    time: reservation.time,
                    date: reservation.date,
                    dateKey: reservation.dateKey,
                    start_time: reservation.start_time,
                    createdAt: reservation.createdAt,
                    updatedAt: reservation.updatedAt
                },
                latest: {
                    time: latestReservation.time,
                    createdAt: latestReservation.createdAt,
                    updatedAt: latestReservation.updatedAt,
                    date: latestReservation.date,
                    dateKey: latestReservation.dateKey,
                    start_time: latestReservation.start_time,
                    fullReservationObject: latestReservation
                }
            });
            
            // äºˆç´„ãƒ‡ãƒ¼ã‚¿ã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯
            if (!validateReservationData(latestReservation)) {
                showMessage('äºˆç´„ãƒ‡ãƒ¼ã‚¿ãŒç„¡åŠ¹ã§ã™', 'error');
                return;
            }
            
            // ç¾åœ¨ã®äºˆç´„ã‚’ä¿å­˜ï¼ˆæœ€æ–°ã®ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨ï¼‰
            currentReservation = latestReservation;
            console.log('ğŸ” Setting currentReservation:', currentReservation);
            console.log('ğŸ” currentReservation.id:', currentReservation.id);
            
            // äºˆç´„ã®å®Ÿéš›ã®æ—¥ä»˜ã‚’ç‰¹å®š
            let actualDate = '';
            for (const dateKey of Object.keys(reservations)) {
                const dayReservations = reservations[dateKey];
                const foundReservation = dayReservations.find(r => r.id === latestReservation.id);
                if (foundReservation) {
                    const [year, month, day] = dateKey.split('-').map(Number);
                    const date = new Date(year, month - 1, day);
                    actualDate = date.toLocaleDateString('ja-JP', { 
                        year: 'numeric', 
                        month: 'long', 
                        day: 'numeric',
                        weekday: 'long'
                    });
                    break;
                }
            }
            
            // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã«å¿œã˜ãŸè‰²ã¨ã‚¢ã‚¤ã‚³ãƒ³ã‚’è¨­å®š
            const statusConfig = {
                'tentative': { color: 'warning', icon: 'â³', text: 'ä»®äºˆç´„' },
                'confirmed': { color: 'success', icon: 'âœ“', text: 'ç¢ºèªæ¸ˆã¿' },
                'completed': { color: 'info', icon: 'âœ…', text: 'å®Œäº†' }
            };
            
            const status = statusConfig[latestReservation.status] || { color: 'secondary', icon: 'â“', text: latestReservation.status };
            
            // Create customer name HTML
            const customerNameHTML = latestReservation.userId ? 
                `<a href="/admin/users/${latestReservation.userId}" target="_blank" class="customer-link">${latestReservation.customer}</a>` : 
                latestReservation.customer;
            
            const modalContent = document.getElementById('reservationDetailContent');
            modalContent.innerHTML = `
                <div class="reservation-detail-container">
                    <!-- ç·¨é›†ãƒ•ã‚©ãƒ¼ãƒ  -->
                    <form id="reservationEditForm" onsubmit="saveReservationChanges(event)">
                    <!-- ãƒ˜ãƒƒãƒ€ãƒ¼æƒ…å ± -->
                    <div class="reservation-header">
                        <div class="header-top">
                            <div class="customer-name-header">
                                <span class="customer-name-large">${latestReservation.customer}</span>
                                    <button type="button" class="btn btn-sm btn-outline-light change-user-btn" onclick="openUserSelectionModal()">
                                        <i class="fas fa-user-edit"></i> å¤‰æ›´
                                    </button>
                            </div>
                            <div class="reservation-status status-${status.color}">
                                    <select id="edit-status" class="form-select status-select" onchange="updateCalendarOnStatusChange()">
                                        <option value="tentative" ${latestReservation.status === 'tentative' ? 'selected' : ''}>ä»®äºˆç´„</option>
                                        <option value="confirmed" ${latestReservation.status === 'confirmed' ? 'selected' : ''}>ç¢ºèªæ¸ˆã¿</option>
                                        <option value="completed" ${latestReservation.status === 'completed' ? 'selected' : ''}>å®Œäº†</option>
                                    </select>
                            </div>
                        </div>
                        <div class="header-bottom">
                            <div class="header-detail-item">
                                <span class="header-label">äºˆç´„æ—¥æ™‚</span>
                                <span class="header-value">${actualDate || 'æ—¥ä»˜ä¸æ˜'} ${latestReservation.time}</span>
                            </div>
                            <div class="header-detail-item">
                                <span class="header-label">ã‚³ãƒ¼ã‚¹</span>
                                    <select id="edit-course" class="form-select course-select" onchange="updateCalendarOnCourseChange()">
                                        <option value="40åˆ†" ${latestReservation.duration === 40 ? 'selected' : ''}>40åˆ†</option>
                                        <option value="60åˆ†" ${latestReservation.duration === 60 ? 'selected' : ''}>60åˆ†</option>
                                        <option value="80åˆ†" ${latestReservation.duration === 80 ? 'selected' : ''}>80åˆ†</option>
                                    </select>
                                </div>
                                <div class="header-detail-item">
                                    <span class="header-label">æº–å‚™æ™‚é–“</span>
                                    <span class="header-value">
                                        <select id="edit-interval" class="interval-select" onchange="updateIntervalOnChange()">
                                            <option value="0" ${(latestReservation.effective_interval_minutes ?? 10) === 0 ? 'selected' : ''}>0åˆ†</option>
                                            <option value="5" ${(latestReservation.effective_interval_minutes ?? 10) === 5 ? 'selected' : ''}>5åˆ†</option>
                                            <option value="10" ${(latestReservation.effective_interval_minutes ?? 10) === 10 ? 'selected' : ''}>10åˆ†</option>
                                            <option value="15" ${(latestReservation.effective_interval_minutes ?? 10) === 15 ? 'selected' : ''}>15åˆ†</option>
                                            <option value="20" ${(latestReservation.effective_interval_minutes ?? 10) === 20 ? 'selected' : ''}>20åˆ†</option>
                                            <option value="30" ${(latestReservation.effective_interval_minutes ?? 10) === 30 ? 'selected' : ''}>30åˆ†</option>
                                        </select>
                                    </span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- ãŠå®¢æ§˜åŸºæœ¬æƒ…å ± -->
                    <div class="customer-basic-info">
                        <div class="customer-phone">
                            ${latestReservation.phone || 'é›»è©±ç•ªå·æœªè¨˜å…¥'}
                        </div>
                        <div class="customer-email">
                            ${latestReservation.email || 'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹æœªè¨˜å…¥'}
                        </div>
                    </div>
                    
                        <!-- ãƒ¡ãƒ¢ -->
                        <div class="notes-section">
                            <div class="section-title">ãƒ¡ãƒ¢</div>
                            <textarea id="edit-note" class="form-control" rows="3" placeholder="ãƒ¡ãƒ¢ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„">${latestReservation.note || ''}</textarea>
                        </div>
                    </form>
                    
                    <!-- å›æ•°åˆ¸ã¨åˆ©ç”¨å±¥æ­´ã‚’æ¨ªä¸¦ã³ã§è¡¨ç¤º -->
                    <div class="tickets-history-container">
                    <!-- å›æ•°åˆ¸ -->
                    <div class="tickets-section">
                        <div class="section-title">å›æ•°åˆ¸</div>
                        <div class="tickets-content" id="tickets-content">
                            <div class="loading">èª­ã¿è¾¼ã¿ä¸­...</div>
                        </div>
                    </div>
                    
                        <!-- åˆ©ç”¨å±¥æ­´ -->
                    <div class="reservation-history-section">
                            <div class="section-title">åˆ©ç”¨å±¥æ­´</div>
                        <div class="history-content" id="history-content">
                            <div class="loading">èª­ã¿è¾¼ã¿ä¸­...</div>
                        </div>
                        </div>
                    </div>
                    
                    <!-- ã‚·ã‚¹ãƒ†ãƒ æƒ…å ± -->
                    <div class="system-info-section">
                        <div class="detail-item">
                            <span class="detail-label">ä½œæˆæ—¥æ™‚</span>
                            <span class="detail-value">${new Date(latestReservation.createdAt).toLocaleString('ja-JP')}</span>
                        </div>
                        ${(function() {
                            console.log('ğŸ” Checking timestamps for å¤‰æ›´æ—¥æ™‚:', {
                                createdAt: latestReservation.createdAt,
                                updatedAt: latestReservation.updatedAt,
                                created_at: latestReservation.created_at,
                                updated_at: latestReservation.updated_at,
                                createdTime: new Date(latestReservation.createdAt).getTime(),
                                updatedTime: latestReservation.updatedAt ? new Date(latestReservation.updatedAt).getTime() : 'null',
                                isDifferent: latestReservation.updatedAt && new Date(latestReservation.updatedAt).getTime() !== new Date(latestReservation.createdAt).getTime(),
                                allFields: Object.keys(latestReservation)
                            });
                            
                            // Check multiple possible timestamp field combinations
                            const createdTimestamp = latestReservation.createdAt || latestReservation.created_at;
                            const updatedTimestamp = latestReservation.updatedAt || latestReservation.updated_at;
                            
                            console.log('ğŸ” Final timestamp check:', {
                                createdTimestamp,
                                updatedTimestamp,
                                hasDifferentTimestamps: updatedTimestamp && createdTimestamp && new Date(updatedTimestamp).getTime() !== new Date(createdTimestamp).getTime()
                            });
                            
                            if (updatedTimestamp && createdTimestamp && new Date(updatedTimestamp).getTime() !== new Date(createdTimestamp).getTime()) {
                                return `
                        <div class="detail-item">
                            <span class="detail-label">å¤‰æ›´æ—¥æ™‚</span>
                            <span class="detail-value">${new Date(updatedTimestamp).toLocaleString('ja-JP')}</span>
                        </div>`;
                            } else {
                                return '';
                            }
                        })()}
                    </div>
                </div>
            `;
            document.getElementById('reservationDetailModal').style.display = 'block';
            
            // Add click event listener to customer link
            setTimeout(() => {
                const customerLink = document.querySelector('.customer-link');
                if (customerLink) {
        
                    customerLink.addEventListener('click', function(e) {
            
                        e.preventDefault();
                        window.open(this.href, '_blank');
                    });
                } else {
                    console.log('âŒ Customer link not found');
                }
            }, 100);
            
            // ãƒã‚±ãƒƒãƒˆã¨äºˆç´„å±¥æ­´ã‚’èª­ã¿è¾¼ã¿ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼IDãƒ™ãƒ¼ã‚¹ï¼‰
            if (latestReservation.userId) {
                loadTicketsAndHistoryForUser(latestReservation.userId);
            } else {
            loadTicketsAndHistory(latestReservation);
            }
            
            // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒªã‚¹ãƒˆã¯æ¤œç´¢æ™‚ã«å‹•çš„ã«èª­ã¿è¾¼ã¿
        }

        // äºˆç´„è©³ç´°ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
        function closeReservationDetailModal() {
            document.getElementById('reservationDetailModal').style.display = 'none';
            currentReservation = null; // ç¾åœ¨ã®äºˆç´„ã‚’ãƒªã‚»ãƒƒãƒˆ
        }
        
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•°ã¨ã—ã¦å…¬é–‹
        window.closeReservationDetailModal = closeReservationDetailModal;

        // ãƒ¢ãƒ¼ãƒ€ãƒ«å¤–ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹æ©Ÿèƒ½
        function setupModalClickOutside() {
            const modal = document.getElementById('reservationDetailModal');
            if (modal) {
                modal.addEventListener('click', function(event) {
                    // ãƒ¢ãƒ¼ãƒ€ãƒ«èƒŒæ™¯ï¼ˆ.modalï¼‰ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸå ´åˆã®ã¿é–‰ã˜ã‚‹
                    if (event.target === modal) {
                        closeReservationDetailModal();
                    }
                });
            }
        }

        // ãƒã‚±ãƒƒãƒˆã¨åˆ©ç”¨å±¥æ­´ã‚’èª­ã¿è¾¼ã¿
        function loadTicketsAndHistory(reservation) {
            // ãƒã‚±ãƒƒãƒˆæƒ…å ±ã‚’èª­ã¿è¾¼ã¿
            loadTickets(reservation);
            // åˆ©ç”¨å±¥æ­´ã‚’èª­ã¿è¾¼ã¿
            loadReservationHistory(reservation);
        }

        // ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã§ãƒã‚±ãƒƒãƒˆã¨åˆ©ç”¨å±¥æ­´ã‚’èª­ã¿è¾¼ã¿
        function loadTicketsAndHistoryForUser(userId) {
            // ãƒã‚±ãƒƒãƒˆæƒ…å ±ã‚’èª­ã¿è¾¼ã¿
            loadTicketsForUser(userId);
            // åˆ©ç”¨å±¥æ­´ã‚’èª­ã¿è¾¼ã¿
            loadReservationHistoryForUser(userId);
        }

        // ãƒã‚±ãƒƒãƒˆæƒ…å ±ã‚’èª­ã¿è¾¼ã¿
        function loadTickets(reservation) {

            
            const ticketsContent = document.getElementById('tickets-content');
            if (!ticketsContent) {
                console.error('âŒ Tickets content element not found');
                return;
            }

            // äºˆç´„ãƒ‡ãƒ¼ã‚¿ã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯
            if (!validateReservationData(reservation)) {
                ticketsContent.innerHTML = '<div class="no-data">äºˆç´„ãƒ‡ãƒ¼ã‚¿ãŒç„¡åŠ¹ã§ã™</div>';
                return;
            }

            // ãƒ¦ãƒ¼ã‚¶ãƒ¼IDãŒã‚ã‚‹å ´åˆã¯ãƒã‚±ãƒƒãƒˆæƒ…å ±ã‚’å–å¾—
            if (reservation.userId) {
    
    
                
                // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã‚’è¿½åŠ 
                fetch(`/admin/reservations/${reservation.id}/tickets`, {
                    headers: {
                        'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]')?.getAttribute('content')
                    }
                })
    .then(response => {
                        console.log('ğŸ“¡ Response status:', response.status);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
      return response.json();
    })
                    .then(data => {
            
                        if (data.success) {
                            displayTickets(data.tickets);
                        } else {
                            console.warn('âš ï¸ No tickets data:', data.message);
                            ticketsContent.innerHTML = '<div class="no-data">ãƒã‚±ãƒƒãƒˆæƒ…å ±ãŒã‚ã‚Šã¾ã›ã‚“</div>';
                        }
    })
    .catch(error => {
                        console.error('âŒ Error loading tickets:', error);
                        console.error('âŒ Error details:', {
                            message: error.message,
                            stack: error.stack,
                            reservationId: reservation.id,
                            userId: reservation.userId
                        });
                        ticketsContent.innerHTML = '<div class="no-data">ãƒã‚±ãƒƒãƒˆæƒ…å ±ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ</div>';
                    });
            } else {
                console.warn('âš ï¸ No user ID found for reservation');
                ticketsContent.innerHTML = '<div class="no-data">ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ãŒã‚ã‚Šã¾ã›ã‚“</div>';
            }
        }

        // ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã§ãƒã‚±ãƒƒãƒˆæƒ…å ±ã‚’èª­ã¿è¾¼ã¿
        function loadTicketsForUser(userId) {
            const ticketsContent = document.getElementById('tickets-content');
            if (!ticketsContent) {
                console.error('âŒ Tickets content element not found');
                return;
            }

            // ãƒ¦ãƒ¼ã‚¶ãƒ¼IDãŒã‚ã‚‹å ´åˆã¯ãƒã‚±ãƒƒãƒˆæƒ…å ±ã‚’å–å¾—
            if (userId) {
                fetch(`/admin/users/${userId}/tickets.json`)
                    .then(response => {
                        console.log('ğŸ“¡ User tickets response status:', response.status);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(tickets => {
                        console.log('ğŸ“¡ User tickets data:', tickets);
                        displayUserTickets(tickets);
                    })
                    .catch(error => {
                        console.error('âŒ Error loading user tickets:', error);
                        ticketsContent.innerHTML = '<div class="no-data">ãƒã‚±ãƒƒãƒˆæƒ…å ±ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ</div>';
                    });
            } else {
                console.warn('âš ï¸ No user ID provided');
                ticketsContent.innerHTML = '<div class="no-data">ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ãŒã‚ã‚Šã¾ã›ã‚“</div>';
            }
        }

        // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒã‚±ãƒƒãƒˆæƒ…å ±ã‚’è¡¨ç¤º
        function displayUserTickets(tickets) {
            const ticketsContent = document.getElementById('tickets-content');
            if (!ticketsContent) {
                console.error('âŒ Tickets content element not found in displayUserTickets');
                return;
            }

            if (!tickets || tickets.length === 0) {
                console.log('â„¹ï¸ No user tickets to display');
                ticketsContent.innerHTML = '<div class="no-data">ãƒã‚±ãƒƒãƒˆãŒã‚ã‚Šã¾ã›ã‚“</div>';
                return;
            }

            // Sort tickets by newest first (assuming created_at or issued_at field exists)
            const sortedTickets = tickets.sort((a, b) => {
                const dateA = new Date(a.created_at || a.issued_at || a.expires_at || 0);
                const dateB = new Date(b.created_at || b.issued_at || b.expires_at || 0);
                return dateB - dateA; // Newest first
            });

            // Limit to 5 tickets like the original
            const limitedTickets = sortedTickets.slice(0, 5);

            const ticketsHtml = limitedTickets.map(ticket => {
                const isExpired = ticket.remaining === 0 || new Date(ticket.expires_at) < new Date();
                const expiryDate = ticket.expires_at ? new Date(ticket.expires_at).toLocaleDateString('ja-JP') : 'ç„¡æœŸé™';
                
                return `
                    <div class="ticket-item ${isExpired ? 'expired' : ''}">
                        <div class="ticket-checkbox">â–¡</div>
                        <div class="ticket-info">
                            <div class="ticket-name">${ticket.name}</div>
                            <div class="ticket-details">æ®‹${ticket.remaining}æš / æœ‰åŠ¹æœŸé™:${expiryDate}</div>
                        </div>
                    </div>
                `;
            }).join('');

            ticketsContent.innerHTML = ticketsHtml;
        }

        // ãƒã‚±ãƒƒãƒˆæƒ…å ±ã‚’è¡¨ç¤º
        function displayTickets(tickets) {

            
            const ticketsContent = document.getElementById('tickets-content');
            if (!ticketsContent) {
                console.error('âŒ Tickets content element not found in displayTickets');
                return;
            }

            if (!tickets || tickets.length === 0) {
                console.log('â„¹ï¸ No tickets to display');
                ticketsContent.innerHTML = '<div class="no-data">ãƒã‚±ãƒƒãƒˆãŒã‚ã‚Šã¾ã›ã‚“</div>';
                return;
            }


            
            const ticketsHtml = tickets.map(ticket => {
                const isExpired = ticket.remaining_count === 0 || new Date(ticket.expiry_date) < new Date();
                const expiryDate = new Date(ticket.expiry_date).toLocaleDateString('ja-JP');
                

                
                return `
                    <div class="ticket-item ${isExpired ? 'expired' : ''}">
                        <div class="ticket-checkbox">â–¡</div>
                        <div class="ticket-info">
                            <div class="ticket-name">${ticket.ticket_template_name}</div>
                            <div class="ticket-details">æ®‹${ticket.remaining_count}${ticket.unit_type} / æœ‰åŠ¹æœŸé™:${expiryDate}</div>
          </div>
        </div>
      `;
            }).join('');


            ticketsContent.innerHTML = ticketsHtml;
        }

        // ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã§åˆ©ç”¨å±¥æ­´ã‚’èª­ã¿è¾¼ã¿
        function loadReservationHistoryForUser(userId) {
            const historyContent = document.getElementById('history-content');
            if (!historyContent) return;

            // ãƒ¦ãƒ¼ã‚¶ãƒ¼IDãŒã‚ã‚‹å ´åˆã¯åˆ©ç”¨å±¥æ­´ã‚’å–å¾—
            if (userId) {
                fetch(`/admin/users/${userId}/history.json`)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        console.log('ğŸ“¡ User history data:', data);
                        if (data.success) {
                            displayReservationHistory(data.usages);
                        } else {
                            historyContent.innerHTML = '<div class="no-data">åˆ©ç”¨å±¥æ­´ãŒã‚ã‚Šã¾ã›ã‚“</div>';
                        }
                    })
                    .catch(error => {
                        console.error('âŒ Error loading user history:', error);
                        historyContent.innerHTML = '<div class="no-data">åˆ©ç”¨å±¥æ­´ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ</div>';
                    });
            } else {
                historyContent.innerHTML = '<div class="no-data">ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ãŒã‚ã‚Šã¾ã›ã‚“</div>';
            }
        }

        // åˆ©ç”¨å±¥æ­´ã‚’èª­ã¿è¾¼ã¿
        function loadReservationHistory(reservation) {

            
            const historyContent = document.getElementById('history-content');
            if (!historyContent) return;

            // äºˆç´„ãƒ‡ãƒ¼ã‚¿ã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯
            if (!validateReservationData(reservation)) {
                historyContent.innerHTML = '<div class="no-data">äºˆç´„ãƒ‡ãƒ¼ã‚¿ãŒç„¡åŠ¹ã§ã™</div>';
                return;
            }

            // ãƒ¦ãƒ¼ã‚¶ãƒ¼IDãŒã‚ã‚‹å ´åˆã¯åˆ©ç”¨å±¥æ­´ã‚’å–å¾—
            if (reservation.userId) {
                fetch(`/admin/reservations/${reservation.id}/history`, {
                    headers: {
                        'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]')?.getAttribute('content')
                    }
                })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data.success) {
                            displayReservationHistory(data.usages);
                        } else {
                            historyContent.innerHTML = '<div class="no-data">åˆ©ç”¨å±¥æ­´ãŒã‚ã‚Šã¾ã›ã‚“</div>';
                        }
                    })
                    .catch(error => {
                        console.error('âŒ Error loading usage history:', error);
                        console.error('âŒ Error details:', {
                            message: error.message,
                            stack: error.stack,
                            reservationId: reservation.id,
                            userId: reservation.userId
                        });
                        historyContent.innerHTML = '<div class="no-data">åˆ©ç”¨å±¥æ­´ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ</div>';
                    });
            } else {
                historyContent.innerHTML = '<div class="no-data">ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ãŒã‚ã‚Šã¾ã›ã‚“</div>';
            }
        }

        // åˆ©ç”¨å±¥æ­´ã‚’è¡¨ç¤º
        function displayReservationHistory(usages) {
            const historyContent = document.getElementById('history-content');
            if (!historyContent) return;

            if (!usages || usages.length === 0) {
                historyContent.innerHTML = '<div class="no-data">åˆ©ç”¨å±¥æ­´ãŒã‚ã‚Šã¾ã›ã‚“</div>';
                return;
            }

            const historyHtml = usages.map(usage => {
                // Backend returns date and time as separate fields
                const displayDate = usage.date || 'Unknown Date';
                const displayTime = usage.time || 'Unknown Time';
                const displayName = usage.course || usage.ticket_name || 'Unknown';
                const typeIcon = usage.type === 'reservation' ? 'ğŸ“…' : 'ğŸ«';
                const typeText = usage.type === 'reservation' ? 'äºˆç´„' : 'ãƒã‚±ãƒƒãƒˆä½¿ç”¨';
                
                return `
                    <div class="history-item-compact">
                        <span class="history-icon-small">${typeIcon}</span>
                        <span class="history-content-compact">
                            <strong>${displayName}</strong> - ${displayDate} ${displayTime} (${typeText})
                        </span>
                    </div>
                `;
            }).join('');

            historyContent.innerHTML = historyHtml;
        }



        // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚¢ã‚¤ã‚³ãƒ³ã‚’å–å¾—
        function getStatusIcon(status) {
            const statusIcons = {
                'confirmed': 'âœ…',
                'tentative': 'â³',
                'cancelled': 'âŒ',
                'completed': 'âœ…',
                'no_show': 'âš ï¸'
            };
            return statusIcons[status] || 'â“';
        }



        // äºˆç´„ã‚’ç·¨é›†
        function editReservation() {
            if (!currentReservation) {
                showMessage('ç·¨é›†ã™ã‚‹äºˆç´„ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚', 'error');
                return;
            }
            
            console.log('âœï¸ Editing reservation:', currentReservation);
            
            // ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ãƒ•ãƒ©ã‚°ã‚’è¨­å®š
            isEditingReservation = true;
            
            // äºˆç´„ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ï¼ˆãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹å‰ã«ï¼‰
            reservationToEdit = { ...currentReservation };
            
            // äºˆç´„ã®å®Ÿéš›ã®æ—¥ä»˜ã‚’ç‰¹å®šï¼ˆreservationsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰è©²å½“ã™ã‚‹æ—¥ä»˜ã‚­ãƒ¼ã‚’æ¢ã™ï¼‰
            let actualReservationDate = null;
            let foundDateKey = null;
            
            // ã™ã¹ã¦ã®æ—¥ä»˜ã‚­ãƒ¼ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦è©²å½“ã™ã‚‹äºˆç´„ã‚’æ¢ã™
            for (const dateKey of Object.keys(reservations)) {
                const dayReservations = reservations[dateKey];
                const foundReservation = dayReservations.find(r => r.id === currentReservation.id);
                
                if (foundReservation) {
                    foundDateKey = dateKey;
                    // æ—¥ä»˜ã‚­ãƒ¼ã‹ã‚‰å®Ÿéš›ã®æ—¥ä»˜ã‚’è¨ˆç®—
                    const [year, month, day] = dateKey.split('-').map(Number);
                    const [hours, minutes] = currentReservation.time.split(':').map(Number);
                    actualReservationDate = new Date(year, month - 1, day, hours, minutes, 0, 0);
                    break;
                }
            }
            
            // è¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯createdAtã‹ã‚‰è¨ˆç®—ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
            if (!actualReservationDate) {
                console.warn('âš ï¸ Could not find reservation in date keys, using createdAt as fallback');
                actualReservationDate = new Date(reservationToEdit.createdAt);
                const [hours, minutes] = reservationToEdit.time.split(':').map(Number);
                actualReservationDate.setHours(hours, minutes, 0, 0);
            }
            
            console.log('ğŸ“… Actual reservation date:', actualReservationDate, 'from date key:', foundDateKey);
            
            // äºˆç´„è©³ç´°ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
            closeReservationDetailModal();
            
            // äºˆç´„ç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
            openBookingModal(actualReservationDate, reservationToEdit.time);
            
            // ãƒ•ã‚©ãƒ¼ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æ—¢å­˜ã®äºˆç´„ãƒ‡ãƒ¼ã‚¿ã§åŸ‹ã‚ã‚‹ï¼ˆãƒ¢ãƒ¼ãƒ€ãƒ«ãŒé–‹ã„ãŸå¾Œã«å®Ÿè¡Œï¼‰
            setTimeout(() => {
                const customerNameField = document.getElementById('customerName');
                const customerPhoneField = document.getElementById('customerPhone');
                const customerEmailField = document.getElementById('customerEmail');
                const bookingDurationField = document.getElementById('bookingDuration');
                const bookingNoteField = document.getElementById('bookingNote');
                const bookingStatusField = document.getElementById('bookingStatus');
                
                if (customerNameField) customerNameField.value = reservationToEdit.customer;
                if (customerPhoneField) customerPhoneField.value = reservationToEdit.phone;
                if (customerEmailField) customerEmailField.value = reservationToEdit.email;
                if (bookingDurationField) bookingDurationField.value = reservationToEdit.duration;
                if (bookingNoteField) bookingNoteField.value = reservationToEdit.note;
                if (bookingStatusField) bookingStatusField.value = reservationToEdit.status;
            }, 200);
            
            showMessage('äºˆç´„ã‚’ç·¨é›†ã§ãã¾ã™ã€‚', 'info');
        }

                // äºˆç´„ã‚’å‰Šé™¤
        function deleteReservation() {
            console.log('ğŸ—‘ï¸ deleteReservationé–¢æ•°ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã—ãŸ');
            console.log('ğŸ” currentReservation:', currentReservation);
            console.log('ğŸ” Function called from:', new Error().stack);
            
            if (!currentReservation) {
                showMessage('å‰Šé™¤ã™ã‚‹äºˆç´„ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚', 'error');
                console.error('âŒ currentReservationãŒæœªå®šç¾©ã§ã™');
                return;
            }
            
            if (!currentReservation.id) {
                showMessage('äºˆç´„IDãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚', 'error');
                console.error('âŒ currentReservation.idãŒæœªå®šç¾©ã§ã™:', currentReservation);
                return;
            }
            
            // è¿½åŠ ã®æ¤œè¨¼
            if (typeof currentReservation.id !== 'number' && typeof currentReservation.id !== 'string') {
                console.error('âŒ currentReservation.id has invalid type:', typeof currentReservation.id, currentReservation.id);
                showMessage('äºˆç´„IDã®å½¢å¼ãŒç„¡åŠ¹ã§ã™ã€‚', 'error');
                return;
            }
            
            if (currentReservation.id === 'calendar' || currentReservation.id === 'delete_reservation') {
                console.error('âŒ currentReservation.id has invalid value:', currentReservation.id);
                showMessage('äºˆç´„IDãŒç„¡åŠ¹ã§ã™ã€‚', 'error');
                return;
            }
            
            console.log('âœ… äºˆç´„IDç¢ºèª:', currentReservation.id);
            
            const confirmed = confirm(`ã“ã®äºˆç´„ã‚’å®Œå…¨ã«å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ\n\nãŠå®¢æ§˜: ${currentReservation.customer}\næ—¥æ™‚: ${currentReservation.time}\nã‚³ãƒ¼ã‚¹: ${currentReservation.duration}åˆ†\n\nã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚`);
            
            if (!confirmed) {
                return;
            }
            
            console.log('ğŸ—‘ï¸ Deleting reservation:', currentReservation);
            
            // è¦–è¦šçš„ãªãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯: å‰Šé™¤ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é–‹å§‹
            const reservationBlocks = document.querySelectorAll('.reservation-block');
            reservationBlocks.forEach(block => {
                if (block.textContent.includes(currentReservation.customer) && 
                    block.textContent.includes(currentReservation.time)) {
                    block.classList.add('deleting');
                }
            });
            
            // æ­£ã—ã„APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’ä½¿ç”¨
            console.log('ğŸ” Debug - currentReservation:', currentReservation);
            console.log('ğŸ” Debug - currentReservation.id:', currentReservation.id);
            const deleteUrl = `/admin/reservations/delete_reservation`;
            console.log('ğŸŒ å‰Šé™¤URL:', deleteUrl);
            
            // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã«å‰Šé™¤ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡
            console.log('ğŸŒ Making DELETE request to:', deleteUrl);
            console.log('ğŸ”‘ CSRF Token:', document.querySelector('meta[name="csrf-token"]')?.getAttribute('content'));
            
            fetch(deleteUrl, {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]')?.getAttribute('content')
                },
                body: JSON.stringify({
                    reservation_id: currentReservation.id
                })
            })
            .then(response => {
                console.log('ğŸ“¡ Response status:', response.status);
                console.log('ğŸ“¡ Response headers:', response.headers);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    console.log('âœ… Reservation deleted successfully');
                    
                    // ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰äºˆç´„ã‚’å‰Šé™¤
                    // äºˆç´„ã®å®Ÿéš›ã®æ—¥ä»˜ã‚’ç‰¹å®šã™ã‚‹ãŸã‚ã«ã€ã™ã¹ã¦ã®æ—¥ä»˜ã‚­ãƒ¼ã‚’ãƒã‚§ãƒƒã‚¯
                    console.log('ğŸ—‘ï¸ Searching for reservation ID:', currentReservation.id, 'in all date keys');
                    console.log('ğŸ—‘ï¸ Available date keys:', Object.keys(reservations));
                    
                    let foundDateKey = null;
                    let foundReservation = null;
                    
                    // ã™ã¹ã¦ã®æ—¥ä»˜ã‚­ãƒ¼ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦è©²å½“ã™ã‚‹äºˆç´„ã‚’æ¢ã™
                    for (const dateKey of Object.keys(reservations)) {
                        const dayReservations = reservations[dateKey];
                        const matchingReservation = dayReservations.find(r => r.id === currentReservation.id);
                        
                        if (matchingReservation) {
                            foundDateKey = dateKey;
                            foundReservation = matchingReservation;
                            console.log(`ğŸ—‘ï¸ Found reservation in date key: ${dateKey}`);
                            break;
                        }
                    }
                    
                    if (foundDateKey && foundReservation) {
                        const beforeCount = reservations[foundDateKey].length;
                        reservations[foundDateKey] = reservations[foundDateKey].filter(r => r.id !== currentReservation.id);
                        const afterCount = reservations[foundDateKey].length;
                        
                        console.log(`ğŸ—‘ï¸ Removed reservation: ${beforeCount} â†’ ${afterCount} reservations for ${foundDateKey}`);
                        
                        if (reservations[foundDateKey].length === 0) {
                            delete reservations[foundDateKey];
                            console.log(`ğŸ—‘ï¸ Deleted empty date key: ${foundDateKey}`);
                        }
                    } else {
                        console.warn(`âš ï¸ Reservation ID ${currentReservation.id} not found in any date key`);
                        console.warn(`âš ï¸ Available reservations:`, reservations);
                    }
                    
                    // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚’å†æç”»
                    generateTimeSlots();
                    
                    // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
                    closeReservationDetailModal();
                    
                    // æˆåŠŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
                    showMessage('äºˆç´„ãŒå‰Šé™¤ã•ã‚Œã¾ã—ãŸã€‚', 'success');
                    
                    // ãƒ‡ãƒãƒƒã‚°: å‰Šé™¤å¾Œã®äºˆç´„ãƒ‡ãƒ¼ã‚¿ã‚’ç¢ºèª
                    console.log('âœ… After deletion - reservations data:', reservations);
                } else {
                    console.error('âŒ Failed to delete reservation:', data.message);
                    showMessage(`äºˆç´„ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ: ${data.message}`, 'error');
                }
            })
            .catch(error => {
                console.error('âŒ Error deleting reservation:', error);
                showMessage('äºˆç´„ã®å‰Šé™¤ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚', 'error');
            });
        }
        
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•°ã¨ã—ã¦å…¬é–‹
        window.deleteReservationFromCalendar = deleteReservation;

        // äºˆç´„ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ï¼ˆå‰Šé™¤ï¼‰
        function cancelReservation() {
            console.log('ğŸ—‘ï¸ cancelReservationé–¢æ•°ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã—ãŸ');
            console.log('ğŸ” currentReservation:', currentReservation);
            console.log('ğŸ” Function called from:', new Error().stack);
            
            if (!currentReservation) {
                showMessage('ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã™ã‚‹äºˆç´„ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚', 'error');
                return;
            }
            
            if (!currentReservation.id) {
                console.error('âŒ currentReservation.id is undefined:', currentReservation);
                showMessage('äºˆç´„IDãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚', 'error');
                return;
            }
            
            // è¿½åŠ ã®æ¤œè¨¼
            if (typeof currentReservation.id !== 'number' && typeof currentReservation.id !== 'string') {
                console.error('âŒ currentReservation.id has invalid type:', typeof currentReservation.id, currentReservation.id);
                showMessage('äºˆç´„IDã®å½¢å¼ãŒç„¡åŠ¹ã§ã™ã€‚', 'error');
                return;
            }
            
            if (currentReservation.id === 'calendar' || currentReservation.id === 'delete_reservation') {
                console.error('âŒ currentReservation.id has invalid value:', currentReservation.id);
                showMessage('äºˆç´„IDãŒç„¡åŠ¹ã§ã™ã€‚', 'error');
                return;
            }
            
            const confirmed = confirm(`ã“ã®äºˆç´„ã‚’å®Œå…¨ã«å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ\n\nãŠå®¢æ§˜: ${currentReservation.customer}\næ—¥æ™‚: ${currentReservation.time}\nã‚³ãƒ¼ã‚¹: ${currentReservation.duration}åˆ†\n\nã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚`);
            
            if (!confirmed) {
                return;
            }
            
            // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã«å‰Šé™¤ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡
            console.log('ğŸ” Debug - currentReservation:', currentReservation);
            console.log('ğŸ” Debug - currentReservation.id:', currentReservation.id);
            const deleteUrl = `/admin/reservations/delete_reservation`;
            console.log('ğŸŒ ã‚­ãƒ£ãƒ³ã‚»ãƒ«URL:', deleteUrl);
            
            fetch(deleteUrl, {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]')?.getAttribute('content')
                },
                body: JSON.stringify({
                    reservation_id: currentReservation.id
                })
            })
            .then(response => {
                console.log('ğŸ“¡ Response status:', response.status);
                console.log('ğŸ“¡ Response headers:', response.headers);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
  .then(data => {
    if (data.success) {

                    

                    
                    // ã‚­ãƒ£ãƒ³ã‚»ãƒ«è¡¨ç¤ºã‚¨ãƒªã‚¢ã«è¿½åŠ ï¼ˆå‰Šé™¤å‰ã«äºˆç´„ãƒ‡ãƒ¼ã‚¿ã¨æ—¥ä»˜ã‚’ä¿å­˜ï¼‰
                    const reservationToCancel = { ...currentReservation };
                    
                    // äºˆç´„ã®å®Ÿéš›ã®æ—¥ä»˜ã‚’ç‰¹å®šï¼ˆdateKeyã‹ã‚‰æŠ½å‡ºï¼‰- å‰Šé™¤å‰ã«å®Ÿè¡Œ
                    let actualReservationDate = null;
                    let foundDateKey = null;
                    
                    // ã™ã¹ã¦ã®æ—¥ä»˜ã‚­ãƒ¼ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦è©²å½“ã™ã‚‹äºˆç´„ã‚’æ¢ã™
                    for (const dateKey of Object.keys(reservations)) {
                        const dayReservations = reservations[dateKey];
                        const foundReservation = dayReservations.find(r => r.id === reservationToCancel.id);
                        
                        if (foundReservation) {
                            foundDateKey = dateKey;
                            const [year, month, day] = dateKey.split('-').map(Number);
                            actualReservationDate = new Date(year, month - 1, day);
                            break;
                        }
                    }
                    
                    // è¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯createdAtã‹ã‚‰è¨ˆç®—
                    if (!actualReservationDate) {
                        actualReservationDate = new Date(reservationToCancel.createdAt);
                    }
                    
                    // ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰äºˆç´„ã‚’å‰Šé™¤
                    if (foundDateKey) {
                        const beforeCount = reservations[foundDateKey].length;
                        reservations[foundDateKey] = reservations[foundDateKey].filter(r => r.id !== reservationToCancel.id);
                        const afterCount = reservations[foundDateKey].length;
                        
                        if (reservations[foundDateKey].length === 0) {
                            delete reservations[foundDateKey];
                        }
                    }
                    
                    addToCancellationDisplay({
                        ...reservationToCancel,
                        start_time: actualReservationDate.toISOString()
                    });
                    
                    // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚’å†æç”»
                    generateTimeSlots();
                    
                    // ã‚­ãƒ£ãƒ³ã‚»ãƒ«è¡¨ç¤ºã‚’æ›´æ–°ï¼ˆDOMæ“ä½œå¾Œã«ç¢ºå®Ÿã«æ›´æ–°ï¼‰
                    setTimeout(() => {
                        updateCancellationDisplay();
                    }, 50);
                    
                    // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
                    closeReservationDetailModal();
                    
                    showMessage('äºˆç´„ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ï¼ˆå‰Šé™¤ï¼‰ã•ã‚Œã¾ã—ãŸã€‚', 'success');
                } else {
                    console.error('âŒ Failed to cancel reservation:', data.message);
                    showMessage(`äºˆç´„ã®ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã«å¤±æ•—ã—ã¾ã—ãŸ: ${data.message}`, 'error');
    }
  })
  .catch(error => {
                console.error('âŒ Error cancelling reservation:', error);
                showMessage('äºˆç´„ã®ã‚­ãƒ£ãƒ³ã‚»ãƒ«ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚', 'error');
            });
        }
        
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•°ã¨ã—ã¦å…¬é–‹
        window.cancelReservationFromCalendar = cancelReservation;

        // ã‚³ãƒ¼ã‚¹ã‹ã‚‰æ™‚é–“ã‚’æŠ½å‡ºã™ã‚‹é–¢æ•°
        function extractDurationFromCourse(courseString) {
            if (!courseString) return 60;
            
            const match = courseString.match(/(\d+)åˆ†/);
            return match ? parseInt(match[1]) : 60;
        }

        // é‡è¤‡ãƒã‚§ãƒƒã‚¯é–¢æ•°
        function checkForOverlap(dateTime, duration) {
            const startTime = new Date(dateTime);
            const endTime = new Date(startTime.getTime() + parseInt(duration) * 60 * 1000);
            const dateKey = formatDateKey(startTime);
            
            // æŒ‡å®šæ—¥ã®äºˆç´„ã‚’å–å¾—
            const dayReservations = reservations[dateKey] || [];
            
            // é‡è¤‡ãƒã‚§ãƒƒã‚¯ï¼ˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«æ™‚é–“ã‚‚å«ã‚€ï¼‰
            for (const reservation of dayReservations) {
                const reservationStart = new Date(`${dateKey}T${reservation.time}`);
                const reservationEnd = new Date(reservationStart.getTime() + reservation.duration * 60 * 1000);
                
                // ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«æ™‚é–“ã‚’å–å¾—ï¼ˆeffective_interval_minutesã‚’ä½¿ç”¨ï¼‰
                const intervalMinutes = reservation.effective_interval_minutes ?? 10;
                const reservationEndWithInterval = new Date(reservationEnd.getTime() + intervalMinutes * 60 * 1000);
                
                // ç¾åœ¨ã®äºˆç´„ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«æ™‚é–“ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ10åˆ†ï¼‰
                const currentIntervalMinutes = 10; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ10åˆ†
                const currentEndWithInterval = new Date(endTime.getTime() + currentIntervalMinutes * 60 * 1000);
                
                // é‡è¤‡åˆ¤å®šï¼ˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«æ™‚é–“ã‚‚å«ã‚€ï¼‰
                if (startTime < reservationEndWithInterval && currentEndWithInterval > reservationStart) {
                    return true; // é‡è¤‡ã‚ã‚Š
                }
            }
            
            return false; // é‡è¤‡ãªã—
        }

        // äºˆç´„å¯èƒ½æ™‚é–“ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆã™ã‚‹é–¢æ•°
        function highlightAvailableSlots() {
            const dateTime = document.getElementById('bookingDate')?.value;
            const duration = document.getElementById('bookingDuration')?.value;
            
            if (!dateTime || !duration) return;
            
            const startTime = new Date(dateTime);
            const endTime = new Date(startTime.getTime() + parseInt(duration) * 60 * 1000);
            const dateKey = formatDateKey(startTime);
            
            // æ—¢å­˜ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’ã‚¯ãƒªã‚¢
            document.querySelectorAll('.time-slot').forEach(slot => {
                slot.classList.remove('overlap-warning', 'available-slot');
            });
            
            // æŒ‡å®šæ—¥ã®äºˆç´„ã‚’å–å¾—
            const dayReservations = reservations[dateKey] || [];
            
            // å„æ™‚é–“ã‚¹ãƒ­ãƒƒãƒˆã‚’ãƒã‚§ãƒƒã‚¯
            document.querySelectorAll('.time-slot').forEach(slot => {
                const slotTime = slot.getAttribute('data-time');
                if (!slotTime) return;
                
                const slotStart = new Date(`${dateKey}T${slotTime}`);
                const slotEnd = new Date(slotStart.getTime() + parseInt(duration) * 60 * 1000);
                
                // é‡è¤‡ãƒã‚§ãƒƒã‚¯ï¼ˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«æ™‚é–“ã‚‚å«ã‚€ï¼‰
                let hasOverlap = false;
                for (const reservation of dayReservations) {
                    const reservationStart = new Date(`${dateKey}T${reservation.time}`);
                    const reservationEnd = new Date(reservationStart.getTime() + reservation.duration * 60 * 1000);
                    
                    // ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«æ™‚é–“ã‚’å–å¾—ï¼ˆeffective_interval_minutesã‚’ä½¿ç”¨ï¼‰
                    const intervalMinutes = reservation.effective_interval_minutes ?? 10;
                    const reservationEndWithInterval = new Date(reservationEnd.getTime() + intervalMinutes * 60 * 1000);
                    
                    // ç¾åœ¨ã®ã‚¹ãƒ­ãƒƒãƒˆã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«æ™‚é–“ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ10åˆ†ï¼‰
                    const currentIntervalMinutes = 10; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ10åˆ†
                    const slotEndWithInterval = new Date(slotEnd.getTime() + currentIntervalMinutes * 60 * 1000);
                    
                    if (slotStart < reservationEndWithInterval && slotEndWithInterval > reservationStart) {
                        hasOverlap = true;
                        break;
                    }
                }
                
                if (hasOverlap) {
                    slot.classList.add('overlap-warning');
                } else {
                    slot.classList.add('available-slot');
                }
            });
        }

        // ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—æ©Ÿèƒ½
        let isDragging = false;
        let draggedReservationData = null;

        function handleDragStart(e) {
            console.log('ğŸ¯ handleDragStart called for target:', e.target);
            isDragging = true;
            
            // The target should be the reservation block itself
            const reservationBlock = e.target;
            
            if (!reservationBlock || !reservationBlock.classList.contains('reservation-block')) {
                console.error('âŒ Target is not a reservation block');
                return;
            }
            
            const reservationId = reservationBlock.dataset.reservationId;
            
            if (!reservationId) {
                console.error('âŒ Reservation ID not found');
                return;
            }
            
            console.log('ğŸ¯ Drag started for reservation:', reservationId, 'from block:', reservationBlock);
            
            // Store the original reservation data for better debugging
            const reservationData = JSON.parse(reservationBlock.dataset.reservationData);
            draggedReservationData = reservationData; // Store globally
            
            console.log('ğŸ¯ Original reservation data:', {
                id: reservationData.id,
                customer: reservationData.customer,
                time: reservationData.time,
                date: reservationBlock.dataset.originalDateKey
            });
            
            e.dataTransfer.setData('text/plain', reservationId);
            reservationBlock.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            
            // Use the original block as the drag image so it follows the cursor
            e.dataTransfer.setDragImage(reservationBlock, 50, 25);
            
            // Prevent other drag events from firing
            e.stopPropagation();
        }

        function handleDragEnd(e) {
            // The target should be the reservation block itself
            const reservationBlock = e.target;
            
            if (reservationBlock && reservationBlock.classList.contains('reservation-block')) {
                reservationBlock.classList.remove('dragging');
            }
            
            document.querySelectorAll('.schedule-cell').forEach(cell => {
                cell.classList.remove('drag-over');
                cell.classList.remove('drag-over-invalid');
            });
            
                            // å°‘ã—é…å»¶ã—ã¦ã‹ã‚‰ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆèª¤ã‚¯ãƒªãƒƒã‚¯ã‚’é˜²ãï¼‰
                setTimeout(() => {
                    isDragging = false;
                    draggedReservationData = null; // Clear global data
                }, 100);
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            
            const cell = e.target.closest('.schedule-cell');
            if (cell) {
                // Clear all previous drag-over states
                document.querySelectorAll('.schedule-cell').forEach(c => {
                    c.classList.remove('drag-over');
                    c.classList.remove('drag-over-invalid');
                });
                
                // Get the reservation data from global variable
                if (draggedReservationData) {
                    const reservationData = draggedReservationData;
                    const duration = reservationData.duration || 60;
                    const interval = reservationData.effective_interval_minutes ?? 10;
                    const totalDuration = duration + interval;
                    
                    // Calculate how many cells this reservation would occupy (10-minute slots)
                    const cellsToOccupy = Math.ceil(totalDuration / 10);
                    
                    // Check if all required cells are within business hours
                    let currentCell = cell;
                    let allCellsValid = true;
                    let cellsToCheck = [];
                    
                    // First, collect all cells that would be occupied
                    for (let i = 0; i < cellsToOccupy && currentCell; i++) {
                        cellsToCheck.push(currentCell);
                        
                        // Move to the next row (next time slot) in the same day column
                        const currentRow = currentCell.parentElement;
                        const nextRow = currentRow.nextElementSibling;
                        if (nextRow) {
                            const nextCell = nextRow.querySelector(`[data-day="${currentCell.dataset.day}"]`);
                            if (nextCell && nextCell.classList.contains('schedule-cell')) {
                                currentCell = nextCell;
                            } else {
                                break; // No more cells in this day column
                            }
                        } else {
                            break; // No more rows
                        }
                    }
                    
                    // Check if all cells are within business hours
                    for (let checkCell of cellsToCheck) {
                        const dayOfWeek = parseInt(checkCell.dataset.day);
                        const timeStr = checkCell.dataset.time;
                        
                        if (!isBusinessHour(dayOfWeek, timeStr)) {
                            allCellsValid = false;
                            break;
                        }
                    }
                    
                    // Only highlight if all cells are valid
                    if (allCellsValid) {
                        for (let checkCell of cellsToCheck) {
                            checkCell.classList.add('drag-over');
                        }
                    } else {
                        // Show invalid drop effect and visual feedback
                        e.dataTransfer.dropEffect = 'none';
                        for (let checkCell of cellsToCheck) {
                            checkCell.classList.add('drag-over-invalid');
                        }
                    }
                } else {
                    // If no dragged data, check if current cell is within business hours
                    const dayOfWeek = parseInt(cell.dataset.day);
                    const timeStr = cell.dataset.time;
                    
                    if (isBusinessHour(dayOfWeek, timeStr)) {
                        cell.classList.add('drag-over');
                    } else {
                        e.dataTransfer.dropEffect = 'none';
                    }
                }
            }
        }

        function handleDragEnter(e) {
            e.preventDefault();
            if (e.target.classList.contains('schedule-cell')) {
                e.target.classList.add('drag-over');
            }
        }

        function handleDragLeave(e) {
            if (e.target.classList.contains('schedule-cell')) {
                e.target.classList.remove('drag-over');
            }
        }

        function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            
            // ãƒ‰ãƒ©ãƒƒã‚°ã‚ªãƒ¼ãƒãƒ¼çŠ¶æ…‹ã‚’ã‚¯ãƒªã‚¢
            document.querySelectorAll('.schedule-cell').forEach(cell => {
                cell.classList.remove('drag-over');
                cell.classList.remove('drag-over-invalid');
            });
            
            const cell = e.target.closest('.schedule-cell');
            if (!cell) return;
            
            const reservationId = e.dataTransfer.getData('text/plain');
            console.log('ğŸ¯ Drop detected for reservation:', reservationId, 'at cell:', cell.dataset.day, cell.dataset.time);
            
            if (!reservationId || reservationId.trim() === '') {
                console.log('âŒ Empty reservation ID, ignoring drop');
                return;
            }
            
            const reservationBlock = document.querySelector(`[data-reservation-id="${reservationId}"]`);
            
            if (!reservationBlock) {
                console.log('âŒ Reservation block not found for ID:', reservationId);
                return;
            }
            
            const reservationData = JSON.parse(reservationBlock.dataset.reservationData);
            const newDay = parseInt(cell.dataset.day);
            const newTime = cell.dataset.time;
            
            // Check if the target time slot is within business hours
            if (!isBusinessHour(newDay, newTime)) {
                showMessage('å–¶æ¥­æ™‚é–“å¤–ã®ãŸã‚ã€ã“ã®æ™‚é–“ã«äºˆç´„ã‚’ç§»å‹•ã§ãã¾ã›ã‚“ã€‚', 'error');
                return;
            }
            
            // Check if all required time slots for the reservation are within business hours
            const duration = reservationData.duration || 60;
            const interval = reservationData.effective_interval_minutes ?? 10;
            const totalDuration = duration + interval;
            const cellsToOccupy = Math.ceil(totalDuration / 10);
            
            let currentCell = cell;
            let allSlotsValid = true;
            
            for (let i = 0; i < cellsToOccupy && currentCell; i++) {
                const dayOfWeek = parseInt(currentCell.dataset.day);
                const timeStr = currentCell.dataset.time;
                
                if (!isBusinessHour(dayOfWeek, timeStr)) {
                    allSlotsValid = false;
                    break;
                }
                
                // Move to the next row (next time slot) in the same day column
                const currentRow = currentCell.parentElement;
                const nextRow = currentRow.nextElementSibling;
                if (nextRow) {
                    const nextCell = nextRow.querySelector(`[data-day="${currentCell.dataset.day}"]`);
                    if (nextCell && nextCell.classList.contains('schedule-cell')) {
                        currentCell = nextCell;
                    } else {
                        break; // No more cells in this day column
                    }
                } else {
                    break; // No more rows
                }
            }
            
            if (!allSlotsValid) {
                showMessage('äºˆç´„æ™‚é–“ãŒå–¶æ¥­æ™‚é–“å¤–ã«åŠã¶ãŸã‚ã€ã“ã®ä½ç½®ã«ç§»å‹•ã§ãã¾ã›ã‚“ã€‚', 'error');
                return;
            }
            
            // æ–°ã—ã„æ—¥ä»˜ã‚’è¨ˆç®—
            const newDate = new Date(currentWeekStart);
            newDate.setDate(newDate.getDate() + newDay);
            const newDateKey = formatDateKey(newDate);
            
            // é‡è¤‡ãƒã‚§ãƒƒã‚¯
            console.log('ğŸ” Checking for overlap:', {
                reservationId: reservationData.id,
                from: `${reservationBlock.dataset.originalDateKey} ${reservationBlock.dataset.originalTimeStr}`,
                to: `${newDateKey} ${newTime}`,
                duration: reservationData.duration,
                interval: reservationData.effective_interval_minutes ?? 10
            });
            
            // åŒã˜å ´æ‰€ã«ãƒ‰ãƒ­ãƒƒãƒ—ã—ãŸå ´åˆã¯ä½•ã‚‚ã—ãªã„
            if (reservationBlock.dataset.originalDateKey === newDateKey && 
                reservationBlock.dataset.originalTimeStr === newTime) {
                console.log('â­ï¸ Dropped in same location, ignoring');
                return;
            }
            
            if (checkForOverlapOnDrop(newDateKey, newTime, reservationData)) {
                showMessage('ã“ã®æ™‚é–“å¸¯ã«ã¯æ—¢ã«äºˆç´„ãŒã‚ã‚Šã¾ã™ã€‚åˆ¥ã®æ™‚é–“ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚', 'error');
                return;
            }
            
            console.log('âœ… Proceeding with reservation update');
            
            // Prevent multiple updates for the same reservation
            if (reservationBlock.dataset.updating === 'true') {
                console.log('â­ï¸ Reservation already being updated, skipping');
                return;
            }
            
            reservationBlock.dataset.updating = 'true';
            updateReservationTime(reservationData.id, newDateKey, newTime);
        }

        // ãƒ‰ãƒ­ãƒƒãƒ—æ™‚ã®é‡è¤‡ãƒã‚§ãƒƒã‚¯
        function checkForOverlapOnDrop(dateKey, timeStr, reservationData) {
            const startTime = new Date(`${dateKey}T${timeStr}`);
            const endTime = new Date(startTime.getTime() + reservationData.duration * 60 * 1000);
            
            // æŒ‡å®šæ—¥ã®äºˆç´„ã‚’å–å¾—ï¼ˆè‡ªåˆ†ä»¥å¤–ï¼‰
            const dayReservations = reservations[dateKey] || [];
            
            console.log('ğŸ” Checking overlaps for:', {
                dateKey: dateKey,
                timeStr: timeStr,
                reservationId: reservationData.id,
                duration: reservationData.duration,
                dayReservations: dayReservations.length
            });
            
            // é‡è¤‡ãƒã‚§ãƒƒã‚¯ï¼ˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«æ™‚é–“ã‚‚å«ã‚€ï¼‰
            for (const reservation of dayReservations) {
                if (reservation.id === reservationData.id) {
                    console.log('â­ï¸ Skipping self:', reservation.id);
                    continue; // è‡ªåˆ†ã¯é™¤å¤–
                }
                
                const reservationStart = new Date(`${dateKey}T${reservation.time}`);
                const reservationEnd = new Date(reservationStart.getTime() + reservation.duration * 60 * 1000);
                
                // ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«æ™‚é–“ã‚’å–å¾—ï¼ˆeffective_interval_minutesã‚’ä½¿ç”¨ï¼‰
                const intervalMinutes = reservation.effective_interval_minutes ?? 10;
                const reservationEndWithInterval = new Date(reservationEnd.getTime() + intervalMinutes * 60 * 1000);
                
                // ç¾åœ¨ã®äºˆç´„ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«æ™‚é–“
                const currentIntervalMinutes = reservationData.effective_interval_minutes ?? 10;
                const currentEndWithInterval = new Date(endTime.getTime() + currentIntervalMinutes * 60 * 1000);
                
                console.log('ğŸ” Comparing with reservation:', {
                    existingId: reservation.id,
                    existingTime: `${reservation.time} - ${new Date(reservationEndWithInterval).toTimeString().slice(0, 5)}`,
                    newTime: `${timeStr} - ${new Date(currentEndWithInterval).toTimeString().slice(0, 5)}`,
                    existingInterval: intervalMinutes,
                    newInterval: currentIntervalMinutes
                });
                
                // é‡è¤‡åˆ¤å®šï¼ˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«æ™‚é–“ã‚‚å«ã‚€ï¼‰
                if (startTime < reservationEndWithInterval && currentEndWithInterval > reservationStart) {
                    console.log('ğŸš« Overlap detected:', {
                        newReservation: `${timeStr} - ${new Date(currentEndWithInterval).toTimeString().slice(0, 5)}`,
                        existingReservation: `${reservation.time} - ${new Date(reservationEndWithInterval).toTimeString().slice(0, 5)}`,
                        date: dateKey
                    });
                    return true; // é‡è¤‡ã‚ã‚Š
                }
            }
            
            console.log('âœ… No overlaps detected');
            return false; // é‡è¤‡ãªã—
        }

        // äºˆç´„æ™‚é–“ã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
        function updateReservationTime(reservationId, newDateKey, newTime) {
            // å…ƒã®äºˆç´„ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            const originalDateKey = document.querySelector(`[data-reservation-id="${reservationId}"]`)?.dataset.originalDateKey;
            const originalTimeStr = document.querySelector(`[data-reservation-id="${reservationId}"]`)?.dataset.originalTimeStr;
            
            if (!originalDateKey || !originalTimeStr) {
                showMessage('äºˆç´„ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚', 'error');
                return;
            }
            
            // æ–°ã—ã„é–‹å§‹æ™‚é–“ã‚’ISOå½¢å¼ã§ä½œæˆ
            const newStartTime = `${newDateKey}T${newTime}`;
            
            // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã«æ›´æ–°ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡
            const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');
            
            // äºˆç´„ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¦ã‚³ãƒ¼ã‚¹æƒ…å ±ã‚‚å«ã‚ã‚‹
            const reservationBlock = document.querySelector(`[data-reservation-id="${reservationId}"]`);
            const reservationData = reservationBlock ? JSON.parse(reservationBlock.dataset.reservationData) : null;
            
            // ã‚ˆã‚Šå®Œå…¨ãªäºˆç´„ãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡
            const updateData = {
                reservation: {
                    start_time: newStartTime,
                    course: reservationData ? `${reservationData.duration}åˆ†` : undefined
                }
            };
            
            // ä¼‘æ†©æ©Ÿèƒ½ã¯ç„¡åŠ¹åŒ–
            // ä¼‘æ†©äºˆç´„ã®å ´åˆã¯is_breakãƒ•ãƒ©ã‚°ã‚‚é€ä¿¡ï¼ˆç„¡åŠ¹åŒ–ï¼‰
            
            console.log('ğŸ”„ Sending update request:', updateData);
            console.log('ğŸ”„ Original reservation data:', reservationData);
            console.log('ğŸ”„ Course duration:', reservationData ? reservationData.duration : 'undefined');
            console.log('ğŸ”„ Is break: false (ä¼‘æ†©æ©Ÿèƒ½ã¯ç„¡åŠ¹åŒ–)');
            console.log('ğŸ”„ Course string being sent:', updateData.reservation.course);
            
            fetch(`/admin/reservations/${reservationId}/update_booking`, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-Token': csrfToken
                },
                body: JSON.stringify(updateData)
            })
            .then(response => {
                console.log('ğŸ”„ Response received:', response.status, response.statusText);
                if (!response.ok) {
                    return response.json().then(errorData => {
                        console.error('âŒ Server error response:', errorData);
                        console.error('âŒ Response status:', response.status);
                        console.error('âŒ Response headers:', response.headers);
                        throw new Error(`HTTP error! status: ${response.status}, message: ${errorData.message || 'Unknown error'}`);
                    }).catch(() => {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    });
                }
                return response.json();
            })
            .then(data => {
                console.log('ğŸ”„ Response data received:', data);
                if (data.success) {
                    console.log('âœ… Update successful, updating local data');
                    // ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°
                    updateLocalReservationData(reservationId, newDateKey, newTime);
                    
                    // updatedAtãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æ›´æ–°
                    if (data.reservation && data.reservation.updated_at) {
                        // ã‚°ãƒ­ãƒ¼ãƒãƒ«reservationsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®updatedAtã‚’æ›´æ–°
                        const reservationIndex = reservations[newDateKey].findIndex(r => r.id === parseInt(reservationId));
                        if (reservationIndex !== -1) {
                            reservations[newDateKey][reservationIndex].updatedAt = data.reservation.updated_at;
                            console.log('âœ… Updated updatedAt in global reservations object');
                        } else {
                            console.warn('âš ï¸ Reservation not found in global reservations object for update');
                        }
                        
                                                // ç¾åœ¨é–‹ã„ã¦ã„ã‚‹ãƒ¢ãƒ¼ãƒ€ãƒ«ã®å¤‰æ›´æ—¥æ™‚ã‚’å³åº§ã«æ›´æ–°
                        console.log('ğŸ” Checking if currentReservation matches updated reservation');
                        if (currentReservation && currentReservation.id === parseInt(reservationId)) {
                            console.log('ğŸ”„ Updating currentReservation after drag-and-drop:', {
                                before: {
                                    time: currentReservation.time,
                                    date: currentReservation.date,
                                    dateKey: currentReservation.dateKey,
                                    start_time: currentReservation.start_time
                                }
                            });
                            
                            currentReservation.updatedAt = data.reservation.updated_at;
                            // æ—¥ä»˜ã¨æ™‚é–“ã‚‚æ›´æ–°
                            currentReservation.time = newTime;
                            currentReservation.date = newDateKey;
                            currentReservation.dateKey = newDateKey;
                            // start_timeã‚‚æ›´æ–°
                            const [hours, minutes] = newTime.split(':');
                            const newStartTime = new Date(`${newDateKey}T${hours}:${minutes}:00+09:00`);
                            currentReservation.start_time = newStartTime.toISOString();
                            
                            console.log('ğŸ”„ Updated currentReservation after drag-and-drop:', {
                                after: {
                                    time: currentReservation.time,
                                    date: currentReservation.date,
                                    dateKey: currentReservation.dateKey,
                                    start_time: currentReservation.start_time
                                }
                            });
                            
                            try {
                                updateModalUpdatedAt(data.reservation.updated_at);
                                console.log('âœ… Modal updated at timestamp updated successfully');
                            } catch (error) {
                                console.error('âŒ Error updating modal timestamp:', error);
                            }
                        } else {
                            console.log('âŒ currentReservation not found or ID mismatch:', {
                                currentReservation: currentReservation ? currentReservation.id : 'null',
                                reservationId: reservationId
                            });
                            console.log('ğŸ” currentReservation details:', currentReservation);
                            
                            // ãƒ¢ãƒ¼ãƒ€ãƒ«ãŒé–‹ã„ã¦ã„ã‚‹å ´åˆã¯ã€æœ€æ–°ã®ãƒ‡ãƒ¼ã‚¿ã§currentReservationã‚’æ›´æ–°
                            const modal = document.getElementById('reservationDetailModal');
                            console.log('ğŸ” Modal display status:', modal ? modal.style.display : 'modal not found');
                            console.log('ğŸ” Modal element:', modal);
                            
                            if (modal && modal.style.display === 'block') {
                                console.log('ğŸ” Modal is open, updating currentReservation...');
                                console.log('ğŸ” Searching through reservations for ID:', reservationId);
                                // æœ€æ–°ã®äºˆç´„ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¦currentReservationã‚’æ›´æ–°
                                for (const dateKey of Object.keys(reservations)) {
                                    const dayReservations = reservations[dateKey];
                                    const foundReservation = dayReservations.find(r => r.id === parseInt(reservationId));
                                                                    if (foundReservation) {
                                    currentReservation = foundReservation;
                                    console.log('ğŸ”„ Updated currentReservation from reservations data:', {
                                        time: currentReservation.time,
                                        date: currentReservation.date,
                                        dateKey: currentReservation.dateKey,
                                        start_time: currentReservation.start_time
                                    });
                                    console.log('ğŸ”„ currentReservation object after update:', currentReservation);
                                    console.log('ğŸ”„ Found reservation details:', foundReservation);
                                    console.log('ğŸ”„ Updated currentReservation successfully');
                                    break;
                                } else {
                                    console.log('ğŸ” No matching reservation found in dayReservations for ID:', reservationId);
                                    console.log('ğŸ” Available reservations in this day:', dayReservations.map(r => ({ id: r.id, time: r.time, date: r.date })));
                                }
                                }
                            } else {
                                console.log('ğŸ” Modal is not open, skipping currentReservation update');
                                console.log('ğŸ” Modal display value:', modal ? modal.style.display : 'N/A');
                            }
                        }
                    }
                    
                    // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚’å†æç”»
                    console.log('ğŸ”„ Regenerating calendar after reservation move');
                    try {
                        generateTimeSlots();
                        console.log('âœ… Calendar regenerated successfully');
                    } catch (error) {
                        console.error('âŒ Error regenerating calendar:', error);
                    }
                    
                    showMessage('äºˆç´„æ™‚é–“ãŒæ›´æ–°ã•ã‚Œã¾ã—ãŸã€‚', 'success');
                } else {
                    console.error('âŒ Update failed:', data.message);
                    showMessage(`äºˆç´„ã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ: ${data.message}`, 'error');
                }
                
                // Reset updating flag
                const reservationBlock = document.querySelector(`[data-reservation-id="${reservationId}"]`);
                if (reservationBlock) {
                    reservationBlock.dataset.updating = 'false';
                    console.log('âœ… Updating flag reset to false');
                } else {
                    console.warn('âš ï¸ Reservation block element not found for updating flag reset');
                }
            })
            .catch(error => {
                console.error('âŒ Error updating reservation:', error);
                console.error('âŒ Error details:', error.message);
                console.error('âŒ Error stack:', error.stack);
                showMessage('äºˆç´„ã®æ›´æ–°ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚', 'error');
                
                // Reset updating flag on error
                const reservationBlock = document.querySelector(`[data-reservation-id="${reservationId}"]`);
                if (reservationBlock) {
                    reservationBlock.dataset.updating = 'false';
                    console.log('âœ… Updating flag reset to false after error');
                } else {
                    console.warn('âš ï¸ Reservation block element not found for updating flag reset after error');
                }
            });
        }

        // ãƒ­ãƒ¼ã‚«ãƒ«äºˆç´„ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°
        function updateLocalReservationData(reservationId, newDateKey, newTime) {
            console.log('ğŸ”„ Updating local reservation data:', {
                reservationId: reservationId,
                newDateKey: newDateKey,
                newTime: newTime
            });
            console.log('ğŸ”„ Current reservations object:', reservations);
            
            // å…ƒã®äºˆç´„ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            let originalReservationData = null;
            let originalDateKey = null;
            
            console.log('ğŸ” Searching for original reservation in reservations object');
            // å…ƒã®äºˆç´„ã‚’è¦‹ã¤ã‘ã¦å‰Šé™¤
            for (const dateKey of Object.keys(reservations)) {
                const reservationIndex = reservations[dateKey].findIndex(r => r.id === parseInt(reservationId));
                if (reservationIndex !== -1) {
                    originalReservationData = { ...reservations[dateKey][reservationIndex] };
                    originalDateKey = dateKey;
                    console.log('ğŸ” Found original reservation:', originalReservationData);
                    console.log('ğŸ” Original date key:', originalDateKey);
                    
                    reservations[dateKey].splice(reservationIndex, 1);
                    
                    // ç©ºã®é…åˆ—ã®å ´åˆã¯æ—¥ä»˜ã‚­ãƒ¼ã‚’å‰Šé™¤
                    if (reservations[dateKey].length === 0) {
                        delete reservations[dateKey];
                    }
                    break;
                }
            }
            
            if (!originalReservationData) {
                console.error('âŒ Original reservation data not found for ID:', reservationId);
                return;
            }
            
            // æ–°ã—ã„å ´æ‰€ã«äºˆç´„ã‚’è¿½åŠ 
            if (!reservations[newDateKey]) {
                reservations[newDateKey] = [];
            }
            
            // äºˆç´„ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°
            const updatedReservationData = {
                ...originalReservationData,
                time: newTime,
                date: newDateKey,
                dateKey: newDateKey,
                // start_timeã‚‚æ›´æ–°
                start_time: new Date(`${newDateKey}T${newTime}:00+09:00`).toISOString()
            };
            
            console.log('ğŸ”„ Updated reservation data:', updatedReservationData);
            reservations[newDateKey].push(updatedReservationData);
            
            // DOMè¦ç´ ã®ãƒ‡ãƒ¼ã‚¿å±æ€§ã‚‚æ›´æ–°
            const reservationBlock = document.querySelector(`[data-reservation-id="${reservationId}"]`);
            if (reservationBlock) {
                console.log('ğŸ”„ Updating DOM element data attributes');
                reservationBlock.dataset.originalDateKey = newDateKey;
                reservationBlock.dataset.originalTimeStr = newTime;
                reservationBlock.dataset.reservationData = JSON.stringify(updatedReservationData);
                console.log('ğŸ”„ DOM element updated successfully');
            } else {
                console.warn('âš ï¸ Reservation block element not found for DOM update');
            }
            
            console.log('âœ… Local reservation data updated:', {
                from: originalDateKey,
                to: newDateKey,
                reservationId: reservationId
            });
            console.log('âœ… Final reservations object state:', reservations);
        }

        // äºˆç´„ãƒ‡ãƒ¼ã‚¿ã®å¦¥å½“æ€§ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹é–¢æ•°
        function validateReservationData(reservation) {
            console.log('ğŸ” äºˆç´„ãƒ‡ãƒ¼ã‚¿å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯é–‹å§‹:', reservation);
            
            if (!reservation) {
                console.error('âŒ Reservation is null or undefined');
                return false;
            }
            
            if (!reservation.id || reservation.id === 'null' || reservation.id === null || reservation.id === undefined) {
                console.error('âŒ Invalid reservation ID:', reservation.id);
                console.error('âŒ Reservation object:', reservation);
                return false;
            }
            
            console.log('âœ… äºˆç´„IDç¢ºèª:', reservation.id);
            
            if (!reservation.userId || reservation.userId === 'null' || reservation.userId === null) {
                console.warn('âš ï¸ No user ID for reservation:', reservation.id);
                // Don't return false - allow modal to open without userId
            }
            
            console.log('âœ… äºˆç´„ãƒ‡ãƒ¼ã‚¿å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯å®Œäº†');
            return true;
        }

                // ãƒ¦ãƒ¼ã‚¶ãƒ¼æ¤œç´¢æ©Ÿèƒ½
        function setupUserSearch() {
            // é€šå¸¸ã®äºˆç´„ä½œæˆãƒ¢ãƒ¼ãƒ€ãƒ«ç”¨
            const customerNameInput = document.getElementById('customerName');
            const searchResults = document.getElementById('userSearchResults');
            
            if (customerNameInput && searchResults) {
                setupUserSearchForInput(customerNameInput, searchResults, 'customerName', 'customerPhone', 'customerEmail');
            }
            
            // ä¸€æ‹¬äºˆç´„ä½œæˆãƒ¢ãƒ¼ãƒ€ãƒ«ç”¨
            const bulkCustomerNameInput = document.getElementById('bulkCustomerName');
            const bulkSearchResults = document.getElementById('bulkUserSearchResults');
            
            if (bulkCustomerNameInput && bulkSearchResults) {
                setupUserSearchForInput(bulkCustomerNameInput, bulkSearchResults, 'bulkCustomerName', 'bulkCustomerPhone', 'bulkCustomerEmail');
            }
        }
        
        function setupUserSearchForInput(inputElement, resultsElement, nameFieldId, phoneFieldId, emailFieldId) {
            // å…¥åŠ›ã‚¤ãƒ™ãƒ³ãƒˆ
            inputElement.addEventListener('input', function() {
                const query = this.value.trim();
                
                // ãƒ‡ãƒã‚¦ãƒ³ã‚¹å‡¦ç†
                if (searchTimeout) {
                    clearTimeout(searchTimeout);
                }
                
                if (query.length < 2) {
                    hideUserSearchResults(resultsElement);
                    return;
                }
                
                searchTimeout = setTimeout(() => {
                    searchUsers(query, resultsElement, nameFieldId, phoneFieldId, emailFieldId);
                }, 300);
            });
            
            // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã‚¢ã‚¦ãƒˆæ™‚ã«çµæœã‚’éš ã™
            inputElement.addEventListener('blur', function() {
                setTimeout(() => {
                    hideUserSearchResults(resultsElement);
                }, 200);
            });
            
            // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹æ™‚ã«çµæœã‚’è¡¨ç¤ºï¼ˆå…¥åŠ›ãŒã‚ã‚‹å ´åˆï¼‰
            inputElement.addEventListener('focus', function() {
                const query = this.value.trim();
                if (query.length >= 2) {
                    searchUsers(query, resultsElement, nameFieldId, phoneFieldId, emailFieldId);
                }
            });
        }
        
        function searchUsers(query, resultsElement, nameFieldId, phoneFieldId, emailFieldId) {
            fetch(`/admin/reservations/search_users?query=${encodeURIComponent(query)}`)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        displayUserSearchResults(data.users, resultsElement, nameFieldId, phoneFieldId, emailFieldId);
                    } else {
                        console.error('âŒ User search failed:', data.message);
                        hideUserSearchResults(resultsElement);
                    }
                })
                .catch(error => {
                    console.error('âŒ Error searching users:', error);
                    hideUserSearchResults(resultsElement);
                });
        }
        
        function displayUserSearchResults(users, resultsElement, nameFieldId, phoneFieldId, emailFieldId) {
            if (!resultsElement) return;
            
            if (users.length === 0) {
                resultsElement.innerHTML = '<div class="user-search-item">è©²å½“ã™ã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“</div>';
                resultsElement.style.display = 'block';
                return;
            }
            
            const resultsHtml = users.map(user => `
                <div class="user-search-item" onclick="selectUser(${user.id}, '${user.name}', '${user.phone_number}', '${user.email}', '${nameFieldId}', '${phoneFieldId}', '${emailFieldId}')">
                    <div class="user-name">${user.name}</div>
                    <div class="user-details">
                        ğŸ“ ${user.phone_number || 'æœªè¨­å®š'} | ğŸ“§ ${user.email || 'æœªè¨­å®š'}
                        ${user.active_tickets > 0 ? `<span class="user-tickets"> | ğŸ« æ®‹${user.active_tickets}æš</span>` : ''}
                        ${user.last_visit !== 'ãªã—' ? ` | ğŸ“… æœ€çµ‚æ¥åº—: ${user.last_visit}` : ''}
                    </div>
                </div>
            `).join('');
            
            resultsElement.innerHTML = resultsHtml;
            resultsElement.style.display = 'block';
        }
        
        function selectUser(userId, name, phone, email, nameFieldId, phoneFieldId, emailFieldId) {
            // ãƒ•ã‚©ãƒ¼ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æ›´æ–°
            const nameField = document.getElementById(nameFieldId);
            const phoneField = document.getElementById(phoneFieldId);
            const emailField = document.getElementById(emailFieldId);
            
            if (nameField) nameField.value = name;
            if (phoneField) phoneField.value = phone;
            if (emailField) emailField.value = email;
            
            // æ¤œç´¢çµæœã‚’éš ã™ï¼ˆå®‰å…¨ã«å®Ÿè¡Œï¼‰
            if (nameField) {
                const positionRelative = nameField.closest('.position-relative');
                if (positionRelative) {
                    const searchResults = positionRelative.querySelector('.user-search-results');
                    if (searchResults) {
                        hideUserSearchResults(searchResults);
                    }
                }
            }
            
            // æˆåŠŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
            showMessage(`æ—¢å­˜ãƒ¦ãƒ¼ã‚¶ãƒ¼ã€Œ${name}ã€ã‚’é¸æŠã—ã¾ã—ãŸ`, 'success');
        }
        
        function hideUserSearchResults(resultsElement) {
            console.log('ğŸ” hideUserSearchResults called');
            if (resultsElement) {
                resultsElement.style.display = 'none';
                resultsElement.innerHTML = ''; // Also clear the content
                console.log('ğŸ” Search results hidden and cleared');
            } else {
                // Fallback for backward compatibility
                const searchResults = document.getElementById('userSelectionSearchResults');
                if (searchResults) {
                    searchResults.style.display = 'none';
                    searchResults.innerHTML = '';
                    console.log('ğŸ” Fallback search results hidden and cleared');
                } else {
                    console.log('ğŸ” Search results element not found for hiding');
                }
            }
        }

        // ã‚­ãƒ£ãƒ³ã‚»ãƒ«è¡¨ç¤ºã‚¨ãƒªã‚¢ã«äºˆç´„ã‚’è¿½åŠ 
        function addToCancellationDisplay(reservation) {
            if (!reservation) {
                console.error('âŒ Reservation is null or undefined');
                return;
            }
            
            // äºˆç´„ã®å®Ÿéš›ã®æ—¥ä»˜ã‚’ç‰¹å®š
            let actualReservationDate = null;
            
            // start_timeãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆã¯ãã‚Œã‚’ä½¿ç”¨ï¼ˆæœ€å„ªå…ˆï¼‰
            if (reservation.start_time) {
                actualReservationDate = new Date(reservation.start_time);
            } else {
                // reservationsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰æ¤œç´¢
                for (const dateKey of Object.keys(reservations)) {
                    const dayReservations = reservations[dateKey];
                    const foundReservation = dayReservations.find(r => r.id === reservation.id);
                    if (foundReservation) {
                        const [year, month, day] = dateKey.split('-').map(Number);
                        actualReservationDate = new Date(year, month - 1, day);
                        break;
                    }
                }
                
                // è¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯createdAtã‹ã‚‰è¨ˆç®—
                if (!actualReservationDate) {
                    actualReservationDate = new Date(reservation.createdAt);
                }
            }
            
            const cancellationData = {
                id: reservation.id,
                customer: reservation.customer,
                time: reservation.time,
                duration: reservation.duration,
                date: actualReservationDate.toLocaleDateString('ja-JP'),
                cancelledAt: new Date().toLocaleString('ja-JP')
            };
            
            cancelledReservations.unshift(cancellationData); // æœ€æ–°ã‚’å…ˆé ­ã«è¿½åŠ 
  
  // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜
            saveCancelledReservations();
            

            
            // å³åº§ã«æ›´æ–°ã‚’è©¦è¡Œï¼ˆæ¬¡ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã§å®Ÿè¡Œï¼‰
            requestAnimationFrame(() => {
                updateCancellationDisplayImmediately();
            });
        }

        // ã‚­ãƒ£ãƒ³ã‚»ãƒ«è¡¨ç¤ºã‚¨ãƒªã‚¢ã‚’æ›´æ–°ï¼ˆå³åº§ã«å®Ÿè¡Œï¼‰
        // ç¾åœ¨ã®é€±ã®ã‚­ãƒ£ãƒ³ã‚»ãƒ«å±¥æ­´ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
        function getCurrentWeekCancellations() {
            const weekStart = new Date(currentWeekStart);
            const weekEnd = new Date(currentWeekStart);
            weekEnd.setDate(weekEnd.getDate() + 6);
            
            return cancelledReservations.filter(reservation => {
                const reservationDate = new Date(reservation.date);
                return reservationDate >= weekStart && reservationDate <= weekEnd;
            });
        }

        function updateCancellationDisplayImmediately() {
            const btn = document.getElementById('showCancellationsBtn');
            const countSpan = document.getElementById('cancellation-count');
            const display = document.getElementById('cancellation-display');
            const list = document.getElementById('cancellation-list');
            
            // ç¾åœ¨ã®é€±ã®ã‚­ãƒ£ãƒ³ã‚»ãƒ«å±¥æ­´ã‚’å–å¾—
            const currentWeekCancellations = getCurrentWeekCancellations();
            
            console.log('ğŸ”„ Attempting to update cancellation display, total count:', cancelledReservations.length, 'current week:', currentWeekCancellations.length);
            console.log('ğŸ” Elements found:', { btn: !!btn, countSpan: !!countSpan, display: !!display, list: !!list });
            
            // ãƒœã‚¿ãƒ³ãŒå­˜åœ¨ã™ã‚‹å ´åˆã¯å³åº§ã«æ›´æ–°ï¼ˆspanãŒãªãã¦ã‚‚ãƒœã‚¿ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ç›´æ¥æ›´æ–°ï¼‰
            if (btn) {
                console.log('ğŸ”„ Updating cancellation display immediately, current week count:', currentWeekCancellations.length);
                
                // ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã‚’æ›´æ–°ï¼ˆspanãŒãªãã¦ã‚‚ç›´æ¥ãƒ†ã‚­ã‚¹ãƒˆã‚’æ›´æ–°ï¼‰
                if (currentWeekCancellations.length === 0) {
                    btn.disabled = false;
                    btn.textContent = `âŒ ã‚­ãƒ£ãƒ³ã‚»ãƒ«å±¥æ­´ (0)`;
                    if (display) {
                        display.style.display = 'none';
                    }
                    console.log('âœ… Updated cancellation display for 0 cancellations in current week');
    } else {
                    btn.disabled = false;
                    btn.textContent = `âŒ ã‚­ãƒ£ãƒ³ã‚»ãƒ«å±¥æ­´ (${currentWeekCancellations.length})`;
                    console.log('âœ… Updated cancellation display for', currentWeekCancellations.length, 'cancellations in current week');
                }
                
                // spanãŒå­˜åœ¨ã™ã‚‹å ´åˆã¯ãã‚Œã‚‚æ›´æ–°
                if (countSpan) {
                    countSpan.textContent = currentWeekCancellations.length;
                }
                
                // ãƒªã‚¹ãƒˆã‚’æ›´æ–°ï¼ˆè¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹å ´åˆã®ã¿ï¼‰
                if (display && display.style.display === 'block' && list) {
                    const listHtml = currentWeekCancellations.map(reservation => `
                        <div class="cancellation-item">
                            <div class="cancellation-info">
                                <div class="cancellation-customer">${reservation.customer}</div>
                                <div class="cancellation-details">
                                    ğŸ“… ${reservation.date} <span class="cancellation-time">${reservation.time}</span> | 
                                    â±ï¸ ${reservation.duration}åˆ† | 
                                    ğŸ—‘ï¸ ${reservation.cancelledAt}
                                </div>
                            </div>
                        </div>
                    `).join('');
                    
                    list.innerHTML = listHtml;
                }
            } else {
                if (!domReady) {
                    console.log('âš ï¸ DOM not ready yet, will update when ready');
                    // DOMãŒæº–å‚™ã§ãã¦ã„ãªã„å ´åˆã¯å¾Œã§æ›´æ–°
                    setTimeout(() => {
                        updateCancellationDisplayImmediately();
                    }, 200);
                } else {
                    console.log('âš ï¸ Cancellation button not found, will update later');
                    // è¦ç´ ãŒæº–å‚™ã§ãã¦ã„ãªã„å ´åˆã¯å¾Œã§æ›´æ–°ï¼ˆã‚ˆã‚Šé•·ã„é–“éš”ã§ï¼‰
                    setTimeout(() => {
                        updateCancellationDisplayImmediately();
                    }, 100);
                }
            }
        }

        // ã‚­ãƒ£ãƒ³ã‚»ãƒ«è¡¨ç¤ºã‚¨ãƒªã‚¢ã‚’æ›´æ–°ï¼ˆå¾…æ©Ÿç‰ˆï¼‰
        function updateCancellationDisplay() {
            // å³åº§ã«æ›´æ–°ã‚’è©¦è¡Œ
            updateCancellationDisplayImmediately();
        }

        // ã‚­ãƒ£ãƒ³ã‚»ãƒ«è¡¨ç¤ºã‚¨ãƒªã‚¢ã®è¡¨ç¤º/éè¡¨ç¤ºã‚’åˆ‡ã‚Šæ›¿ãˆ
        function toggleCancellationDisplay() {
            const display = document.getElementById('cancellation-display');
            const btn = document.getElementById('showCancellationsBtn');
            const list = document.getElementById('cancellation-list');
            
            // è¦ç´ ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³
            if (!display || !btn || !list) {
                console.error('âŒ Cancellation display elements not found');
                showMessage('ã‚­ãƒ£ãƒ³ã‚»ãƒ«è¡¨ç¤ºã‚¨ãƒªã‚¢ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚', 'error');
                return;
            }
            
            if (display.style.display === 'none') {
                // è¡¨ç¤ºã™ã‚‹
                display.style.display = 'block';
                btn.classList.add('active');
                
                // ç¾åœ¨ã®é€±ã®ã‚­ãƒ£ãƒ³ã‚»ãƒ«å±¥æ­´ã‚’å–å¾—ã—ã¦ãƒªã‚¹ãƒˆã‚’æ›´æ–°
                const currentWeekCancellations = getCurrentWeekCancellations();
                const listHtml = currentWeekCancellations.map(reservation => `
                    <div class="cancellation-item">
                        <div class="cancellation-info">
                            <div class="cancellation-customer">${reservation.customer}</div>
                            <div class="cancellation-details">
                                ğŸ“… ${reservation.date} <span class="cancellation-time">${reservation.time}</span> | 
                                â±ï¸ ${reservation.duration}åˆ† | 
                                ğŸ—‘ï¸ ${reservation.cancelledAt}
                            </div>
                        </div>
                    </div>
                `).join('');
                
                list.innerHTML = listHtml;
                
                showMessage('ã‚­ãƒ£ãƒ³ã‚»ãƒ«å±¥æ­´ã‚’è¡¨ç¤ºã—ã¾ã—ãŸã€‚', 'info');
            } else {
                // éè¡¨ç¤ºã«ã™ã‚‹
                display.style.display = 'none';
                btn.classList.remove('active');
                showMessage('ã‚­ãƒ£ãƒ³ã‚»ãƒ«å±¥æ­´ã‚’éè¡¨ç¤ºã«ã—ã¾ã—ãŸã€‚', 'info');
            }
        }

        // ã‚­ãƒ£ãƒ³ã‚»ãƒ«è¡¨ç¤ºã‚¨ãƒªã‚¢ã‚’ã‚¯ãƒªã‚¢
        function clearCancellationDisplay() {
            console.log('ğŸ—‘ï¸ Clearing cancellation display...');
            
            // ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢
            cancelledReservations = [];
            
            // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‹ã‚‰ã‚‚å‰Šé™¤
            localStorage.removeItem('cancelledReservations');
            
            // è¦ç´ ã‚’å–å¾—
            const display = document.getElementById('cancellation-display');
            const btn = document.getElementById('showCancellationsBtn');
            const countSpan = document.getElementById('cancellation-count');
            const list = document.getElementById('cancellation-list');
            
            // è¦ç´ ãŒå­˜åœ¨ã™ã‚‹å ´åˆã®ã¿æ“ä½œ
            if (btn && countSpan) {
                // ã‚«ã‚¦ãƒ³ãƒˆã‚’æ›´æ–°
                countSpan.textContent = '0';
                btn.textContent = 'âŒ ã‚­ãƒ£ãƒ³ã‚»ãƒ«å±¥æ­´ (0)';
                btn.disabled = false;
            }
            
            if (display) {
                display.style.display = 'none';
            }
            
            if (btn) {
                btn.classList.remove('active');
            }
            
            if (list) {
                list.innerHTML = '';
            }
            
            console.log('âœ… Cancellation display cleared successfully');
            
            // å³åº§ã«æ›´æ–°
            updateCancellationDisplayImmediately();
            
            showMessage('ã‚­ãƒ£ãƒ³ã‚»ãƒ«å±¥æ­´ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸã€‚', 'info');
        }
        
        // ã‚­ãƒ£ãƒ³ã‚»ãƒ«è¡¨ç¤ºã®åˆæœŸåŒ–ï¼ˆå³åº§ã«å®Ÿè¡Œï¼‰
        function initializeCancellationDisplay() {
            console.log('ğŸš€ Starting cancellation display initialization...');
            loadCancelledReservations();
            
            // å³åº§ã«æ›´æ–°ã‚’è©¦è¡Œ
            setTimeout(() => {
                updateCancellationDisplayImmediately();
                cancellationDisplayReady = true;
                console.log('âœ… Cancellation display initialized successfully');
            }, 100);
        }
        
        // åˆæœŸåŒ–å®Ÿè¡Œ
        init();
        
        // DOMãŒå®Œå…¨ã«èª­ã¿è¾¼ã¾ã‚Œã¦ã‹ã‚‰ã‚­ãƒ£ãƒ³ã‚»ãƒ«è¡¨ç¤ºã‚’åˆæœŸåŒ–
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                domReady = true;
                setTimeout(() => {
                    initializeCancellationDisplay();
                }, 100);
            });
        } else {
            // DOMãŒæ—¢ã«èª­ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹å ´åˆ
            domReady = true;
            setTimeout(() => {
                initializeCancellationDisplay();
            }, 100);
        }
        
        // ãƒ¦ãƒ¼ã‚¶ãƒ¼æ¤œç´¢æ©Ÿèƒ½ã‚’åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', function() {
            setupUserSearch();
        });
        
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•°ã¨ã—ã¦å…¬é–‹ï¼ˆonclickå±æ€§ã§ä½¿ç”¨ã•ã‚Œã‚‹é–¢æ•°ï¼‰
        window.openBookingModal = openBookingModal;
        window.openBreakModal = openBreakModal;
        window.closeSlotOptionsMenu = closeSlotOptionsMenu;
        window.openBulkReservationModal = openBulkReservationModal;
        window.closeBulkReservationModal = closeBulkReservationModal;
        window.previewBulkReservations = previewBulkReservations;
        window.createBulkReservations = createBulkReservations;
        window.openSettingsModal = openSettingsModal;
        window.closeSettingsModal = closeSettingsModal;
        window.switchTab = switchTab;
        window.saveSettings = saveSettings;
        window.openUserSelectionModal = openUserSelectionModal;
        window.closeUserSelectionModal = closeUserSelectionModal;
        window.saveUserSelection = saveUserSelection;
        window.selectUserForModal = selectUserForModal;
        window.selectUser = selectUser;
        window.previousWeek = previousWeek;
        window.nextWeek = nextWeek;
        window.toggleMiniCalendar = toggleMiniCalendar;
        window.previousMiniCalendarYear = previousMiniCalendarYear;
        window.previousMiniCalendarMonth = previousMiniCalendarMonth;
        window.nextMiniCalendarMonth = nextMiniCalendarMonth;
        window.nextMiniCalendarYear = nextMiniCalendarYear;
        window.toggleCancellationDisplay = toggleCancellationDisplay;
        window.clearCancellationDisplay = clearCancellationDisplay;
        window.closeBookingModal = closeBookingModal;
        window.createBooking = createBooking;
        window.closeBreakModal = closeBreakModal;
        window.createBreak = createBreak;
        window.closeBreakDetailModal = closeBreakDetailModal;
        window.saveBreakChanges = saveBreakChanges;
        window.deleteBreakReservation = deleteBreakReservation;
        window.closeReservationDetailModal = closeReservationDetailModal;
        window.toggleDay = toggleDay;
        window.addTimeSlot = addTimeSlot;
        window.removeTimeSlot = removeTimeSlot;
        window.updateIntervalOnChange = updateIntervalOnChange;
        window.handleBreakTitleChange = handleBreakTitleChange;
        window.handleEditBreakTitleChange = handleEditBreakTitleChange;
        window.updateCalendarOnStatusChange = updateCalendarOnStatusChange;
        window.updateCalendarOnCourseChange = updateCalendarOnCourseChange;
        window.updateTimeSlot = updateTimeSlot;
        window.saveReservationChanges = saveReservationChanges;
        
        console.log('âœ… All global functions exposed for onclick attributes');
        })(); // IIFEã‚’é–‰ã˜ã‚‹
</script> 
</body>
</html> 